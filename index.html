<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录我的前端学习">
<meta property="og:type" content="website">
<meta property="og:title" content="Hello!">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hello!">
<meta property="og:description" content="记录我的前端学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Geylnu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hello!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/10/%E8%AF%B4%E8%AF%B4Vue3%E7%9A%84watchEffect%E4%B8%8EReact-Hooks%E7%9A%84useEffect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/%E8%AF%B4%E8%AF%B4Vue3%E7%9A%84watchEffect%E4%B8%8EReact-Hooks%E7%9A%84useEffect/" class="post-title-link" itemprop="url">说说Vue3的watchEffect与React Hooks的useEffect</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-10 11:19:59" itemprop="dateCreated datePublished" datetime="2020-10-10T11:19:59+00:00">2020-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近有空阅读了一下 Vue3 的文档，发现 Vue 也新增了类似 React Hooks 中的 useEffect 的 watchEffect，两者基本很相似，这里就来比较比较。</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h3><p>React Hooks 带有一种函数式的设计理念，期望 <code>UI = f(x)</code>，UI 是纯函数的渲染结果，useEffect 则用来处理副作用，也就是对外部环境的影响，在 Hooks 中基本取代了生命周期的概念,类似于原本的<code>componentDidMount</code>和<code>componentWillUnmount</code>。</p>
<p>常见的在 useEffect 中请求数据</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> example = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hasCancle = <span class="literal">false</span>;</span><br><span class="line">    query(<span class="string">&quot;/xxxx&quot;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 避免副作用被取消后仍然调用</span></span><br><span class="line">      <span class="keyword">if</span> (!hasCancle) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = data;</span><br><span class="line">        setCount(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除副作用</span></span><br><span class="line">      hasCancle = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a><code>watchEffect</code></h3><p>watchEffect 作用基本与 useEffect 作用一致，上面的代码可以很方便的改写为 Vue 版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    watchEffect( <span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> hasCancle = <span class="literal">false</span>;</span><br><span class="line">      query(<span class="string">&quot;/xxxx&quot;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasCancle) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; count &#125; = data;</span><br><span class="line">          setCount(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      onInvalidate(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          hasCancle = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管功能上 watchEffect 与 useEffect 十分相似，但由于实现不一，实质还是有很多不同</p>
<h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>在 React 中，<code>useEffect</code>被用来处理与界面无关的副作用，会在 React 更新 DOM 后调用，这样可以尽快的展现渲染结果，如果涉及到对 DOM 的副作用操作，则可以使用<code>useLayoutEffect</code>在重渲染期间调用，以避免浏览器重渲染。</p>
<p>而在 Vue 中，watchEffect 的调用时机则由<code>watchEffect</code>函数的第二个参数控制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(</span><br><span class="line">  (onInvalidate) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do xxx</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">&quot;pre&quot;</span>, <span class="comment">// &#x27;pre&#x27; | &#x27;post&#x27; | &#x27;sync&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>watchEffect 的默认调用时机<code>pre</code>，按照官方文档，它有两次调用时机</p>
<ul>
<li>在初始化时被同步调用</li>
<li>在组件被更新前</li>
</ul>
<p>watchEffect 类似于<code>beforeCreate</code>与<code>beforeUpdate</code>，但是实际还是有不小区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;beforeCreate&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    watchEffect(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;watchEffect sync&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(count.value);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flush: <span class="string">&quot;sync&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;watchEffect pre&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watchEffect(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;watchEffect post&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(count.value);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flush: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    onBeforeMount(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;beforeMount&quot;</span>));</span><br><span class="line">    onMounted(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;onMounted&quot;</span>));</span><br><span class="line">    onBeforeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;onBeforeUpdate&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUpdated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;onUpdated&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sync setup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码调用顺序会是这样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchEffect sync</span><br><span class="line">watchEffect pre</span><br><span class="line">sync setup</span><br><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">watchEffect post</span><br><span class="line">onMounted</span><br></pre></td></tr></table></figure>

<p>我们可以看到 setup 函数里所有的内容都会被首先被调用，调用时机为 <code>pre</code> 和 <code>sync</code> 的 watchEffect 函数也会被同步调用，调用顺序取决于声明顺序，而调用时机为<code>post</code>的 watchEffect 函数 则会在 DOM 元素挂载后调用。</p>
<p>对于三种不同刷新方式，其实可以很简单的理解：</p>
<ul>
<li><code>pre</code> 初始化会在 setup 函数中被同步调用，此后总在组件更新前调用</li>
<li><code>post</code> 初始化会在元素挂载后，此后总在组件更新后调用，总能获取实际的渲染结果</li>
<li><code>sync</code> 初始化会在 setup 函数中被同步调用，此后总在状态更改时同步调用</li>
</ul>
<p>当然。在大多数情况下，我们其实不需要关心时机，仅在涉及到对 DOM 的副作用时做下区分，比如获取 ref</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button ref&#x3D;&quot;buttonRef&quot; @click&#x3D;&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; watchEffect, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const count &#x3D; ref(0);</span><br><span class="line">    const buttonEL &#x3D; ref(null);</span><br><span class="line">    watchEffect(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(buttonRef.value?.innerText); &#x2F;&#x2F; 初始化: undefined 第一次调用: count is 0</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watchEffect(</span><br><span class="line">      () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(buttonRef.value?.innerText); &#x2F;&#x2F; 初始化: &lt;button&gt; 第一次调用: count is 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flush: &quot;post&quot;,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>flush: &quot;post&quot;</code>,可以保证总是获取到最新的 DOM。</p>
<p>总的来说，Vue 和 React 在处理副作用上走上了不同的道路，React 倾向于尽快的进行重渲染，在渲染结束后执行副作用以避免 UI 线程等待；而 Vue 默认会在渲染更新前调用，更新的结果会直接体现在这次的渲染结果中。</p>
<h4 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h4><p>在 React 中，<code>useEffect</code>经常出现的错误就是进行了递归的重渲染</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(count + <span class="number">1</span>); <span class="comment">// 这会导致递归调用,setCount触发了重渲染，副作用重新执行</span></span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<p>在 Vue 中，如果这个值仅被单个副作用函数依赖则并不会导致递归调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>值会正确的更新，同时这次的副作用不会被更新。</p>
<p>然而如果被多个副作用函数依赖，或者被异步调用，仍然会导致递归调用</p>
<p>多个依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count.value++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总而言之，在 watchEffect 应该尽量小心的更新值。</p>
<h4 id="取消副作用"><a href="#取消副作用" class="headerlink" title="取消副作用"></a>取消副作用</h4><p>在 React 中，取消副作用的函数通过函数返回值返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do xxxxx</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而在异步函数中这会存在问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> fetchData(props.id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do xxxxx</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步函数返回的是一个 promise,我们无法在异步调用完成前拿到取消函数。</p>
<p>因此，为了更好地与 asnyc 函数调用兼容，在Vue中，取消函数以回调的方式注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line">watchEffect(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 我们在Promise解析之前注册清除函数</span></span><br><span class="line">  data.value = <span class="keyword">await</span> fetchData(props.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>Vue 由于响应式原理，可以自动的进行依赖收集，React 则需要手动填写依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;, [count]); <span class="comment">//手动声明依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count.value); <span class="comment">// 在每次更改count时都会调用。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue 会在第一次运行副作用函数执行时进行自动的依赖收集，类似于目前的<code>computed</code>属性。<br>然而，依赖收集只发生在同步调用时，Vue 无法知道异步调用时使用的依赖，</p>
<p>比如下面这个例子，来自于 github 上的一个<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/issues/2223" title="watchEffect doesn&#39;t work when perform async ">issues</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffectTest</span>(<span class="params">reactive, watchEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = reactive(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  watchEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timmer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obj.age++;</span><br><span class="line">    <span class="keyword">if</span> (obj.age &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timmer);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;stop&quot;</span>, obj.age);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    watchEffectTest(reactive, watchEffect);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>预期输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">stop 6</span><br></pre></td></tr></table></figure>

<p>实际输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">stop 6</span><br></pre></td></tr></table></figure>

<p>当然，这种缺陷也可以通过手动的读取一次依赖，告诉Vue这是依赖项，仅仅是在编写时会并不优雅。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/Cookie-Session%E4%B8%8ELocalStorage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/02/Cookie-Session%E4%B8%8ELocalStorage/" class="post-title-link" itemprop="url">Cookie,Session与LocalStorage</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-02 19:42:11" itemprop="dateCreated datePublished" datetime="2020-10-02T19:42:11+00:00">2020-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Cookie由来"><a href="#Cookie由来" class="headerlink" title="Cookie由来"></a>Cookie由来</h1><p>谈到Cookie不得不谈到http协议，wiki上的定义⬇</p>
<blockquote>
<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p>
</blockquote>
<p>由于这个设计目的，早期http协议被设计为无状态的协议，一个HTTP协议通信过程往往是建立连接&gt;传输内容&gt;关闭连接，整个过程十分简单。</p>
<p>然而万维网发展的比想象中快太多，HTML不再只是单纯的文档，还被用于交互，有了登陆注册等保存状态的需要，然而http协议是无状态的，这个场景需要下，Cookie就诞生了。</p>
<h1 id="Cookie具体是怎么样的？"><a href="#Cookie具体是怎么样的？" class="headerlink" title="Cookie具体是怎么样的？"></a>Cookie具体是怎么样的？</h1><p>Cookie其实就是一段文本信息，由浏览器储存在本地硬盘上，服务器通过<code>Set-Cookie</code>设置Cookie，浏览器通过<code>Cookie</code>字段附上设置的Cookie信息。</p>
<p>emm，还是看一个完整的请求吧</p>
<hr>
<p><strong>响应</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 ok</span><br><span class="line">Date: Sat, 02 Feb 2019 14:24:28 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 182</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: tgw_l7_route&#x3D;80f350dcd7c650b07bd7b485fcab5bf7; Expires&#x3D;Sat, 02-Feb-2019 14:39:28 GMT; Path&#x3D;&#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>下次请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: tgw_l7_route&#x3D;80f350dcd7c650b07bd7b485fcab5bf7</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a><code>Set-Cookie</code></h2><p>服务端通过在响应头中添加<code>Set-Cookie: xxx=xxx</code>的方式以键值对的形式设置Cookie，除此之外还有其它字段可以控制Cookie的字段</p>
<ul>
<li><p><code>Domain</code><br>指定Cookie从属于那个域名，在请求对应域名时会带上这个Cookie，默认为当前文档域名，<strong>不包含子域名</strong>，若主动设置<code>Domain</code>,则一般会包含子域名，例如设置了<code>Domain=geylnu.com</code>,则<code>blog.geylnu.com</code>也是可以访问这个<code>geylnu.com</code>的Cookie。</p>
</li>
<li><p><code>Path</code><br>在域名符合的前提下，如果请求的路径与<code>Path</code>的路径相匹配就在请求中附上这个Cookie，路径匹配从前到后匹配，以<code>/</code>作为分隔符</p>
</li>
<li><p><code>Expires</code><br>在指定日期Cookie到期，Cookie到期后服务器会自动删除这个Cookie，设置时间格的式为<code>Thu, 01 Jan 1970 00:00:00 GMT</code>这样的格林尼治标准时间，没有设置该属性或<code>Max-age</code>，Cookie会自动在浏览器关闭后清除。值得注意的是响应头中的时间是基于服务器时间生成的，而客户端的时间可能与服务端不一致，这种情况下使用<code>max-age</code>属性设置过期时间是一个更好的选择。</p>
</li>
<li><p><code>Max-age</code><br>在指定秒后Cookie到期，作用等同于<code>Expires</code>，当同时设置了<code>Expires</code>和<code>Max-age</code>时，<code>Max-age</code>优先级更大；由于不直接设置时间，规避了服务端时间和客户端时间可能不一致的问题。</p>
</li>
<li><p><code>Http-only</code><br>Cookie只允许浏览器发出请求时在<code>Cookie</code>中附带上，通过<code>Set-Cookie</code>修改，不允许通过js脚本得到拿到，这可以有效的防止<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="什么是xss攻击？">XSS攻击</a></p>
</li>
<li><p><code>Secure</code><br>指定该Cookie只在加密协议（https）才能把这个Cookie发送到服务器，如果设置该属性是通过http协议设置的，浏览器会自动忽略该属性（自动纠错，因为http下设置这个属性没有意义）。如果协议为<code>https</code>，该属性默认打开</p>
</li>
</ul>
<p>一个完整的Cookie设置示范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sessionId&#x3D;hihihi; Expirers&#x3D;Wed, 01 Jan 2020 00:00:00 GMT; Max-age&#x3D;10000; Http-only; Secure;</span><br></pre></td></tr></table></figure>
<h2 id="js操作方式"><a href="#js操作方式" class="headerlink" title="js操作方式"></a>js操作方式</h2><p>读</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie <span class="comment">//返回&quot;xx=xxx; yy=yyy&quot;</span></span><br></pre></td></tr></table></figure>
<p>写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;xxx=hihihi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里由于设定了<code>get</code>和<code>set</code>属性，读是一次读写全部Cookie，写为一个个Cookie单独设置。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>好了，现在http协议支持将状态保存在客户端了，之后每个客户端都是有名有姓的人了。<br>但是客户端保存状态信息是不可靠的，客户端可以修改自己本地的Coookie值，Cookie值在非<code>https</code>加密协议的情况下，也容易被截获获取到敏感信息（这里吐槽下我校教务系统，密码明文直接写在Cookie中）。</p>
<p>对应的解决方法就是在服务端也维护对应的状态，大部分状态信息都由服务端记录，客户端只需要记录一个由服务端随机生成的sessionId用于服务端识别，这就是Session了，一般Session储存在内存，也有其它实现，甚至无Session的方式。</p>
<h1 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h1><p>由于Cookie在每个请求中都会被添加，网络开销很大，很多非敏感状态信息也不需要服务器来存储，Cookie的大小有也很小，只有4kb；为了解决这个问题，HTML5规范就提出了LocalStorage，LocalStorage和cookie一样都是存在本地电脑磁盘上，数据形式也是hash表，存储形式也都是字符串。</p>
<p>不过和cookie不同的是LocalStorage不会跟随请求发送，仅限通过浏览器api操作，储存空间一般为5M大小，远大于cookie可以使用的空间，并且没有过期期限，除非用户主动清理会一直存在，通常在能用LocalStorage的地方尽量都用LocalStorage，前端不应该使用Cookie。</p>
<h1 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h1><p>sessionStorage与LocalStorage基本相同，只是sessionStorage过期不同，另外还有个显著的特点：sessionStorage会在窗口创建时初始化一个新的会话，也就是即使是同一个域名下不同窗口，sessionStorage也是不一样的。同时，在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点与使用cookie作为凭证是相似的。</p>
<h2 id="js操作方式-1"><a href="#js操作方式-1" class="headerlink" title="js操作方式"></a>js操作方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="built_in">localStorage</span>.remove(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">localStorage</span>.clear()<span class="comment">//移除全部</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/%E8%AF%B4%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/%E8%AF%B4%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" class="post-title-link" itemprop="url">说说浏览器下载的那些事儿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 11:47:29" itemprop="dateCreated datePublished" datetime="2020-09-25T11:47:29+00:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近突然在 chrome 85 版本上遇到下载后会出现”xxx 下载方式实属异常 因此它可能存在危险”，去看了下相关的谷歌博客，定位是谷歌的浏览器安全策略引起的。<br>实际上浏览器下载还有不少坑，这次就接这个机会总结一下。</p>
<h2 id="前端如何实现文件下载？"><a href="#前端如何实现文件下载？" class="headerlink" title="前端如何实现文件下载？"></a>前端如何实现文件下载？</h2><h3 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h3><p>在 download 属性出现之前，前端实现文件下载实际上依赖于浏览器的默认行为，也就是打开链接。</p>
<p>通常我们可以直接这样实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;http://xxxx&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.open(url);</span><br></pre></td></tr></table></figure>

<p>这会以指定的 url 打开一个新窗口，浏览器在根据 url 获得到服务器的响应，判断出这不是一个浏览器可以打开的文件类型，就自动会转为下载。</p>
<p>在段代码在正常情况下是能够工作正常的，然而实际上有些业务场景，下载链接是后台生成的，我们需要这样做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clickHandle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  api.get(<span class="string">&#x27;xxx&#x27;</span>, params).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = response.data;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="keyword">let</span> url = data.data.url || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="built_in">window</span>.open(url);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在几乎所有的现代浏览器上都会被阻止，在 Chrome 上会在地址栏显示被拦截的标志，用户需要手动点击才能成功，Safari 会静默失效。<br>这是由于早期网页经常在页面插入自动打开广告页面，带来很糟糕的用户体验，因此浏览器做了限制，会禁止所有的异步回调中调用的 window.open()</p>
<p>当然了，浏览器限制也拦不过各种奇思妙想，既然无法在异步代码中调用 window.open()，那先在同步代码中调用，等待异步调用完成，改变新开的浏览器窗口的 url 就好了。<br>下面的代码就是一种实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clickHandle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> windowObjectReference = <span class="built_in">window</span>.open(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  api.get(<span class="string">&#x27;xxx&#x27;</span>, params).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = response.data;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="keyword">let</span> url = data.data.url || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        windowObjectReference.location.href = url;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上述的原因，使用了 window.open(), 无法打开页面是很容易发生的事，这时 window.open(）会返回 null，需要做一些失败后的处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.open(<span class="string">&quot;xxxx&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// do xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="window-location-href"><a href="#window-location-href" class="headerlink" title="window.location.href"></a>window.location.href</h3><p>尽管可以以上面的方式绕过浏览器的安全限制，然而这种行为是不确定，永远无法知道浏览器会在哪一个版本改变这种做法，更安全的行为是使用 window.location.href</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.herf = <span class="string">&quot;http://xxxx&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式下载是手动让浏览器跳转到指定页面，浏览器发现是不支持预览的文件类型，自动转为下载，由于浏览器加载链接到发现这是一个应该下载的资源需要一定时间，这会造成页面白屏一段时间，表现的像是页面闪动一样</p>
<p>为了避免闪动，也有人想出了在 iframe 中调用 window.location.href 中的办法，由于链接是在 iframe 里加载的，也就不会出现闪动了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无闪现下载excel</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  iframe.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">iframeLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;iframe onload&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> win = iframe.contentWindow;</span><br><span class="line">    <span class="keyword">const</span> doc = win.document;</span><br><span class="line">    <span class="keyword">if</span> (win.location.href === url) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doc.body.childNodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// response is error</span></span><br><span class="line">      &#125;</span><br><span class="line">      iframe.parentNode.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;onload&quot;</span> <span class="keyword">in</span> iframe) &#123;</span><br><span class="line">    iframe.onload = iframeLoad;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iframe.attachEvent) &#123;</span><br><span class="line">    iframe.attachEvent(<span class="string">&quot;onload&quot;</span>, iframeLoad);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iframe.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="title">onreadystatechange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (iframe.readyState === <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">        iframeLoad;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  iframe.src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">loadUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.contentWindow.location.href = url;</span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 iframe 的顾虑和使用 window.open 的顾虑一样，这依赖于浏览器的默认安全策略，我们无法知道浏览器会在哪天把创建 iframe 进行下载定义为危险的行为并进行拦截。</p>
<h3 id="使用-lt-a-gt-标签"><a href="#使用-lt-a-gt-标签" class="headerlink" title="使用 &lt;a&gt; 标签"></a>使用 &lt;a&gt; 标签</h3><p>这实际上是目前大多数前端下载库的实现方式，会动态创建一个隐藏的 &lt;a&gt; 标签，通过 Blob 转换为 data 链接，点击这个 data 链接，浏览器会默认将这个文件 data 链接的内容进行保存。<br>15k start 的<a target="_blank" rel="noopener" href="https://github.com/eligrey/FileSaver.js">FileSaver.js</a>就是这样实现的。</p>
<p>这样的方式相比直接打开或者直接使用链接的好处在于许多文件类型可以下载，而不是变为预览。</p>
<p>除此之外，&lt;a&gt; 还能支持 download 属性，这是真正的浏览器语义上的下载属性，以上除 data 链接的方式，浏览器都会抛出控制台警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource interpreted as Document but transferred with MIME type application xxx</span><br></pre></td></tr></table></figure>

<p>浏览器的请求头会附带这样的 Accept 头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: xxxx</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br></pre></td></tr></table></figure>

<p>使用 download 属性后，浏览器发出的请求头会像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: xxxx</span><br></pre></td></tr></table></figure>

<p>浏览器不会带上 Accept 头，甚至请求也不会出现在开发者工具中，会直接进行下载。</p>
<p>虽然 download 属性非常好用，但是还有一些限制：</p>
<blockquote>
<p>此属性仅适用于同源 URL<br>尽管 HTTP URL 需要位于同一源中，但是可以使用 blob: URL 和 data: URL ，以方便用户下载使用 JavaScript 生成的内容（例如使用在线绘图 Web 应用程序创建的照片）。<br>如果 HTTP 头中的 Content-Disposition 属性赋予了一个不同于此属性的文件名，HTTP 头属性优先于此属性。</p>
</blockquote>
<p>download 属性支持所有现代浏览器，而 IE 理所当然的不支持，需要进行一些特殊处理。</p>
<h2 id="后端如何实现文件下载？"><a href="#后端如何实现文件下载？" class="headerlink" title="后端如何实现文件下载？"></a>后端如何实现文件下载？</h2><h3 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h3><p>实际上，在 HTTP 响应中加上 Content-Disposition 是浏览器兼容性最好的下载方式，大多数的浏览器都支持这种方式.</p>
<p>Content-Disposition 可以指定浏览器是以附件的形式下载文件，还是以页面的一部分预览展示,同时也可以指定文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: inline</span><br><span class="line">Content-Disposition: attachment</span><br><span class="line">Content-Disposition: attachment; filename&#x3D;&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure>

<h2 id="还存在的一些问题"><a href="#还存在的一些问题" class="headerlink" title="还存在的一些问题"></a>还存在的一些问题</h2><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>IOS 由于系统是每个应用都是一个沙盒，没有为用户暴露文件系统，如果用户 IOS 手机上没有安装对应的打开软件是无法进行下载的。</p>
<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>在最新的谷歌浏览器版本中(chrome 84+)，会开始逐渐限制 https 网站下载 http 内容，其中可执行文件 exe、压缩文件都会警告下载方式十分危险，并且在未来可能所有通过 http 下载的可执行内容都会被阻止。尽管理解谷歌这种方式可能是为了防止中间人攻击替换下载内容，不过推进方式还是蛮激进的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/24/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">自己来实现观察者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-24 23:22:08" itemprop="dateCreated datePublished" datetime="2020-09-24T23:22:08+00:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="自己来实现观察者模式"><a href="#自己来实现观察者模式" class="headerlink" title="自己来实现观察者模式"></a>自己来实现观察者模式</h1><p>今天写自己一个小demo时使用mvc的时候，想自己来实现观察者模式<br>也就是view层会观察model层数据的变化，相应渲染出改变后的数据</p>
<h1 id="使用发布订阅模式"><a href="#使用发布订阅模式" class="headerlink" title="使用发布订阅模式"></a>使用发布订阅模式</h1><p>最开始想的办法是自己model拥有多个修改<code>model.data</code>的方法，如<code>fetch()</code>,<code>patch()</code>,<code>delete()</code>,<code>post()</code>,只需要每个方法里加一句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.emit(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="built_in">this</span>.data)</span><br></pre></td></tr></table></figure>
<p>就能通知在监听的view层进行渲染了</p>
<p>不过有点不优雅，我需要在每个改变数据的方法后都加一句，很麻烦。</p>
<h1 id="使用Object-defineProperty来自动化"><a href="#使用Object-defineProperty来自动化" class="headerlink" title="使用Object.defineProperty来自动化"></a>使用Object.defineProperty来自动化</h1><p>之后想到了ES5提供的**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>**提供的<code>get</code>和<code>set</code>存取描述符，对这个属性的访问和读取会分别触发<code>get</code>和<code>set</code>函数, 也就是如果对<code>data</code>进行设置，就会触发<code>set</code>函数。</p>
<h2 id="get-和set-又是什么？"><a href="#get-和set-又是什么？" class="headerlink" title="get()和set()又是什么？"></a><code>get()</code>和<code>set()</code>又是什么？</h2><p>我们平常取值或者赋值都是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.val = <span class="number">1</span> <span class="comment">//现在val = 1</span></span><br><span class="line">data.val  <span class="comment">//得到 val的值</span></span><br></pre></td></tr></table></figure>
<p>在这个过程中，val就是一个值，获得val和修改val总是相等的，修改成多少，之后就会得到多少。</p>
<p>不过js是门很奇怪的语言，有时候会发现获得的值和修改的值不一样，比如<code>cookie</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie <span class="comment">//xxx=111; yyy=222;</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;zzz=333&quot;</span></span><br><span class="line"><span class="built_in">document</span>.cookie <span class="comment">//xxx=111; yyy=222; zzz=333</span></span><br></pre></td></tr></table></figure>
<p>看这里，赋值和取值并不相等，就像是自己调用的是方法一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie.get() <span class="comment">//xxx=111; yyy=222</span></span><br><span class="line"><span class="built_in">document</span>.cookie.set(<span class="string">&quot;zzz=333&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.cookie.get() <span class="comment">//xxx=111; yyy=222; zzz=333</span></span><br></pre></td></tr></table></figure>
<p>似乎是这样的感觉。<br>原理也就是这样，在js中我们可以把赋值这个过程当成函数调用<br>赋值调用<code>set</code>函数 ,取值使用<code>get</code>函数。</p>
<p>ES5就提供了<code>Object.defineProperty</code>来自己定义赋值和取值得行为<br><code>Object.defineProperty</code>接受三个参数，要定义的对象，要定义的键名，定义行为的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookieList = []</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">document</span>,<span class="string">&#x27;myCookie&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cookieString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        cooieList.forEach(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            cookieString+value+<span class="string">&#x27;; &#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> cookieString</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        cookieList.push(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.myCookie <span class="comment">// &quot;&quot; 空字符串</span></span><br><span class="line"><span class="built_in">document</span>.myCookie = <span class="string">&quot;aaa=111&quot;</span></span><br><span class="line"><span class="built_in">document</span>.myCookie <span class="comment">//&quot;aaa=111; &quot;</span></span><br><span class="line"><span class="built_in">document</span>.myCookie = <span class="string">&quot;bbb=222&quot;</span></span><br><span class="line"><span class="built_in">document</span>.myCookie <span class="comment">//&quot;aaa=111; bbb=222&quot;</span></span><br></pre></td></tr></table></figure>
<p>这就是我们仿写的一个cookie，取值变成了调用<code>get</code>函数，赋值变成了调用<code>set()</code>函数<br>ES6有了定义对象的语法糖，也更简洁明了些</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Barack&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Obama&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123; <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nameArray = value.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        firstName = nameArray[<span class="number">0</span>]</span><br><span class="line">        lastName = nameArray[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">//Barack Obama</span></span><br><span class="line">person.name  = <span class="string">&#x27;Karl Marx&#x27;</span></span><br><span class="line">firstName  <span class="comment">//Karl</span></span><br><span class="line">lastName <span class="comment">//Marx</span></span><br></pre></td></tr></table></figure>
<p>其实在这里设置<code>get</code>和<code>set</code>, 有点像java, java中一切皆对象，类中常常有私有变量不能被外部访问，就通过<code>getName()</code>和<code>setName()</code>暴露api<br>通过这种方式，就能对赋值和取值进行控制，比如赋值的时候检测值是否合法这些，js就直接省略了写函数这部分，直接就能把赋值、取值的行为当作函数调用。<br>不过这种也很误导，赋值和取值竟然会不相等，那为什么不直接告诉我这是一个方法？实际情况下不应该胡乱使用<code>get</code>和<code>set</code></p>
<hr>
<p>另外查了下，语法似乎更像c#</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class example</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> a &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> b &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> c &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，回到正题，现在我们可以在赋值时，通知View层数据改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do xxxxx</span></span><br><span class="line">        event.emit(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="built_in">this</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.data = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">//触发set()</span></span><br></pre></td></tr></table></figure>

<p>不过马上就发现<code>Object.defineProperty</code> 并不怎么好用</p>
<ol>
<li><p><code>get</code> <code>set</code>存取描述符会导致递归问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data = value</span><br><span class="line">        event.emit(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="built_in">this</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.data <span class="comment">//递归调用 页面会卡死</span></span><br></pre></td></tr></table></figure>
<p> 解决办法很简单,不使用data就可以了，比如使用<code>this._data</code>，或者使用闭包，利用外部环境的变量。</p>
</li>
<li><p>如果<code>model.data</code>的值不是原始类型，而是对象，那么对<code>model.data</code>对象的的更改不会触发<code>set()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._data = value</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.data <span class="comment">//get</span></span><br><span class="line">model.data.push(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">//get</span></span><br><span class="line"><span class="keyword">let</span> data = model.data <span class="comment">//get</span></span><br><span class="line">data.push(&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="comment">//不会调用get set</span></span><br><span class="line">data <span class="comment">//不会调用get</span></span><br></pre></td></tr></table></figure>
<p> 在实际情况中，往往<code>data</code>都是一堆对象，存储的是引用，解决办法大概可以判断是否是对象，如果是，就递归的定义<code>get</code>和<code>set</code>,或者判断这是否是一个会更改<code>data</code>的函数,总而言之是件挺麻烦的事</p>
</li>
<li><p><code>Object.defineProperty</code>只能设置已知的属性，不能对未知的属性进行设置<br> 这就导致上面递归解决方案行不通，因为在运行时定义的属性的key是未知的，以就无法设置<code>get</code>,<code>set</code></p>
</li>
</ol>
<h1 id="使用Proxy来更优雅的实现"><a href="#使用Proxy来更优雅的实现" class="headerlink" title="使用Proxy来更优雅的实现"></a>使用Proxy来更优雅的实现</h1><p><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/proxy">关于Proxy的说明可以点击这里</a>,Proxy可以看作是<code>Object.defineProperty()</code>的完全升级版，可以拦截各种对对象的操作，其中就包括<code>get</code>和<code>set</code>，Vue3就是基于<code>Proxy</code>来实现响应式跟踪的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = []</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(array,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target,key,value,receiver</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`set <span class="subst">$&#123;key&#125;</span>`</span>) </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value,receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> model=&#123;data&#125;</span><br><span class="line">model.data.push(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">//set 0  set length   这里push操作会修改&#x27;0&#x27;和&#x27;length&#x27;</span></span><br><span class="line">array.push(&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="comment">//原对象不会触发set</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy</code>翻译为代理，其实挺贴切的，从上面的例子中可以看出，<code>Proxy</code>并不会修改原始对象的行为，而是会生成一个代理对象，用于拦截各种操作。</p>
<p>同时浏览器还提供了<code>Reflect</code>用来更好的扩展默认行为，阮一峰在ES6文中是这样说的:</p>
<blockquote>
<p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
</blockquote>
<p>这个概念类似于子类重写父类的行为一样，可以让我们方便的在原来逻辑基础上添加一扩展行为。</p>
<p>最后贴下大概的最终代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//能够检测所有变动的核心，递归检测所有赋值为对象的情况，并代理这个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyAllobj</span>(<span class="params">target, key, value, receiver,handler</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET key:<span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    排除value 为null的情况，因为typeof null === &#x27;object&#x27;</span></span><br><span class="line"><span class="comment">    如果这个对象已经是被代理的对象了，不重新代理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ( value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">Reflect</span>.get(target, <span class="string">&#x27;_isProxy&#x27;</span>, receiver) !== <span class="literal">true</span>) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="built_in">Proxy</span>(value, handler)  <span class="comment">//使用新的代理对象替换原对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`正在代理化<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">let</span> obj = value</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> newKey <span class="keyword">in</span> obj) &#123;     <span class="comment">//递归检测这个对象中的对象</span></span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(newKey)) &#123;</span><br><span class="line">                <span class="keyword">const</span> nextValue = obj[newKey];</span><br><span class="line">                proxyAllobj(obj, newKey, nextValue, obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`GET key:<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">&#x27;_isProxy&#x27;</span>) &#123; <span class="comment">//由于无法判断一个对象是否为代理对象，所以使用一个预留字段来检测是否为代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyAllobj(target, key, value, receiver,handler)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="built_in">Proxy</span>([], handler)</span><br><span class="line"></span><br><span class="line">data.push(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ddd = <span class="number">2</span></span><br><span class="line">data.push(&#123; ddd &#125;)</span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">data[<span class="number">1</span>] = &#123; <span class="attr">aaa</span>: &#123; <span class="attr">hi</span>: <span class="string">&#x27;hi&#x27;</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>].aaa.hi = <span class="number">5</span> <span class="comment">//能够检测到</span></span><br><span class="line"><span class="keyword">const</span> test = data[<span class="number">1</span>].aaa</span><br><span class="line">test.q = <span class="string">&#x27;haha&#x27;</span> <span class="comment">//能够检测到</span></span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure>
<p>这只是一个小demo，能够实现data内任何数据的改变都能检测到，可以复制到浏览器控制台验证，可能还存在bug，实际情况下应该还会涉及更复杂的错误处理还有性能方面的问题</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/proxy">ECMAScript 6 入门</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN  Object.defineProperty()</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/14/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9Athis%E4%B8%8E%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9Athis%E4%B8%8E%E5%8E%9F%E5%9E%8B/" class="post-title-link" itemprop="url">《你不知道的javascript》读书笔记二：this与原型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-14 20:36:28" itemprop="dateCreated datePublished" datetime="2020-09-14T20:36:28+00:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这部分其实应该叫做吐槽合集，作者在这部分大量吐槽了把 js 中原型理解成类的做法。现在的前端社区中，如 React，Vue 也是更少利用类的一些特性，而是使用了混入，类似于该书中讲的行为委托模式；而在 React Hooks 和 Vue composition api 中，则更激进的几乎完全去掉了 Class 风格的代码。</p>
<p>读了这部分，就能了解社区为什么不太喜欢 Class 风格的代码。</p>
<h2 id="从-this-讲起"><a href="#从-this-讲起" class="headerlink" title="从 this 讲起"></a>从 this 讲起</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 也是 js 中新手很头疼的问题了，各种归纳总结 this 的方法随处可见。这里也贴下书中对 this 的定义</p>
<blockquote>
<p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<br>this 就是这个记录的一个属性，会在函数执行的过程中用到。</p>
</blockquote>
<p>借助 this 我们可以很方便的来传递上下文</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式绑定this</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  name: <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo.speak(); <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Boo = &#123;</span><br><span class="line">  name: <span class="string">&quot;Boo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定this</span></span><br><span class="line">Foo.speak.call(Boo); <span class="comment">// Boo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统传递上下文</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">speak(Foo); <span class="comment">// Foo</span></span><br><span class="line">speak(Boo); <span class="comment">// Boo</span></span><br></pre></td></tr></table></figure>

<p>书里归纳了五种 this 的绑定方式，就以上面的例子为例</p>
<ol>
<li>默认绑定 speak() this = window</li>
<li>隐式绑定 Foo.speak() this = Foo</li>
<li>显式绑定 Foo.speak.call(Boo) this = Boo</li>
<li>硬绑定 bind Foo.speak.bind(Boo) this = Boo</li>
<li>new 绑定 new Foo.speak this = {}（es5）</li>
</ol>
<p>当然，其实也可以用符合直觉的方式来理解，使用函数是手动传入 this，而在其它情况下，则是调用方，也就是指执行上下文，如果没有，则认为是 window。<br>可以看下一些经典的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  logThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.logThis(); <span class="comment">// &#123; name: &#x27;foo&#x27;, logThis: Function  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anthorLogThis = foo.logThis;</span><br><span class="line"></span><br><span class="line">anthorLogThis(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnLogFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnLogFunction()(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">(<span class="literal">false</span> || foo.logThis)(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>这里可能最让人疑惑的可能是最后一个例子，他们看起来是具有执行上下文的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">false</span> || foo.logThis)(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>这里要注意在使用了括号运算符后，返回的是函数的值，而返回的并不是执行上下文和函数的整体，也就自然变为了默认的 Window。</p>
<p>如果想具体如何判断 this，可以参考<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/7" title="JavaScript深入之从ECMAScript规范解读this">这篇博客</a><br>这篇博客从规范实现上面阐述如果判断 this，当然，绝大多数情况都可以以符合直觉的方式，判断它的调用方是谁就好了。</p>
<h3 id="this-与属性描述符"><a href="#this-与属性描述符" class="headerlink" title="this 与属性描述符"></a>this 与属性描述符</h3><p>属性描述符是 ES5 时出现的，可以给对象设置数据描述符和存取描述符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与数据描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.a; <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set!&quot;</span>);</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在对象属性访问中，也有类似的[[GET]]与[[PUT]]。<br>默认的内置[[GET]]操作会首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值，如果没有找到，则会遍历原型链上的属性，如果没有则会返回 undefined，<br>而默认的[[PUT]]方法则由于原型链的存在复杂很多</p>
<p>在对象自身存在属性时，[[PUT]]方法很简单，如果有定义的 setter 就调用 setter，如果没有，就检查属性描述中定义是否可写，如果可写就写入。</p>
<p>而如果对象属性不存在，则会涉及到复杂的原型上属性的处理了。</p>
<ol>
<li>如果原型上存在对应属性，并且是数据描述符，并且 writable 为 true，那么会直接在当前对象上添加对应的属性和值。</li>
<li>如果原型上存在对应属性，并且是数据描述符，如果 writable 为 flase 那么这次赋值默认会失败，严格模式下则会报错。</li>
<li>如果原型上存在对应属性，并且是存取描述符，则会调用对应的 setter</li>
</ol>
<p>第二点类似于 java 中的 final 标识符，表示不可重写，然而可能大多数场景开发者会认为这是一个 BUG，因为结果出人意料。</p>
<h2 id="类与原型"><a href="#类与原型" class="headerlink" title="类与原型"></a>类与原型</h2><p>在很多基于类的语言中，类的继承行为都是复制的，对类的重新定义和运行时改写是不允许的，非常安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 js 中，类似的概念是以原型为基础的，在使用 new 关键字时，产生的对象会自动指向函数的[[prototype]]属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;st&quot;</span>, <span class="number">34</span>);</span><br><span class="line">person.sayName; <span class="comment">// st</span></span><br></pre></td></tr></table></figure>

<p>指的注意的是，由于 js 的动态性，原型也是可以更改的，并且所有属性是共享的，基于原型的方法会很脆弱</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;st&quot;</span>, <span class="number">34</span>);</span><br><span class="line">person.sayName; <span class="comment">// st</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;new&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName; <span class="comment">// stnew</span></span><br></pre></td></tr></table></figure>

<p>由于在 es6 之前，js 没有提供相关类的写法，就有各种对继承的实现，使用最多的就是寄身组合式继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>而在 ES6 中，继承只需要简单的 extnds 关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;kk&quot;</span>, <span class="number">18</span>);</span><br><span class="line">child.getName(); <span class="comment">// kk 1</span></span><br></pre></td></tr></table></figure>

<p>指的注意的是，super 是静态绑定的，super 在声明时就已经确定了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;P.foo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> C();</span><br><span class="line">c1.foo(); <span class="comment">// P.foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> D = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;D.foo&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> E = &#123;</span><br><span class="line">  foo: C.prototype.foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(E, D);</span><br><span class="line">E.foo(); <span class="comment">// P.foo</span></span><br></pre></td></tr></table></figure>

<p>实际上，在 Vue 和 React 的代码中，继承的代码很少被使用，更多倾向于使用混入来复用代码，比如 Vue 中的 混入代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mix properties into target object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">to: <span class="built_in">Object</span>, _from: ?<span class="built_in">Object</span></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</span><br><span class="line">    to[key] = _from[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混入可以更方便的组合多种对象，而不必实现复杂的继承关系。</p>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>实际上社区也有很多基于类关系的框架和代码，比如 angular、nest,实际上它们工作、维护的相当好，并没有太过不堪，选择基于类、原型、函数式更多是一种编程风格的选择，都有或多或少的优点缺点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/https%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/29/https%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">https原理是什么?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-29 21:01:11" itemprop="dateCreated datePublished" datetime="2020-08-29T21:01:11+00:00">2020-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自己初中的时候有过一段时间很好奇密码学相关的问题，当时就了解到了非对称加密，觉得很神奇，只要被公钥加密，就只有私钥才能解开，当时想，加密过程不过就是按照规则进行一些数学计算而已，怎么会不可逆呢？非对称加密是怎么做到这些的？怎么让网络变成可信的？<br>当时百度还挺可靠的，搜索到了一篇讲的很好文章，大概有了认知，可惜那篇文章找不到了；今天正好看到一个前端问题：https 原理是什么？就再学习了一次，写这篇博客记录下来。</p>
<h1 id="https-为什么出现"><a href="#https-为什么出现" class="headerlink" title="https 为什么出现?"></a>https 为什么出现?</h1><p>因为网络链路默认是不可信任的，HTTP 在整个传输过程中无法保证数据不被窥探、篡改，常见的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>就是利用了这个原理，日常经常发现的网页出现莫名奇妙的新增广告，通常叫做运营商劫持，就是一种中间人攻击。</p>
<h1 id="https-如何防止中间人攻击的？"><a href="#https-如何防止中间人攻击的？" class="headerlink" title="https 如何防止中间人攻击的？"></a>https 如何防止中间人攻击的？</h1><p>https 在 TCP 传输层和 HTTP 应用层之间再加了一层 SSL/TSL(传输层安全协议)，用于对 HTTP 报文进行加密。</p>
<p>SSL/TSL 采用基于公钥的加密算法，比如最常用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">RSA 算法</a>。</p>
<p>RSA 是一种非对称加密算法，在了解非对称加密前，先了解一下对称加密，对称加密指的是在加密或者解密时使用相同的密钥。就像是为数据上一把锁，同时也要把钥匙拿给解密的人。<br>使用对称加密的过程往往是这样的：</p>
<ul>
<li>A 生成随机密钥 K</li>
<li>A 与 B 通过某种方式</li>
<li>A 密钥 K 加密明文数据</li>
<li>A 传输密文数据</li>
<li>B 使用密钥 K 解密密文</li>
<li>得到明文数据<br>对称加密的一大问题就是存在密钥交换环节，想要解密必须传输密钥，而传输密钥这个环节，往往容易泄露密钥，整个加密环节也就不安全了。</li>
</ul>
<p>非对称加密算法就解决了这个问题，密钥加密解密使用不同的密钥，避免了密钥交换环节，最著名的非对称加密算法就是 RSA 算法</p>
<h2 id="RSA-算法是怎么工作的？"><a href="#RSA-算法是怎么工作的？" class="headerlink" title="RSA 算法是怎么工作的？"></a>RSA 算法是怎么工作的？</h2><p>RSA 算法利用了数论方面的知识，详细的数学解释可以看阮一峰的博客，简单易懂（虽然自己只看了半懂 233）</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一) 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二）阮一峰</a></li>
</ul>
<p>整个过程简单概述，为</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><ol>
<li>随机选择两个不相等的质数<strong>p</strong>和<strong>q</strong></li>
<li>计算<strong>p</strong>和<strong>q</strong>的乘积<strong>n</strong></li>
<li>计算<strong>n</strong>的欧拉函数 φ(n)，φ(n) = (p-1)(q-1)</li>
<li>随机选择一个整数<strong>e</strong>，条件是 1&lt; e &lt; φ(n)，且 e 与 φ(n) 互质</li>
<li>计算<strong>e</strong>对于 φ(n)的模反元素<strong>d</strong>。</li>
<li>将<strong>n</strong>和<strong>e</strong>封装成公钥，<strong>n</strong>和<strong>d</strong>封装成私钥。</li>
</ol>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><ol>
<li>假设需要加密的密文为 m，m 必须是整数，且<strong>m</strong>必须小于<strong>n</strong></li>
<li>利用公钥（n,e）计算加密的密文<code>c=m^e mod n</code></li>
<li>利用私钥（n,d）解密密文 <code>m=c^d mod n</code></li>
</ol>
<p>理论上公钥也可以当作公钥，也可以当作私钥，但实际上为了方便客户端进行加密和防止破解，公钥使用的 e 往往较小，私钥的更大。</p>
<h2 id="对抗中间人攻击"><a href="#对抗中间人攻击" class="headerlink" title="对抗中间人攻击"></a>对抗中间人攻击</h2><p>只引入非对称加密算法实际上并不能阻止中间人攻击，非对称密钥加密依赖于公钥的正确性。<br>想想这样的场景:</p>
<ol>
<li>小昂给小蕾想秘密的通过网路传输些暧昧信息</li>
<li>小昂生成一对公钥和私钥，将公钥传输给小蕾</li>
<li>小蕾收到公钥，并且将信息利用公钥进行加密</li>
<li>小昂收到信息</li>
</ol>
<p>整个过程看样子很完美<br>但是这其中有一个很重大的缺陷，网络中一切数据都是可以被截获和伪造的，小蕾其实并不能确认公钥就是小昂发送的，公钥在传输中存在被掉包的可能</p>
<ol>
<li>小昂生成一对公钥和私钥，将公钥传输给小蕾</li>
<li>小艾在中途截获了传输的公钥，并替换成了自己公钥</li>
<li>小蕾利用小艾的公钥加密了信息</li>
<li>小艾利用了自己的私钥解密了小蕾的信息</li>
<li>小艾篡改了信息，并使用小昂的公钥重新加密了修改后的信息</li>
<li>小昂收到了被篡改的信息。</li>
</ol>
<p>这是个很大的问题！非对称加密并没有解决中间人攻击。</p>
<h3 id="证书机制"><a href="#证书机制" class="headerlink" title="证书机制"></a>证书机制</h3><p>证书机制利用了另一个特点，即被私钥加密的信息，可以被公钥解密，可以利用私钥对消息进行一次签名，证明自己就是私钥的拥有者。</p>
<p>证书机制是这样工作的</p>
<ol>
<li>首先由受信任的机构（CA）生成一组公钥和私钥</li>
<li>软件商（浏览器、操作系统）会将这个公钥内置在自己软件中，并信任这个公钥。</li>
<li>小昂为了自己的通信安全，证明自己就是公钥的拥有者，决定使用数字证书。</li>
<li>CA 收到小昂的申请，确认了小昂的身份。</li>
<li>CA 先生成了这个证书的基本信息<ul>
<li>使用者： 小昂</li>
<li>公钥：xxxxx</li>
<li>有效期限：xxxxx</li>
<li>公钥算法：RSA</li>
<li>证书版本：xxxx</li>
</ul>
</li>
<li>CA 利用 hash 算法计算上列信息的 hash 值，并用自己的私钥进行加密，并和上面的信息组合，成为最终的数字证书。<br>这时小昂就得到了自己的数字证书，可以证明自己时公钥的拥有者了。</li>
</ol>
<p>小昂与小蕾接下来的通信就是这样的</p>
<ol>
<li>小蕾向小昂发送请求</li>
<li>小昂出示自己的数字证书</li>
<li>小蕾对得到的证书进行验证，使用 CA 的公钥解密被加密的数字证书 hash，计算数字证书 hash 值，以保证证书未被篡改</li>
<li>小类使用数字证书的公钥和算法进行加密密文</li>
</ol>
<h3 id="使用对称密钥"><a href="#使用对称密钥" class="headerlink" title="使用对称密钥"></a>使用对称密钥</h3><p>在使用非对称密钥中，由于公钥是公开的，被私钥加密的内容实际可以被认为等同于明文，小蕾向小昂发送信息，只有小昂能够解密，但是任何持有公钥的人都能解密小昂使用私钥加密的内容。<br>并且非对称加密相比对称加密，运算复杂度要高一个数量级，如果要传输大量信息，性能消耗会很大，在这种情况下，引入对称密钥就是很有必要的了。</p>
<ul>
<li>在上文的前提下，小蕾随机生成一个密钥，并将这个密钥使用公钥加密，发送给小昂</li>
<li>小昂使用私钥解密这个私钥，并在接下来的过程中，转用这个对称加密密钥进行通信</li>
</ul>
<p>在这个过程中往往为了前向安全性，使用的是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">DH 密钥交换算法</a>协商密钥，不依赖于 RSA 算法</p>
<h3 id="增强安全性"><a href="#增强安全性" class="headerlink" title="增强安全性"></a>增强安全性</h3><ul>
<li>为了防止重放攻击，SSL/TLS 还会在密文中附带时间戳</li>
<li>为了保证内容完整性，SSL/TLS 会计算内容的 hash 值并一同加密发送</li>
<li>为了防止从 https 降级成 http，https 拥有 HSTS(HTTP Strict Transport Security)，会强制客户端使用 https</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/16/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">《你不知道的javascript》读书笔记 一：作用域和闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-16 19:36:28" itemprop="dateCreated datePublished" datetime="2020-08-16T19:36:28+00:00">2020-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实之前已经把《你不知道的 javascript》上卷读完了，但是其实只是囫囵吞枣，看的很初略，没有自己的思考，再到今天其实有点忘得差不多，这次重新精读一次，记录下自己的思考。</p>
<h2 id="JS-是如何处理变量声明的？"><a href="#JS-是如何处理变量声明的？" class="headerlink" title="JS 是如何处理变量声明的？"></a>JS 是如何处理变量声明的？</h2><p>js 入门会遇见很多很神奇的点，很著名的就是变量提升</p>
<ul>
<li>var 变量提升<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li>函数声明提升<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hosting(); <span class="comment">// &#x27;function hosting&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hosting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;function hosting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hosting = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
在这里使用<code>var</code>声明的变量标志符被提升了，甚至可以在声明前调用它，函数也是同理，并且函数声明的值也被一同提升了。</li>
</ul>
<p>上面的代码可以翻译成类似的同理代码:</p>
<ul>
<li>var 变量提升<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li>函数声明提升<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hosting = <span class="function"><span class="keyword">function</span> <span class="title">hosting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;function hosting&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">hosting(); <span class="comment">// &#x27;function hosting&#x27;</span></span><br><span class="line">hosting = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
了解了之后，其实我们还会冒出更多的疑问，为什么会这样？为什么这么设计？<br>《你不知道的 javascript》正好解答了这一部分。</li>
</ul>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>在了解 JS 如何变量声明前，我们还需要一些预先的知识，了解代码是如何编译的。编译器前端大致有下面几个流程：</p>
<ul>
<li><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4></li>
</ul>
<p>词法分析就是将字符串分解成适合理解的词法单元，例如 <code>23 + 10 * 2</code> 就应该是 5 个词法单元<code>23</code> <code>+</code> <code>10</code> <code>*</code> <code>2</code>，词法分析有两种方式，一种是基于状态机的，另一种是基于正则的，两者是等同的。</p>
<ul>
<li><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4></li>
</ul>
<p>语法分析实际上做的就是将连续的词法单元分析成一个个语意块，就像将一串连续的汉字理解一个个词语一样，最终输出成为一颗抽象语法树，上面词法单元分析的结果应该是这样</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ExpressionStatement&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expression&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;left&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;value&quot;</span>: <span class="number">23</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;right&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;left&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;right&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个语法结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExpressionStatement &#x3D;</span><br><span class="line"> BinaryExpression  &#x3D;</span><br><span class="line"> Literal(23) + BinaryExpression &#x3D;</span><br><span class="line"> Literal(23) + (Literal(10) * Literal(2))</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4></li>
</ul>
<p>在通过语法分析后，事实上代码已经可以转换成机器代码跑起来了， 但是为了避免一些语义错误和代码优化，就可以在生成抽象语法树后再进行一些处理。<br>比如前端打包中<code>Tree shaking</code>实际上就是在这个阶段对代码进行静态分析，移除不必要的代码。</p>
<p>了解了代码的编译过程，我们就可以从编译原理角度来理解编译器做的这些小动作 了。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域的定义在书中定义的很明白</p>
<blockquote>
<p>作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。<br>它决定了变量如何被查找及访问。</p>
</blockquote>
<h4 id="为什么要变量提升？"><a href="#为什么要变量提升？" class="headerlink" title="为什么要变量提升？"></a>为什么要变量提升？</h4><p>这是一个常见的声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>声明语义应该是这个样子的：</p>
<blockquote>
<p>为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量。</p>
</blockquote>
<p>如果重复声明，在 C、Java 中，会直接报错，也是符合常理的做法。</p>
<p>然而在 js 中，却不是这样。首先编译器会预先扫描所有的变量声明，在首次声明时会将变量添加进作用域，并将变量默认值置为<code>undefined</code>,如果遇到再次声明，则忽略它。函数声明与变量基本一致，但是在编译时就会确定函数的值。</p>
<p>很对人都很奇怪为什么 js 会如此设计，为什么这样进行编译？这样做有什么好处吗？<br>实际上 js 语言的创造者 BrendanEich 其实在<a target="_blank" rel="noopener" href="https://twitter.com/BrendanEich/status/33403701100154880">twitter</a>说过变量提升的原因。Quora 上<a target="_blank" rel="noopener" href="https://www.quora.com/Why-does-JavaScript-hoist-variables">一篇文章</a>也说的很清楚。</p>
<blockquote>
<p>yes, function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order</p>
</blockquote>
<blockquote>
<p>A bit more history: `var` hoisting was an implementation artifact. `function` hoisting was better motivated</p>
</blockquote>
<p>大意就是 BrendanEich 在设计 js 语法时，十分讨厌 LISP 命令式的、自上而下的函数书写风格，如果没有函数声明提升，我们的代码将是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doXXX...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doSomethingB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doSomethingA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读代码时，通常是自上而下的，然而如果没有变量提升，就不得不自上而下声明函数，自上阅读代码。因此 js 编译器会预先做变量提升，类似于类似于 C\C++代码中头文件的作用。而与此同时，作为函数声明提升的副作用，变量声明也被提升了，也就成为了现在的局面。</p>
<h4 id="函数作用域与词法作用域"><a href="#函数作用域与词法作用域" class="headerlink" title="函数作用域与词法作用域"></a>函数作用域与词法作用域</h4><p>在 ES6 之前，仅有全局作用域和函数作用域，这在某些情况下就会造成一些问题，这也在一些经典面试题中出现过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log123(); <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>

<p>这里期望输出行为应该在 1s、2s、3s 时分别输出 1、2、3<br>而实际输出是在 1s、2s、3s 时都输出 4。</p>
<p>在 ES6 中，解决这个办法很简单，将<code>var</code>变成<code>let</code>即可，<br>在 ES6 前有两种解决办法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种 参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(</span><br><span class="line">      (count) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count + <span class="number">1</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      i * <span class="number">1000</span>,</span><br><span class="line">      i</span><br><span class="line">    ); <span class="comment">//  注意这里</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 立即执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> j = i;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j + <span class="number">1</span>);</span><br><span class="line">      &#125;, i * <span class="number">1000</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果初学者的话，可能看到这一大串代码有点手足无措，因为这里确实设计到了 JS 大量的核心特性，我们可以从头开始一点一点看下去</p>
<p>在第一个未改进的版本，我们首先在全局作用域中声明了函数<code>log123</code>函数，编译器预扫描了函数声明，并和宿主环境提供的 api 一起构建了全局作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>在构建完全局作用域后，代码就开始执行了，值得注意的是，js 不会预先编译所有的代码，函数会在执行时编译并缓存编译结果，以达到更快的执行速度。<br>在代码执行到<code>log123()</code>时，编译器会拿到函数的内容，开始编译并构建执行环境。<br>编译器会预先扫描函数体内所有的声明，其中包括形参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>整个过程中，函数作用域被押入栈中，在查询变量时，会按照入栈顺序从最近到最晚开始查询，理所当然的，全局作用域是最后被查询的作用域。</p>
<p>接下来函数继续执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  i被置为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//  创建函数表达式 将函数表达式传入setTimeout函数</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里又创建了一个新的函数表达式，这个函数将会在定时器结束后被调用<br>在这里，词法作用域的特殊性就显现出来了，词法作用域在书中是这样定义的</p>
<blockquote>
<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</p>
</blockquote>
<p>在这里，由于函数表达式是在<code>log123</code>函数内声明的，按照词法作用域的解析规则，函数表达式的内部作用域是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script:[ ]</span><br><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>函数表达式内部并没有变量 i，按照作用域链查找规则，<code>console.log(i)</code>中使用的就是<code>log123()</code>中的 i<br>这里其实就是所说的闭包</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p>闭包几乎在 js 中随处可见，也并没有什么特殊，早期的 js 利用闭包来避免一些私有方法暴露，但在模块化的今天已经越来愈少。更多的时候，我们在写代码的时候无意就创见了闭包，比如一个事件监听函数，使用 React Hooks。</p>
<p>到了此时，我们终于可以总结一下输出和预期不一致的原因了。</p>
<ol>
<li>我们创建了一个函数作用域</li>
<li>在函数作用域中声明了<code>i</code></li>
<li>我们创建了一个函数表达式，用于为定时器回调，函数表达式继承了父级函数作用域</li>
<li>循环结束，<code>i</code>被置为 4</li>
<li>定时器执行回调，执行<code>console.log(i)</code>时，在父级作用域中查找到了<code>i</code>，i 的值为 4</li>
</ol>
<p>在 ES6 之前，解决办法就是上述两种，第一种通过函数传参数的方式，传递了<code>i</code>当时的字面量<code>1</code>,<code>2</code>,<code>3</code>，<code>i</code>指向的是函数表达式作用域的实参，输出是预期的结果。<br>第二种方式，是在每一次循环时，都为函数表达式创建了新的父级函数作用域。<br>作用域链会像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script:[ ]</span><br><span class="line">script:[j]</span><br><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>函数表达式访问的是临时的父级作用域<code>j</code>的值，也如预期结果</p>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>所幸我们很快在 ES6 中拥有了块级作用域，用 let 实现上面的效果很简单，只需要把 var 更换成 let</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="number">1</span>); <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只把 let 理解成仅创建块级作用域的话，实际上无法解释输出的结果，按照作用域链查找规则，log 输出的还是父级块级作用域的 i</p>
<p>实际上，<code>let</code>在循环语句块中，有特别的处理，let 会在循环语句中的每一次循环创建单独的块级作用域，上面的代码类似于这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log123</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> _i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = _i; <span class="comment">// 创建单独的作用域</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="number">1</span>); <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这里的处理方式基本类似于上面第二种办法。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上大概就是读完《你不知道的 javascript》 作用域和闭包 部分的一些想法和笔记，通过解答 js 的经典问题 变量提升来做一些回顾，如果需要再深入的话，可能还是需要深入 ECMAScript 标准，但是作为开发的话，目前的知识已经足够了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/17/%E8%B0%88%E8%B0%88%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%BA%E7%8E%B0%E7%9A%84-%E6%B7%B1%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/17/%E8%B0%88%E8%B0%88%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%BA%E7%8E%B0%E7%9A%84-%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">谈谈经常出现的出现的“深拷贝”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-17 18:16:12" itemprop="dateCreated datePublished" datetime="2020-02-17T18:16:12+00:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>想想已经 N 久没有写文章了，有点怠惰，之后还是尽量学了什么，就写文章记录下来；写文章的过程也是自己把知识联系起来的过程。<br>写这篇文章主要原因还是之前字节跳动三面，面试官一开始就要去写一个深拷贝，然而之前对这方面了解的很少很少，面试表现可以说相当差了，结果也是直接挂掉…<br>之后重新学习了，这里就记录下吧</p>
<h2 id="怎样定义深拷贝？深拷贝到底要拷贝什么？"><a href="#怎样定义深拷贝？深拷贝到底要拷贝什么？" class="headerlink" title="怎样定义深拷贝？深拷贝到底要拷贝什么？"></a>怎样定义深拷贝？深拷贝到底要拷贝什么？</h2><p>说起深拷贝，就得说下内存结构了，内存就是一断特殊的电路，我们通过对内存的储存结构进行编码，某个内存地址对应内存某一个储存数据的地方，最小储存单元是 8 个 bit; 我们甚至可以把最小储存单元定义为 1 个 bit，但是这通常没有必要，因为我们需要针对每一个储存单元设置清除电路，而现实使用时的数据大多都会超过 1 个 bit，为了更小的储存单元而把电路变得更复杂完全不值得。<br>如果我们使用的数据超过最小储存单元，我们就把连续几个内存地址一起用了，记录首个地址，记录它使用个几个内存地址，也就是它的类型，比如<code>int</code>, 在大多数实现上，一般是 4 个字节，也就是连续占用 4 个地址，这些我们称之为基本类型。</p>
<p>而如果我们要储存的数据包含多种类型，我们也可以按照这种方式，按顺序存储下来，记录首个地址，记录它使用了那些地址，通常我们还会有一些对应的函数来操作这些对应的数据，我们通常把这种结构称作为对象，相关的操作函数就被称作方法。</p>
<p>当数据被作为函数的参数传递时，基本类型和对象有很明显的差异</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">num</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b.num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(number, obj);</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;num: 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果值是一个基本类型，那传递给函数的是它直接的值，也就是值的拷贝；而如果是对象，我们传递的是它的储存位置，也就是地址值，或者更抽象的说法，对象的引用，通过这个引用操作到真正的对象。</p>
<p>不过这其中有一个类型是个特例，那就是<code>string</code>，在 java 中<code>string</code>是一个对象，有各种操作方法，然而却表现的像基本类型一样，像是一个怪胎。在知乎中有许多相关的提问</p>
<ul>
<li>[Java 语言中 String a=”a”;String b=”a”; 为什么 a==b 值为 true？]</li>
<li>[Java 到底是值传递还是引用传递？]</li>
<li>[如何理解 String 类型值的不可变？]</li>
</ul>
<p>而在 js 中<code>string</code>中直接被定义为基本类型</p>
<ul>
<li>[MDN-string]</li>
</ul>
<p>实际上，字符串的确是一个对象，只不过为了更好用，我们把它改造成了一个“基本类型”，在我们日常使用中，我们一般很少把字符串进行重新修改，甚至不能修改，有大量场景直接把字符串作为 key 值，有大量密码验证场景使用的就是字符串，如果改动了，一切就乱套了。总而言之，<code>string</code>不应该能被修改</p>
<p>在老大哥 Java 的实现中，<code>string</code>是以常量池的形式维护，每次新建一个<code>string</code>，都会从常量池中寻找是否已存在相同的字符串，如果有直接就返回引用，如果没有则创建。得益于 string 的不可变性，才可以高效的复用相同字符串，甚至像基本类型一样直接比较。js 也实现了类似的设计。</p>
<p>而深拷贝，实际就是拷贝数据里所有可变的数据结构，把新数据和老数据隔离开，避免更改一处数据结构，而更改多处。也就是直接返回所有基本类型和不可变对象，递归复制所有可变的对象。</p>
<h2 id="怎么进行深拷贝？"><a href="#怎么进行深拷贝？" class="headerlink" title="怎么进行深拷贝？"></a>怎么进行深拷贝？</h2><p>搞清除要复制什么东西，只是个起步，深拷贝能经常出现在面试题并不是由于它有多实用，工作中有多常见；主要深拷贝这一块儿会涉及到很多 js 的各种知识，各种边界条件，很能考察面试者的知识深度。</p>
<ol>
<li><p>对于基本类型，直接返回<br>js 中有 7 种基本类型，分别是 <code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>symbol</code>, <code>undefined</code>, <code>null</code>,<br>除了 null 和 function 以外，在<code>typeof</code>操作符下都显示为自己的类型名称，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>我们可以自定义一个<code>ownTypeof</code>方法来正好的帮助我们在深拷贝时判断类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> primitiveTypes = [</span><br><span class="line">  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bigint&quot;</span>,</span><br><span class="line">  <span class="string">&quot;boolean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;symbol&quot;</span>,</span><br><span class="line">  <span class="string">&quot;undefined&quot;</span>,</span><br><span class="line">  <span class="string">&quot;null&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ownTypeof = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">if</span> (primitiveTypes.includes(type) || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;primitive&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些值就可以直接返回，不经过任何处理。</p>
</li>
<li><p>如果是对象，遍历对象的所有值<br>这里也有许多门道，js 提供了太多根据 key 值循环处理的方法，</p>
<ul>
<li>for in<br>最常见的循环方法，遍历对象所有可遍历的字符串 key，无法遍历不可遍历的 key,会遍历到原型上的属性,无法遍历 symbol key,</li>
<li>Object.keys()<br>基本等同于<code>for in</code>，除了不会遍历到原型上的属性</li>
<li>Reflect.ownKeys()<br>获取对象所有的 key ，包括不可遍历的 key，symbol key, 等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。<br>这里为了方便就直接用 Es6 的新方法<code>Reflect.ownKeys()</code>，简单又快速。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> typeofValue = ownTypeof(value);</span><br><span class="line">  <span class="keyword">if</span> (typeofValue === <span class="string">&quot;primitive&quot;</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Reflect</span>.ownKeys(value);</span><br><span class="line">  <span class="keyword">const</span> finalValue = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    finalValue[key] = deepClone(value[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>解决环引用<br>事实上这里我们的代码已经能勾复制大多数普通对象了，但是会碰见序列化时遇见的一个常见问题：环引用，我们通常会在使用 JSON 时遇到相似的错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a.self = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(a); <span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<p>而在我们编写的深拷贝函数种，这会直接导致无限递归，直到栈溢出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a.self = a;</span><br><span class="line"></span><br><span class="line">deepClone(a); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<p>解决环引用其实很简单，栈溢出的原因是我们的函数在不停的重复拷贝一个相同的对象，而实际上，如果这是一个重复的对象，我们直接返回它自身的引用就可以了。我们可以通过建立新老对象引用的映射达到这一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">value, cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> typeofValue = ownTypeof(value);</span><br><span class="line">  <span class="keyword">if</span> (typeofValue === <span class="string">&quot;primitive&quot;</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache.has(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Reflect</span>.ownKeys(value);</span><br><span class="line">  <span class="keyword">const</span> finalValue = &#123;&#125;;</span><br><span class="line">  cache.set(value, finalValue);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    finalValue[key] = deepClone(value[key], cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里基本的一个深拷贝实际上基本就完成了，然而其实还有更多的 edge case, 也就是由于这个原因，实现一个深拷贝很难很难</p>
</li>
<li><p>edge case</p>
<ul>
<li><p>是否考虑原型？<br>在继承了 Java 一切皆对象的思想， js 每一个对象都有一个原型，实际上，我们直接返回它的原型，只把它当作单独的数据处理，因为拷贝原型的代价十分高昂</p>
</li>
<li><p>是否复制函数？<br>在任何实现里面，我相信函数都是不可拷贝的，也无需拷贝，这是因为函数生成以后，其执行的代码就不可更改了，这是一个不可变数据结构，我们理所当然的也不需要考虑再复制一份代码。<br>除此之外还有一个重要原因是我们无法获得函数运行时的作用域，即使我们通过<code>toString()</code>获得源代码，也无法获得函数运行时的作用域。</p>
</li>
<li><p>是否拷贝对象描述符？<br>对象描述分别有两种，一种是数据描述符，一种是存取描述符，数据描述符是可复制的，存取描述符依赖于函数，无法复制</p>
</li>
<li><p>如果复制内置对象？<br>在 js 种，有许多对象是内置的，我们无法通过除其本身的构造函数外，创建出这个对象，比如最常见的数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copyArray = deepClone([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="built_in">JSON</span>.stringify(copyArray); <span class="comment">// &#123; &quot;1&quot;: 1, &quot;2&quot;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>即使我们拷贝了它的原型，它表现的也像是个普通对象，而不是一个数组，我们为其复制，length 属性也不会一同变换。<br>这是由于数组是 js 的内置的对象，有独有的处理逻辑。<br>类似的对象有许多许多：Date、RegExp、Map、Set、Blob，这也是整个过程最复杂的一块，不同的内置对象复制逻辑也不同。</p>
<p>对于这种情况，则只能根据它的对象类型，使用其构造函数创建它。<br>我们可以使用<code>instanceof</code>来确人对象是不是这些内置对象的实例，不过通常使用更方便的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/test/</span>); <span class="comment">// [object RegExp]</span></span><br></pre></td></tr></table></figure>

<p>使用这个方式，我们可以直接读取这个对象类的名称，并进行相应处理。</p>
</li>
</ol>
<p>使用上面的方式，基本就可以写出一个不错的深拷贝，在实际上编写中也是一个踩坑的过程，会了解许多日常忽视的 js 知识，对于一个面试题，称的上不错了。</p>
<p>但是实际使用中，我们应该尽量避免大量使用深拷贝，这是一种大量浪费内存的行为，如果你需要的是不可变性，更应该采用一些提供 Immutable 特性的库。</p>
<p>[Java 语言中 String a=”a”;String b=”a”; 为什么 a==b 值为 true？]: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/57697842/answer/210583977">https://www.zhihu.com/question/57697842/answer/210583977</a> “Java 语言中 String a=”a”;String b=”a”; 为什么 a==b 值为 true？”<br>[Java 到底是值传递还是引用传递？]: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609/answer/576030121">https://www.zhihu.com/question/31203609/answer/576030121</a> “Java 到底是值传递还是引用传递？”<br>[如何理解 String 类型值的不可变？]: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20618891">https://www.zhihu.com/question/20618891</a> “如何理解 String 类型值的不可变？”<br>[MDN-string]: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/string">https://developer.mozilla.org/en-US/docs/Glossary/string</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/Windows-Terminal-Wsl-%E6%89%93%E9%80%A0%E6%9C%80%E7%BE%8E%E7%BB%88%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/Windows-Terminal-Wsl-%E6%89%93%E9%80%A0%E6%9C%80%E7%BE%8E%E7%BB%88%E7%AB%AF/" class="post-title-link" itemprop="url">Windows Terminal 打造最美终端~</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 21:41:30" itemprop="dateCreated datePublished" datetime="2020-01-08T21:41:30+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自己之前在Windows一直使用<a target="_blank" rel="noopener" href="https://cmder.net/">cmder</a>作为自己的终端使用，主要就是自带颜值比git-bash这些高很多，不过在把Windows升级到1909版本，cmder不知为何无法连接到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" title="Windows Linux子系统">wsl</a>了, 正好也想试试微软新出的<a target="_blank" rel="noopener" href="https://github.com/microsoft/terminal">Windows Terminal</a></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接在<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/p/windows-terminal-preview/9n0dx20hk701">应用商店</a>里安装就可以了</p>
<h2 id="个性化Windows-Terminal"><a href="#个性化Windows-Terminal" class="headerlink" title="个性化Windows Terminal"></a>个性化Windows Terminal</h2><p>默认的Windows Terminal各个终端都是默认样式，劝退级别233。点击下拉菜单，点击设置就会打开Vscode来自己配置Windows Terminal了</p>
<p>添加新的终端需要在<code>profiles</code>属性下添加，类似下面这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;guid&quot;</span>: <span class="string">&quot;&#123;156bea93-de01-48ff-bce0-860cc70a73d5&#125;&quot;</span>, <span class="comment">//uuid 用于区分不同终端</span></span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#282c34&quot;</span>, <span class="comment">//背景颜色</span></span><br><span class="line">    <span class="string">&quot;closeOnExit&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;colorScheme&quot;</span>: <span class="string">&quot;Chester&quot;</span>, <span class="comment">//配色方案</span></span><br><span class="line">    <span class="string">&quot;commandline&quot;</span>: <span class="string">&quot;\&quot;%PROGRAMFILES%\\git\\usr\\bin\\bash.exe\&quot; -i -l&quot;</span>, <span class="comment">// 终端位置</span></span><br><span class="line">    <span class="string">&quot;cursorColor&quot;</span>: <span class="string">&quot;#FFFFFF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cursorShape&quot;</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fontSize&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;historySize&quot;</span>: <span class="number">9001</span>,</span><br><span class="line">    <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;%SystemDrive%\\Program Files\\Git\\mingw64\\share\\git\\git-for-windows.ico&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="string">&quot;10, 10, 10, 10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;startingDirectory&quot;</span>: <span class="string">&quot;%USERPROFILE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;useAcrylic&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否启用毛玻璃特效</span></span><br><span class="line">    <span class="string">&quot;acrylicOpacity&quot;</span>: <span class="number">0.85</span> <span class="comment">// 透明度 仅在启用毛玻璃特效后有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要终端变得好看，配色是第一步，可以去<a target="_blank" rel="noopener" href="https://github.com/mbadolato/iTerm2-Color-Schemes">iTerm2-Color-Schemes</a>上找一个自己喜欢的主题，复制<code>windowsterminal</code>同名文件的内容到<code>schemes</code>，比如我选择的<a target="_blank" rel="noopener" href="https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/windowsterminal/Chester.json">Chester</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Chester&quot;</span>,</span><br><span class="line">    <span class="string">&quot;black&quot;</span>: <span class="string">&quot;#080200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="string">&quot;#fa5e5b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;green&quot;</span>: <span class="string">&quot;#16c98d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;yellow&quot;</span>: <span class="string">&quot;#ffc83f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="string">&quot;#288ad6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;purple&quot;</span>: <span class="string">&quot;#d34590&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cyan&quot;</span>: <span class="string">&quot;#28ddde&quot;</span>,</span><br><span class="line">    <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#e7e7e7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightBlack&quot;</span>: <span class="string">&quot;#6f6b68&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightRed&quot;</span>: <span class="string">&quot;#fa5e5b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightGreen&quot;</span>: <span class="string">&quot;#16c98d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightYellow&quot;</span>: <span class="string">&quot;#feef6d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightBlue&quot;</span>: <span class="string">&quot;#278ad6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightPurple&quot;</span>: <span class="string">&quot;#d34590&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightCyan&quot;</span>: <span class="string">&quot;#27dede&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightWhite&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#2c3643&quot;</span>,</span><br><span class="line">    <span class="string">&quot;foreground&quot;</span>: <span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把profiles中终端配置修改成对应主题名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;colorScheme&quot;</span>: <span class="string">&quot;Chester&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后顺带修改一下背景颜色，微调一下透明度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#282c34&quot;</span>,  <span class="comment">// 比较有质感的黑色</span></span><br><span class="line">    <span class="string">&quot;useAcrylic&quot;</span>: <span class="literal">true</span>,       </span><br><span class="line">    <span class="string">&quot;acrylicOpacity&quot;</span>: <span class="number">0.85</span>    <span class="comment">// 0.8左右都是比较适合的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现效果如下</p>
<p><img src="terminal.png" alt="效果"></p>
<p>这里用的是cat的升级版<a target="_blank" rel="noopener" href="https://github.com/sharkdp/bat">bat</a>,需要在<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" title="Windows Linux子系统">wsl</a>下安装</p>
<h3 id="无法出现毛玻璃特效？"><a href="#无法出现毛玻璃特效？" class="headerlink" title="无法出现毛玻璃特效？"></a>无法出现毛玻璃特效？</h3><p>这可能是由于在系统设置中关闭了特效，可以打开设置-&gt;个性化-&gt;颜色-&gt;透明效果-&gt;启用打开毛玻璃特效，然后重新打开Windows Terminal就生效了</p>
<h3 id="进入后目录不是用户目录？"><a href="#进入后目录不是用户目录？" class="headerlink" title="进入后目录不是用户目录？"></a>进入后目录不是用户目录？</h3><p>可以在执行命令后面添加这些参数，相关issues可以看这里<a target="_blank" rel="noopener" href="https://github.com/microsoft/terminal/issues/592">startingDirectory setting issue for wsl profile</a></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;wsl.exe ~ -d Ubuntu&quot;</span></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<h3 id="如何让wsl和windows通信？"><a href="#如何让wsl和windows通信？" class="headerlink" title="如何让wsl和windows通信？"></a>如何让wsl和windows通信？</h3><p>根据 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-ux-changes">官方文档</a>,在<code>/etc/resolv.conf</code>中，会储存windows主机的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="comment"># [network]</span></span><br><span class="line"><span class="comment"># generateResolvConf = false</span></span><br><span class="line">nameserver 172.20.192.1</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用bash脚本提取它作为全局变量使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> win_host=<span class="string">&quot;<span class="subst">$(grep -oP &#x27;(?&lt;=nameserver )</span>\d&#123;1,3&#125;(?:\.\d&#123;1,3&#125;)&#123;3&#125;&#x27; /etc/resolv.conf)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$win_host</span></span><br><span class="line">172.20.192.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://<span class="variable">$&#123;win_host&#125;</span>:1080&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://<span class="variable">$&#123;win_host&#125;</span>:1080&quot;</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/%E4%BB%8Ecallback%E5%88%B0async%E5%87%BD%E6%95%B0-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8F%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Geylnu">
      <meta itemprop="description" content="记录我的前端学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/06/%E4%BB%8Ecallback%E5%88%B0async%E5%87%BD%E6%95%B0-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8F%98/" class="post-title-link" itemprop="url">从callback到async函数-js异步编程的演变</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-06 11:30:33" itemprop="dateCreated datePublished" datetime="2019-10-06T11:30:33+00:00">2019-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 16:27:02" itemprop="dateModified" datetime="2021-05-31T16:27:02+00:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实之前只知道 Promise 很方便，大家也都是这么用的，generate 函数也一知半解，直到最近看了阮一峰的<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/generator-async">ES6 入门</a>和在知乎看的一篇工业聚的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83965949" title="100 行代码实现 Promises/A+ 规范">文章</a>,才了解整个的发展历程，我也推荐你去看看他们的文章。</p>
<h2 id="js-异步编程模型"><a href="#js-异步编程模型" class="headerlink" title="js 异步编程模型"></a>js 异步编程模型</h2><p>js 作为一门浏览器的脚本语言，出生的时候就希望它尽可能的简单，易用，即使是非专业人员也能迅速掌握，而且 js 最初的应用场景并不复杂，所以单线程的 js 就确定了下来。<br>虽然 js 是单线程的，但浏览器却不是，对于很多耗时过长的任务，比如发起 ajax 请求，设置定时器，会由浏览器来做，js 只需要注册回调函数，声明浏览器完成异步后需要要做什么就可以了，js 只要有异步的地方，都有回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/cccc&quot;</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h2 id="原始回调函数"><a href="#原始回调函数" class="headerlink" title="原始回调函数"></a>原始回调函数</h2><p>最早的回调函数方式就是直接在参数中传递一个回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>执行 setTimeout 后，这个计时任务会交由其它线程处理以避免阻塞 js 主线程,例如在浏览器会交由一个单独的计时线程处理；在时间超时后，浏览器会向 js 任务队列中插入新的任务，而 js 主线程在在同步任务完成后会不断检测队列中是否有新任务，并执行，此时这个回调函数也就被执行了。</p>
<p>回调函数的一大缺点就是在大量异步任务时，会嵌套下去，代码会逐渐横向发展，也即回调地狱。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepBystep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;2000 delay&quot;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;3000 delay&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;4000 delay&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，Promise 就诞生了</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 语法可以将异步回调写成链式调用的模样，看着更清晰更直观，错误捕获等也有更好的体验</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeoutPromise</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepBystepPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeoutPromise(<span class="number">1000</span>)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;2000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;3000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">4000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;4000 delay&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候代码就是竖向展开的，错误捕获也很方便，<code>.catch()</code>就好了。<br>虽然 Promise 封装的回调函数已经很方便了，但是如果还想进一步呢？</p>
<h2 id="generate-函数"><a href="#generate-函数" class="headerlink" title="generate 函数"></a>generate 函数</h2><p>generate 函数提供了<code>yield</code>关键字，可以在函数中断执行，直到调用<code>.next()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;log:&quot;</span> + a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;log:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = generate();</span><br><span class="line">gen.next(); <span class="comment">// &#123;value: 5,done: flase&#125;</span></span><br><span class="line">gen.next(<span class="number">8</span>); <span class="comment">// log:8 &#123;value: 6,done: flase&#125;</span></span><br><span class="line">gen.next(<span class="number">9</span>); <span class="comment">// log:9 &#123;value: undefined,done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>用这个方法，我们就可以尝试者用 generate 函数执行异步操作,在此之前我们首先需要把带有 callback 函数写成 Thunk 函数或者 Promise 的风格</p>
<h3 id="什么是-Thunk-函数"><a href="#什么是-Thunk-函数" class="headerlink" title="什么是 Thunk 函数"></a>什么是 Thunk 函数</h3><p>Thunk 函数就是将带有回调函数的多参数函数转变成只有一个回调函数的单参数函数，就像下面这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeOutThunk</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是为了方便使用 generate 函数来控制异步流程，下面就是一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeOutThunk</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">3000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">4000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = generate();</span><br><span class="line"><span class="keyword">let</span> &#123; value &#125; = gen.next(); <span class="comment">// &#123;value: [[callbackFunction]] , done: flase&#125;</span></span><br><span class="line">value(<span class="function">() =&gt;</span> gen.next(<span class="number">123</span>)); <span class="comment">//123 &#123;value: [[callbackFunction]] , done: flase&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里<code>setTimeOutThunk()</code>已经变成单参数版本的函数,我们在调用<code>.next()</code>后，返回只具有回调函数参数的函数，这里其实主要是为了方便传参，如果另有约定不使用 Thunk 函数转化也可以。</p>
<p>在回调函数中,我们让回调函数调用下一个<code>.next()</code>,就可以让这个异步函数像同步函数一样执行了完整版本见下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeOutThunk</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">3000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  val = <span class="keyword">yield</span> setTimeOutThunk(<span class="number">4000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; value, done &#125; = gen.next(...args);</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function">(<span class="params">...args</span>) =&gt;</span> run(gen, ...args));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      value(<span class="function">(<span class="params">...args</span>) =&gt;</span> run(gen, ...args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen());</span><br></pre></td></tr></table></figure>

<p>这里也支持 Promise<br>实质上这里已经完全将异步回调写成了同步代码，除了需要手动调用一下<code>run()</code>方法。</p>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>async 函数其实就是 generate 函数的语法糖版本，会自动运行，让我们不需要再额外调用<code>run()</code>方法，使用就很方便了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeoutPromise</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">stepBystepAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">4000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法上也与 generate 相似。</p>
<h2 id="一切皆回调"><a href="#一切皆回调" class="headerlink" title="一切皆回调"></a>一切皆回调</h2><p>无论是 Promise，还是 async 函数，其实仍然是利用回调函数处理异步，只是对如何处理异步函数做了一层封装，做了一些语法糖，让我们更方便的使用而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Geylnu</p>
  <div class="site-description" itemprop="description">记录我的前端学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Geylnu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
