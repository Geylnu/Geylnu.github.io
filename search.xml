<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie,Session与LocalStorage</title>
    <url>/2020/10/02/Cookie-Session%E4%B8%8ELocalStorage/</url>
    <content><![CDATA[<h1 id="Cookie由来"><a href="#Cookie由来" class="headerlink" title="Cookie由来"></a>Cookie由来</h1><p>谈到Cookie不得不谈到http协议，wiki上的定义⬇</p>
<blockquote>
<p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p>
</blockquote>
<p>由于这个设计目的，早期http协议被设计为无状态的协议，一个HTTP协议通信过程往往是建立连接&gt;传输内容&gt;关闭连接，整个过程十分简单。</p>
<p>然而万维网发展的比想象中快太多，HTML不再只是单纯的文档，还被用于交互，有了登陆注册等保存状态的需要，然而http协议是无状态的，这个场景需要下，Cookie就诞生了。</p>
<h1 id="Cookie具体是怎么样的？"><a href="#Cookie具体是怎么样的？" class="headerlink" title="Cookie具体是怎么样的？"></a>Cookie具体是怎么样的？</h1><p>Cookie其实就是一段文本信息，由浏览器储存在本地硬盘上，服务器通过<code>Set-Cookie</code>设置Cookie，浏览器通过<code>Cookie</code>字段附上设置的Cookie信息。</p>
<p>emm，还是看一个完整的请求吧</p>
<hr>
<p><strong>响应</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 ok</span><br><span class="line">Date: Sat, 02 Feb 2019 14:24:28 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 182</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: tgw_l7_route=80f350dcd7c650b07bd7b485fcab5bf7; Expires=Sat, 02-Feb-2019 14:39:28 GMT; Path=/</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>下次请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Cookie: tgw_l7_route=80f350dcd7c650b07bd7b485fcab5bf7</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a><code>Set-Cookie</code></h2><p>服务端通过在响应头中添加<code>Set-Cookie: xxx=xxx</code>的方式以键值对的形式设置Cookie，除此之外还有其它字段可以控制Cookie的字段</p>
<ul>
<li><p><code>Domain</code><br>指定Cookie从属于那个域名，在请求对应域名时会带上这个Cookie，默认为当前文档域名，<strong>不包含子域名</strong>，若主动设置<code>Domain</code>,则一般会包含子域名，例如设置了<code>Domain=geylnu.com</code>,则<code>blog.geylnu.com</code>也是可以访问这个<code>geylnu.com</code>的Cookie。</p>
</li>
<li><p><code>Path</code><br>在域名符合的前提下，如果请求的路径与<code>Path</code>的路径相匹配就在请求中附上这个Cookie，路径匹配从前到后匹配，以<code>/</code>作为分隔符</p>
</li>
<li><p><code>Expires</code><br>在指定日期Cookie到期，Cookie到期后服务器会自动删除这个Cookie，设置时间格的式为<code>Thu, 01 Jan 1970 00:00:00 GMT</code>这样的格林尼治标准时间，没有设置该属性或<code>Max-age</code>，Cookie会自动在浏览器关闭后清除。值得注意的是响应头中的时间是基于服务器时间生成的，而客户端的时间可能与服务端不一致，这种情况下使用<code>max-age</code>属性设置过期时间是一个更好的选择。</p>
</li>
<li><p><code>Max-age</code><br>在指定秒后Cookie到期，作用等同于<code>Expires</code>，当同时设置了<code>Expires</code>和<code>Max-age</code>时，<code>Max-age</code>优先级更大；由于不直接设置时间，规避了服务端时间和客户端时间可能不一致的问题。</p>
</li>
<li><p><code>Http-only</code><br>Cookie只允许浏览器发出请求时在<code>Cookie</code>中附带上，通过<code>Set-Cookie</code>修改，不允许通过js脚本得到拿到，这可以有效的防止<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="什么是xss攻击？">XSS攻击</a></p>
</li>
<li><p><code>Secure</code><br>指定该Cookie只在加密协议（https）才能把这个Cookie发送到服务器，如果设置该属性是通过http协议设置的，浏览器会自动忽略该属性（自动纠错，因为http下设置这个属性没有意义）。如果协议为<code>https</code>，该属性默认打开</p>
</li>
</ul>
<p>一个完整的Cookie设置示范：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: sessionId=hihihi; Expirers=Wed, 01 Jan 2020 00:00:00 GMT; Max-age=10000; Http-only; Secure;</span><br></pre></td></tr></table></figure>
<h2 id="js操作方式"><a href="#js操作方式" class="headerlink" title="js操作方式"></a>js操作方式</h2><p>读</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> <span class="comment">//返回&quot;xx=xxx; yy=yyy&quot;</span></span><br></pre></td></tr></table></figure>
<p>写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;xxx=hihihi&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里由于设定了<code>get</code>和<code>set</code>属性，读是一次读写全部Cookie，写为一个个Cookie单独设置。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>好了，现在http协议支持将状态保存在客户端了，之后每个客户端都是有名有姓的人了。<br>但是客户端保存状态信息是不可靠的，客户端可以修改自己本地的Coookie值，Cookie值在非<code>https</code>加密协议的情况下，也容易被截获获取到敏感信息（这里吐槽下我校教务系统，密码明文直接写在Cookie中）。</p>
<p>对应的解决方法就是在服务端也维护对应的状态，大部分状态信息都由服务端记录，客户端只需要记录一个由服务端随机生成的sessionId用于服务端识别，这就是Session了，一般Session储存在内存，也有其它实现，甚至无Session的方式。</p>
<h1 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h1><p>由于Cookie在每个请求中都会被添加，网络开销很大，很多非敏感状态信息也不需要服务器来存储，Cookie的大小有也很小，只有4kb；为了解决这个问题，HTML5规范就提出了LocalStorage，LocalStorage和cookie一样都是存在本地电脑磁盘上，数据形式也是hash表，存储形式也都是字符串。</p>
<p>不过和cookie不同的是LocalStorage不会跟随请求发送，仅限通过浏览器api操作，储存空间一般为5M大小，远大于cookie可以使用的空间，并且没有过期期限，除非用户主动清理会一直存在，通常在能用LocalStorage的地方尽量都用LocalStorage，前端不应该使用Cookie。</p>
<h1 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h1><p>sessionStorage与LocalStorage基本相同，只是sessionStorage过期不同，另外还有个显著的特点：sessionStorage会在窗口创建时初始化一个新的会话，也就是即使是同一个域名下不同窗口，sessionStorage也是不一样的。同时，在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点与使用cookie作为凭证是相似的。</p>
<h2 id="js操作方式-1"><a href="#js操作方式-1" class="headerlink" title="js操作方式"></a>js操作方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">remove</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()<span class="comment">//移除全部</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>LocalStorage</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM API</title>
    <url>/2018/05/27/DOM-API/</url>
    <content><![CDATA[<h1 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h1><p><code>DOM</code>全称为<code>Document Object Model</code>,是js用来操控XHTML,在DOM中，所有标签都是node的子集，文档最开始的属性标识了文档采用的版本，比如<code>&lt;!DOCTYPE html&gt;</code>表示是html5,这个属性每个HTML&#x2F;XHTML文档都必须具有。将文档每个标签以树形的方式组织方便js对 其进行操控，着建里起的模型就叫DOM。</p>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><p>DOM中所有标签及元素等都被抽象地称为<code>node</code>节点，比如对于<code>标签元素</code>，还具有</p>
<h1 id="DOM标准"><a href="#DOM标准" class="headerlink" title="DOM标准"></a>DOM标准</h1><p>Element对象代表页面中具有的标签，构造函数为Element,整个文档被称为document,对应的构造函数为Document<br>元素中的文字被Text构造出来</p>
<p>Element、Document、Text都继承自node，其它结点还有注释结点<code>Comment</code>这些，不过平时很少用</p>
<h2 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h2><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">节点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">标签</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">文字</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">注释</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">document</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">声明文档类型的标签</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">虚拟DOM</td>
</tr>
</tbody></table>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h3><p>返回节点的名称，除特例外总是返回名称的大写<br>特例：</p>
<ul>
<li><p>document<br>直接使用document.nodeName返回的是<code>#document</code>，需要使用<code>document.documentElement.nodeName</code>，才会正常返回<code>HTML</code></p>
</li>
<li><p>svg<br>  svg很特殊，只有它的标签是小写</p>
</li>
</ul>
<h3 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h3><p>获取到其节点内的所有文本内容(微软发明的)</p>
<h3 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h3><p>和上面一样，只是不会忽略style和script标签，性能会更好一点。（火狐发明的）</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h3><p>添加儿子</p>
<h3 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode()"></a>cloneNode()</h3><p>默认进行浅拷贝。如果传<code>true</code>进行深拷贝。</p>
<h3 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h3><p>是否包含指定元素</p>
<h3 id="hasChildNodes"><a href="#hasChildNodes" class="headerlink" title="hasChildNodes()"></a>hasChildNodes()</h3><p>是否有子节点</p>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h3><p>插入人到元素前面</p>
<h3 id="isEqualNode"><a href="#isEqualNode" class="headerlink" title="isEqualNode()"></a>isEqualNode()</h3><p>元素类型、内容、属性完全一致</p>
<h3 id="isSanmeNode"><a href="#isSanmeNode" class="headerlink" title="isSanmeNode()"></a>isSanmeNode()</h3><p>同一元素</p>
<h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild()"></a>removeChild()</h3><p>从DOM树中移除，等待被垃圾回收</p>
<h3 id="replaceChild-newChild-oldChild"><a href="#replaceChild-newChild-oldChild" class="headerlink" title="replaceChild(newChild,oldChild)"></a>replaceChild(newChild,oldChild)</h3><p>替换成指定的子节点</p>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>常规化，在一个”规范化”后的DOM树中，不存在一个空的文本节点，或者两个相邻的文本节点。</p>
<h1 id="Document接口"><a href="#Document接口" class="headerlink" title="Document接口"></a>Document接口</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>包含当前页面的元素</p>
<h3 id="characterSet"><a href="#characterSet" class="headerlink" title="characterSet"></a>characterSet</h3><p>返回使用的字符编码</p>
<h3 id="childElementCount"><a href="#childElementCount" class="headerlink" title="childElementCount"></a>childElementCount</h3><p>返回子元素个数</p>
<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>返回域名</p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>一个包含地址信息的对象</p>
<h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>是否正在下载</p>
<h3 id="referrer"><a href="#referrer" class="headerlink" title="referrer"></a>referrer</h3><p>从哪里访问过来</p>
<h3 id="visibilityState"><a href="#visibilityState" class="headerlink" title="visibilityState"></a>visibilityState</h3><p>该页面是否被显示</p>
<h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><h3 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h3><h3 id="documentElement"><a href="#documentElement" class="headerlink" title="documentElement"></a>documentElement</h3><h3 id="fullscreen"><a href="#fullscreen" class="headerlink" title="fullscreen"></a>fullscreen</h3><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><h3 id="onxxxxxxxxx"><a href="#onxxxxxxxxx" class="headerlink" title="onxxxxxxxxx"></a>onxxxxxxxxx</h3><h3 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h3><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><h3 id="readyState-1"><a href="#readyState-1" class="headerlink" title="readyState"></a>readyState</h3><h3 id="referrer-1"><a href="#referrer-1" class="headerlink" title="referrer"></a>referrer</h3><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><h3 id="scrollingElement"><a href="#scrollingElement" class="headerlink" title="scrollingElement"></a>scrollingElement</h3><h3 id="styleSheets"><a href="#styleSheets" class="headerlink" title="styleSheets"></a>styleSheets</h3><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>页面加载完毕后自动关闭</p>
<h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><p>向文档内写入东西，如在open时调用write会向文档追加内容，如果已经关闭了调用write会<strong>重写documentn的内容</strong>，这<strong>十分危险！</strong> 不能在任何<strong>异步</strong>或者<strong>延时性</strong>的操作上使用write</p>
<h3 id="writeln"><a href="#writeln" class="headerlink" title="writeln()"></a>writeln()</h3><p>写一行</p>
<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>页面一开始打开的时候启用open,可以向文档内写入数据</p>
<h3 id="execCommand"><a href="#execCommand" class="headerlink" title="execCommand()"></a>execCommand()</h3><p>文本编辑器会用到这个</p>
<h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment()"></a>createDocumentFragment()</h3><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h3><h3 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode()"></a>createTextNode()</h3><h3 id="exitFullscreen"><a href="#exitFullscreen" class="headerlink" title="exitFullscreen()"></a>exitFullscreen()</h3><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h3><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h3><h3 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h3><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h3><h3 id="getSelection"><a href="#getSelection" class="headerlink" title="getSelection()"></a>getSelection()</h3><h3 id="hasFocus"><a href="#hasFocus" class="headerlink" title="hasFocus()"></a>hasFocus()</h3><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h3><p>返回找到的第一个元素</p>
<h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h3><p>以伪数组的形式返回符合的所有元素</p>
<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>其中的HTML，被改写有安全风险</p>
<h1 id="一些其它需要注意的点"><a href="#一些其它需要注意的点" class="headerlink" title="一些其它需要注意的点"></a>一些其它需要注意的点</h1><p>看下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line">parent.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line">parent.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">parent.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allDiv = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">allDiv.<span class="property">length</span> <span class="comment">// 假设是 2</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)  )</span><br><span class="line">allDiv.<span class="property">length</span> <span class="comment">// 还是2</span></span><br></pre></td></tr></table></figure>
<p>这里length没有改变时因为<code>parent.childNodes</code>是动态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。<br> <code>document.querySelectorAll</code>方法返回的是一个静态集合(伪数组)。DOM内部的变化，并不会实时反映在该方法的返回结果之中。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM事件</title>
    <url>/2018/06/04/DOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="DOM标准"><a href="#DOM标准" class="headerlink" title="DOM标准"></a>DOM标准</h1><h2 id="标准前的标准"><a href="#标准前的标准" class="headerlink" title="标准前的标准"></a>标准前的标准</h2><p>在未指定标准前就已经有了事实上的标准<br>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button.<span class="property">onclick</span> = <span class="keyword">function</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DOM1"><a href="#DOM1" class="headerlink" title="DOM1"></a>DOM1</h2><p>有了更多的事件</p>
<ul>
<li>blur</li>
<li>click</li>
<li>focus</li>
<li>select</li>
</ul>
<h2 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h2><p>事件被单独列出来，有了拥有了事件流，事件捕获，事件冒泡，事件取消，也是最广泛的版本</p>
<h1 id="事件详解"><a href="#事件详解" class="headerlink" title="事件详解"></a>事件详解</h1><h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><ol>
<li><p>内联声明</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;xxx()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;xxx.call&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式比较奇怪的时第一种方式无效，下面两种方式有效，实际上这里等同于<code>eval(xxx())</code></p>
</li>
<li><p>js声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">button.<span class="property">onclick</span> = xxx</span><br><span class="line">button.<span class="title function_">addListener</span>(<span class="string">&#x27;click&#x27;</span>,xxx,options)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>onclick</code>与<code>addListener</code>的区别<br>前者是一个属性，只能赋值一个，后者是一个队列，可以监听多个事件，并按照声明顺序触发。<br>除此之外，第三个参数还可以指定一些布尔值</p>
</li>
</ol>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="捕获与冒泡"><a href="#捕获与冒泡" class="headerlink" title="捕获与冒泡"></a>捕获与冒泡</h3><p>在DON的事件模型中，事件传播被分为两个阶段，首先某事件触发后，会把该事件从父标签一级级传递给最终的子标签，这个阶段叫做捕获阶段，最终的子标签得到这个事件后，再把这个事件一级级返回到最上层父标签，这个过程叫做冒泡阶段，默认声明的事件是在冒泡阶段触发。值得注意的是，最终的子标签并不区分冒泡或捕获阶段，声明的多个事件按照声明先后触发。</p>
<p>如果只指定一个布尔值，则指是否在捕获阶段捕获事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button.<span class="title function_">addListener</span>(<span class="string">&#x27;click&#x27;</span>,xxx,ture)</span><br></pre></td></tr></table></figure>
<p>默认为在冒泡阶段捕获，也就是此值为false</p>
<p>阻止传播：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外jquery()的阻止默认事件是直接传false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(xxx).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>


<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="怎么达到点击别处关闭浮层的效果"><a href="#怎么达到点击别处关闭浮层的效果" class="headerlink" title="怎么达到点击别处关闭浮层的效果?"></a>怎么达到点击别处关闭浮层的效果?</h3><p>在<code>document</code>的冒泡阶段监听click事件，如果监听到就关闭浮层，而在浮层上监听click事件，阻止click事件冒泡。</p>
<p>我们还可以不使用阻止冒泡，我们在浮层被点击后添加一个0定时器，监听<code>document</code>，定时器会在空闲时触发，也就是当前事件传播结束，OK。</p>
<p>实现轮播细节<br>把第一张和最后一张复制到前面和后面，这里用<code>clone(true)</code>进行深克隆<br>复制后还要让其显示第二张</p>
<p><code>hidden()</code>再<code>show()</code>就可以隐藏动画,但是短时间的操作浏览器会合并,<code>offset()</code>可以让css立即生效而不计算</p>
<p>jquery还可以监听所有子元素的，为其添加事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;xxx&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;button&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>))</span><br></pre></td></tr></table></figure>
<p>这里 第二个参数是选择器</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML常用标签</title>
    <url>/2018/04/03/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p><em>注意：由于Markdown会自动将换行转换为&lt;br&gt;标签，为了避免换行，展现实际效果时的标签事实上都在同一行,这可能会带来一些空格的差异</em></p>
<h1 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt;div&gt;"></a>&lt;div&gt;</h1><p>没有实义，主要用来分组，默认样式为块级，会单独占一行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<div>A</div><div>B</div>
***
# <span\>
没有实义，主要用来分组和其它作用，默认样式为内嵌，与其它元素共存。
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>A<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
**效果：**
<span>A</span><span>B</span>
***
# <h1\>
表示一级标题，默认会加粗，二级标签使用`<h2>`，以此类推
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果：
<h1>一级标题<h1><h2>二级标题<h2><h3>三级标题<h3>
# <p\>
段落元素，表示一个文本的段落
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;埃菲尔铁塔最初是作为 1889 年世界博览会的入口而兴建的。得名于设计它的著名建筑、结构师古斯塔夫·埃菲尔。埃菲尔铁塔从 1887 年开始动工，直到 1898 年才结束。是目前世界上访问人数最多的付费建筑物，每年有 700 万人登上铁塔的最高处。&lt;/p&gt;</span><br></pre></td></tr></table></figure>
**效果：**
<p>埃菲尔铁塔最初是作为 1889 年世界博览会的入口而兴建的。得名于设计它的著名建筑、结构师古斯塔夫·埃菲尔。埃菲尔铁塔从 1887 年开始动工，直到 1898 年才结束。是目前世界上访问人数最多的付费建筑物，每年有 700 万人登上铁塔的最高处。</p>
***
# <strong\>
表示强调其中的内容，内容十分重要，会自动加粗，如果只是为了加粗，将其css中的`font-weight`属性设置为`"bold"`是更好的选择。**`em`**和其类似。

<p><em>由于Markdown只提供<code>**xxx**</code>的方式加粗文本，这被解释为&lt;strong&gt;xxx&lt;&#x2F;strong&gt;,所以我这里</em>*<code>效果：</code>*<em>的用法是不正确的。</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这个文本很重要<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong><br><strong>这个文本很重要</strong></p>
<hr>
<h1 id="lt-ul-gt"><a href="#lt-ul-gt" class="headerlink" title="&lt;ul&gt;"></a>&lt;ul&gt;</h1><p> 表示无序列表,用<code>&lt;li&gt;&lt;/li&gt;</code>来表示每一个例子&#x2F;选项，与其相似的还有<code>ol</code>有序列表<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>菠萝<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>效果：</strong></p>
<ul><li>葡萄</li><li>橘子</li><li>香蕉</li><li>菠萝</li></ul>
***

<h1 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a>&lt;img&gt;</h1><p>显示图片，<code>&lt;img&gt;</code>是一个空标签，没有带有带<code>/</code>的结束标签，且它也是一个可替换标签，它的相关样式由资源自己决定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/2018/03/17/Markdown%E5%85%A5%E9%97%A8/jz.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;紫罗兰永恒花园&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong><br><a href="/2018/03/17/Markdown%E5%85%A5%E9%97%A8/jz.png" download="紫罗兰紫罗兰永恒花园"><br><img data-src="/2018/03/17/Markdown%E5%85%A5%E9%97%A8/jz.png" alt="紫罗兰永恒花园" download></a></p>
<hr>
<h1 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt;a&gt;"></a>&lt;a&gt;</h1><p>可访问的链接，使用href指定访问的URL地址。也可以添加<code>download</code>属性，表示直接下载url的内容。</p>
<p><em>download属性只在当前协议为http&#x2F;https时有用</em></p>
<p><strong>href有多种状态</strong></p>
<ol>
<li><p><strong>绝对路径</strong><br> 以<code>/</code>开头，访问的是当前协议当前域名下的绝对地址</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/2018/03/17/Markdown入门/&quot;</span>&gt;</span>我的第一篇博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="/2018/03/17/Markdown入门/">我的第一篇博客</a></p>
</li>
<li><p><strong>相对路径</strong><br> 使用<code>.</code>或<code>..</code>可以访问当前目录和上级目录，默认会加上<code>./</code></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./龙王的工作.jpg&quot;</span>&gt;</span>点击查看《龙王的工作》图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="./龙王的工作.jpg">点击查看《龙王的工作》图片</a></p>
</li>
<li><p><strong>当前协议URL</strong><br> 使用很当前一致的协议补全URL</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;//baidu.com&quot;</span>&gt;</span>点击访问百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="//baidu.com">点击访问百度</a></p>
</li>
<li><p><strong>指定协议</strong><br> 输入一个完整的URL</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:yanglei1997630@gmail.com&quot;</span>&gt;</span>给我发邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="mailto:yanglei1997630@gmail.com">给我发邮件</a></p>
</li>
<li><p><strong>伪协议</strong><br> 伪协议是指以<code>javascript:</code>为属性值，点击之后执行javascript,<br> 这在某些方面有特殊的作用。<br> 如想点击<code>&lt;a&gt;</code></p>
<ul>
<li><p><strong>为空值</strong><br> 这种方法会导致重新刷新此页面</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;&quot;</span>&gt;</span>这会导致页面刷新<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="">这会导致页面刷新</a></p>
</li>
<li><p><strong>为<code>#</code></strong><br> 这种方法不会引起页面刷新，但会跳转到页面顶部</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这会导致跳转到页面顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="#">这会导致跳转到页面顶部</a></p>
</li>
</ul>
<p> 比较好的解决办法是使用<code>###</code>。<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;###&quot;</span>&gt;</span>不会发生任何事，但地址栏会轻微改变<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <strong>效果：</strong><br> <a href="###">不会发生任何事，但地址栏会轻微改变</a></p>
<ul>
<li><strong>javascript空语句</strong><br> 另一个办法就是javascript为伪协议，执行一段空javascrpt语句 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>不会发生任何事<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <strong>效果：</strong><br> <a href="javascript:;">不会发生任何事</a></li>
</ul>
</li>
</ol>
<hr>
<h1 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt;iframe&gt;"></a>&lt;iframe&gt;</h1><p>框架元素，主要用来在当前页面嵌入一个新的HTML页面，iframe几乎相当于独立的标签页，拥有自己独立的历史记录等，目前已经很少使用，不过在部分情况下仍然有用处。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>iframe未显示时出现的文本<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<iframe src="http://baidu.com"><p>iframe未显示时出现的文本<p></iframe>


<p>如想在iframe中打开你需要的页面,需要添加name属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>iframe未显示时出现的文本<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://qq.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span>点击在iframe中打开qq.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<iframe src="http://baidu.com" name="iframe"><p>iframe未显示时出现的文<p></iframe><a href="http://qq.com" target="iframe">点击在iframe中打开qq.com</a>

<p>除此之外，a标签还拥有其它target属性</p>
<ol>
<li><p><strong>_black</strong><br> 在新标签页打开</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击在新标签页内访问百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="http://baidu.com" target="_blank">点击在新标签页内访问百度</a></p>
</li>
<li><p><strong>_self</strong><br> 在本页内打开</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>点击在本标签页内访问百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <a href="http://baidu.com" target="_self">点击在本标签页内访问百度</a></p>
</li>
<li><p><strong>_parent</strong><br> 在父级页面打开</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_parent&quot;</span>&gt;</span>访问父级<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> 比如页面内嵌套一个iframe，iframe内有一个在这样的标签，是在上级页面打开。</p>
</li>
<li><p><strong>_parent</strong><br> 在根页面打开打开</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_parent&quot;</span>&gt;</span>访问父级<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> 在frame嵌套frame的多级嵌套情况下，无论嵌套多少层，总是在最开始的根页面打开。</p>
</li>
</ol>
<p>除此之外，因为自带的iframe边框比较丑，可以通过<code>frameborder=0</code>来禁用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://baidu.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>iframe未显示时出现的文本<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<iframe src="http://baidu.com" frameborder="0"><p>iframe未显示时出现的文本<p></iframe>
***
# <form\>
表单元素，用来提交给服务器表单数据，**<form\>**标签中包含有许多子标签，包括**<input\>** **<select\>** **<textarea\>**等等

<p>form元素使用<code>action</code>确定请求的地址，使用<code>method</code>确定请求的方式，<code>method</code>拥有两种方式，分别为post和get,通过开发者工具可以方便的看见请求的类型,默认使用get请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<form action="xxx" method="get">
<input type="submit" >
</form>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果：</strong></p>
<form action="xxx" method="post">
<input type="submit" >
</form>

<ol>
<li><p><strong>&lt;input&gt;</strong><br>input拥有许多type值，常见的有text、button、submit、checkbox、radio、password、file等。</p>
<ul>
<li><strong>submit</strong><br> 提交表单的内容 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <strong>效果：</strong> <form action="xxx" method="post">
 <input type="text" name="userName">
 <input type="text" name="password">
 <input type="submit" value="登录" >
 </form></li>
</ul>
<p> 其中，具有想提交内容的标签必须具有name，否则无法提交内容。<br> 使用get提交，会直接把内容加到路径后，使用post提交，会添加在header第四部分</p>
<p> 如果表单中没有form标签，没有指定type的&lt;button&gt;标签也具有提交功能<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <strong>效果：</strong><br> <form action="xxx" method="post"><br> <button>提交</button><br> </form></p>
<ul>
<li><p><strong>checkbox</strong><br> 多选框</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>喜欢吃的水果：<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lovaFruit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lovaFruit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;草莓&quot;</span>&gt;</span>草莓<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lovaFruit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;橘子&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <span>喜欢吃的水果：<span><label><input type="checkbox" name="lovaFruit" value="苹果">苹果</label><label><input type="checkbox" name="lovaFruit" value="草莓">草莓</label><label><input type="checkbox" name="lovaFruit" value="橘子">橘子</label></p>
</li>
<li><p><strong>radio</strong><br> 单选框</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你是男孩还是女孩？<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span>&gt;</span>女孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;boy&quot;</span>&gt;</span>男孩<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LGBT&quot;</span>&gt;</span>跨性别者<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<p> <strong>效果：</strong><br> <span>你是男孩还是女孩？</span><label><input type="radio" name="gender" value="girl">女孩</label><label><input type="radio" name="gender" value="boy">男孩</label><label><input type="radio" name="gender" value="LGBT">跨性别者</label></p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>&lt;select&gt;</strong><br>下拉列表，使用<code>disabled</code>不可选中，<code>selected</code>默认选中，<code>multipl</code>可以多选<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>四川<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>湖南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span>&gt;</span>台湾<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>效果：</strong><br><select><option selected>四川</option><option>广东</option><option>湖南</option><option disabled>台湾</option></select></p>
<hr>
<ol start="3">
<li><strong>&lt;textarea&gt;</strong><br>文本域，主要用来输入大量文本，可以使用<code>cols</code>指定列数，<code>rows</code>指定行数，但是这与字符长度不完全匹配</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">clos</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;50&quot;</span>&gt;</span>在这里输入<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<textarea clos="10" rows="10">在这里输入</textarea>

<hr>
<h1 id="lt-table-gt"><a href="#lt-table-gt" class="headerlink" title="&lt;table&gt;"></a>&lt;table&gt;</h1><p>表格标签，表格标签分别具有三部分，分别是头<code>&lt;thead&gt;</code>，身体<code>&lt;tbody&gt;</code>，脚<code>&lt;tfoot&gt;</code>，还有管内容的标签<code>&lt;th&gt;</code>，<code>&lt;tr&gt;</code>，<code>&lt;td&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thred</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thred</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>0101<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>99<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>0102<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>98<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>王麻子<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>0103<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>95<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thred</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thred</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table><thred><th>姓名</th><th>学号</th><th>成绩</th></thred><tr><td>张三</td><td>0101</td><td>99</td></tr><tr><td>李四</td><td>0102</td><td>98</td></tr><tr><td>王麻子</td><td>0103</td><td>95</td></tr><tbody></thred><tfoot></thred></table>

<p>还可以通过<code>&lt;colgroup&gt;</code>及其子元素<code>&lt;col&gt;</code>指定每一列的宽度</p>
<hr>
<p><em>OK</em></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>JSONP</title>
    <url>/2018/06/10/JSONP/</url>
    <content><![CDATA[<h1 id="为什么要使用JSONP？"><a href="#为什么要使用JSONP？" class="headerlink" title="为什么要使用JSONP？"></a>为什么要使用JSONP？</h1><p>在早期，访问html页面必须进行跳转，页面的展示也依靠点击超链接，由于加载一个新页面，这不可避免的需要进行刷新。<br>有些利用页面种嵌入<code>iframe</code>，点击链接&#x2F;按钮<code>iframe</code>访问页面，达到页面不刷新的目的，这种实现方式很丑陋。</p>
<p>而JSONP是一种更方便的更新数据方式，类似于现在的<code>ajax</code></p>
<h1 id="JSONP具体是怎么做的"><a href="#JSONP具体是怎么做的" class="headerlink" title="JSONP具体是怎么做的?"></a>JSONP具体是怎么做的?</h1><ol>
<li>创建一个随机的函数名，</li>
<li>创建一个<code>&lt;script&gt;</code>,并将<code>src</code>指向要访问的后端服务器地址，如<code>/?callback=函数名</code></li>
<li>将<code>&lt;script&gt;</code>加入文档就会立即向指定地址发起请求</li>
<li>服务器收到请求，将数据写入自己要返回的内容中，如<code>函数名(参数)</code>，</li>
<li>客户端收到，立即执行了<code>&lt;script&gt;</code>中的内容，也就是<code>函数名(参数)</code>,通过这种方式就完成了动态的更新。</li>
</ol>
<p>JSONP参数可以是任意的，不过为了统一，一般使用<code>callback=</code>这种调用。</p>
<p>JSONP的请求是跨域的，后端服务器只要实现了<code>callback</code>调用，就可以直接使用。但同时由于使用的是动态加载<code>&lt;script&gt;</code>资源，JSONP只能使用<code>get</code>方式请求资源。</p>
<p>jQuery对其进行了封装，调用方式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">    <span class="attr">dateType</span>: <span class="string">&#x27;jsonp&#x27;</span></span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">A</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我的简单实现可以在<a href="https://github.com/Geylnu/nodeServerDemo/blob/master/main.js">这里</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC</title>
    <url>/2018/07/09/MVC/</url>
    <content><![CDATA[<p>M:Model<br>V:view<br>c:controller</p>
<p>模块化 把每个分成一个个js小文件<br>每个模块把操作的html作为一个view，作为v（我觉得应该是model）<br>再生成一个controller，参数是view，接受view进行操作</p>
<p>这里最好将controller封装成一个对象，像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> controller = &#123;</span><br><span class="line">    <span class="attr">view</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="keyword">function</span> (<span class="params">view</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">view</span> = view</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">bindEvents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">bindEvents</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        xxx.<span class="title function_">addListener</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            xxx</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是监听函数中调用的是触发事件本身的元素，也就是这里取this取到的不是controller对象本身，这种情况可以使用箭头函数，箭头函数自身不具有this，使用的this向上寻找到的对象就是正确的了。</p>
<p>同时由于多个模块相互分离，并不知道其它模块的情况，可能出现全局变量污染的情况，因此，需要使用立即执行函数。</p>
<p>js中在ES6前不能使用<code>&#123;&#125;</code>包裹创建局部变量，避免全局变量污染可以使用<code>function</code>的创建局部变量环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.<span class="title function_">call</span>()</span><br></pre></td></tr></table></figure>
<p>但是这个方案实际还是存在问题，xxx其实也是一个全局变量</p>
<p>升级版就出现了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;.<span class="title function_">call</span>()</span><br></pre></td></tr></table></figure>
<p>然而遗憾的是这个方法会报语法错误</p>
<p>再升级版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">&#125;.<span class="title function_">call</span>()</span><br></pre></td></tr></table></figure>
<p>使用其它单目运算符也能起到一样的效果，整个包裹大括号也是可行的，但可能出现bug,比如被视为函数实参。<br>还可以用随机数，不过有点丑陋</p>
<p>同时还可以使用闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> person =&#123;&#125;</span><br><span class="line">    person.<span class="property">name</span> = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">getname</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Markdown入门</title>
    <url>/2018/03/17/Markdown%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown?"></a>什么是Markdown?</h2><p>Markdown是一种轻量的<a href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80" title="什么是标记语言？">标记语言</a>,允许人们以易读易写的纯文本方式编写文档，并可以轻松的转换为有效的HTML文档，许多网站及应用都使用Markdown或其它衍生版本让用户更专注于文档的写作，而不需要烦恼于排版、格式等琐碎的事情，你大可以在轻度写作上，告别word这样繁琐的工具。</p>
<h2 id="怎么使用Markdown"><a href="#怎么使用Markdown" class="headerlink" title="怎么使用Markdown?"></a>怎么使用Markdown?</h2><h3 id="我需要怎样的编辑器？"><a href="#我需要怎样的编辑器？" class="headerlink" title="我需要怎样的编辑器？"></a>我需要怎样的编辑器？</h3><p>Markdown无需任何编辑器，你可以在任意文档编辑器使用Markdown语法，即使不经过处理，纯文本的Markdown也拥有不错的阅读体验，如果你需要即时的预览的Markdown语法效果，你可以使用以下几个在线的编辑器</p>
<ol>
<li><a href="https://www.zybuluo.com/mdeditor">Cmd Markdown</a> 国内一款不错的Markdown在线编辑器</li>
<li><a href="https://jianshu.com/">简书</a> 需要注册一下，也支持Markdown</li>
<li><a href="https://dillinger.io/">dillinger</a> 很漂亮的一个在线编辑器，还支持许多云端备份，不过国内访问很慢，中文支持也不好，如果你在国外还是不错的。</li>
</ol>
<h3 id="Makedown的具体语法是怎样的？"><a href="#Makedown的具体语法是怎样的？" class="headerlink" title="Makedown的具体语法是怎样的？"></a>Makedown的具体语法是怎样的？</h3><p>Makedown的语法是相当简单的，你至多只需要十分钟就能掌握Markdown语法，我推荐你打开上述的在线编辑器，一起来编辑看看效果！</p>
<h4 id="1-我想要一个标题？"><a href="#1-我想要一个标题？" class="headerlink" title="1. 我想要一个标题？"></a>1. 我想要一个标题？</h4><p>你可以这样输入<br>    # 标题</p>
<p><strong>效果：</strong></p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>嘿！看看你是否正确的在#号后加了空格？虽然许多编辑器支持不带空格的写法，但标准的Markdown标签里应该加上空格。</p>
<hr>
<h4 id="2-我想要一个多级标题？"><a href="#2-我想要一个多级标题？" class="headerlink" title="2. 我想要一个多级标题？"></a>2. 我想要一个多级标题？</h4><p>你可以这样输入<br>    # 一级标题<br>    ## 二级标题<br>    ### 三级标题<br><strong>效果:</strong></p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><hr>
<h4 id="3-标题有了，段落（正文）又该怎么写？"><a href="#3-标题有了，段落（正文）又该怎么写？" class="headerlink" title="3. 标题有了，段落（正文）又该怎么写？"></a>3. 标题有了，段落（正文）又该怎么写？</h4><p>不需要怎么写！Markdown并不需要你做多余的工作，你只需要自然的<strong>回车换行</strong>，即是下一个段落。</p>
<pre><code>由若干“来自GitHub、Reddit、Stack Exchange以及开源社区的重要代表”组成了一个“小型非公开工作组”，打算将Markdown标准化，并为了进一步的改进开放该标准。工作组于近日发布了Standard Markdown，随之有专门的网站standardmarkdown.com，但发布几天后应Gruber的要求被迫关闭了。

在一则发给Atwood的私信中，Gruber说标准使用了Markdown“令人愤怒”，要求标准化工作组重新命名项目，关闭standardmarkdown.com并且道歉。对于名字，Gruber建议工作组可以使用比如Strict Markdown或Pedantic Makrdown类似的名字。Atwood希望有其他的名称，在等待Gruber的反馈一天无果后，将其重命名为Common Markdown。
</code></pre>
<p><strong>效果：</strong><br>由若干“来自GitHub、Reddit、Stack Exchange以及开源社区的重要代表”组成了一个“小型非公开工作组”，打算将Markdown标准化，并为了进一步的改进开放该标准。工作组于近日发布了Standard Markdown，随之有专门的网站standardmarkdown.com，但发布几天后应Gruber的要求被迫关闭了。</p>
<p>在一则发给Atwood的私信中，Gruber说标准使用了Markdown“令人愤怒”，要求标准化工作组重新命名项目，关闭standardmarkdown.com并且道歉。对于名字，Gruber建议工作组可以使用比如Strict Markdown或Pedantic Makrdown类似的名字。Atwood希望有其他的名称，在等待Gruber的反馈一天无果后，将其重命名为Common Markdown。</p>
<hr>
<h4 id="4-我想引用其他人的话语-x2F-句子该怎么办？"><a href="#4-我想引用其他人的话语-x2F-句子该怎么办？" class="headerlink" title="4. 我想引用其他人的话语&#x2F;句子该怎么办？"></a>4. 我想引用其他人的话语&#x2F;句子该怎么办？</h4><pre><code>&gt; 鹅，鹅，鹅，曲项向天歌。
  白毛浮绿水，红掌拨清波。
              ————骆宾王
</code></pre>
<p><strong>效果：</strong></p>
<blockquote>
<p>鹅，鹅，鹅，曲项向天歌。<br>  白毛浮绿水，红掌拨清波。<br>                  ————骆宾王</p>
</blockquote>
<p>你还可以多级嵌套这些引用：</p>
<pre><code>&gt; 鲁迅说：
&gt;&gt; 鲁迅没有说过这句话
            ————鲁迅
</code></pre>
<p><strong>效果：</strong></p>
<blockquote>
<p>鲁迅说：</p>
<blockquote>
<p>鲁迅没有说过这句话<br>—————鲁迅</p>
</blockquote>
</blockquote>
<hr>
<h4 id="5-我需要一个列表？"><a href="#5-我需要一个列表？" class="headerlink" title="5. 我需要一个列表？"></a>5. 我需要一个列表？</h4><pre><code>*《如果有妹妹就好了》
*《小林家的妹抖龙》
*《紫罗兰永恒花园》
*《罗小鸽战记》
</code></pre>
<p><strong>效果：</strong></p>
<ul>
<li>《如果有妹妹就好了》</li>
<li>《小林家的妹抖龙》</li>
<li>《紫罗兰永痕花园》</li>
<li>《罗小鸽战记》<br>如果你愿意，你还可以使用 <code>+</code> 或 <code>-</code> 代替 <code>*</code> 号，它们的作用是等同的。</li>
</ul>
<p>如果你需要一个有序列表，你可以这样做：<br>    1. 先看看3<br>    2. 看看4写的什么<br>    3. 再看看2<br>    4. 回去看看1<br><strong>效果：</strong></p>
<ol>
<li>先看看3</li>
<li>看看4写的什么</li>
<li>再看看2</li>
<li>回去看看1</li>
</ol>
<p>如果你愿意，你也可以不按顺序写上标号，这也能够被正常解析。</p>
<pre><code>4. 先看看3
2. 看看4写的什么
1. 再看看2
4. 回去看看1
</code></pre>
<p><strong>效果：</strong><br>4. 先看看3<br>2. 看看4写的什么</p>
<ol>
<li>再看看2</li>
<li>回去看看1</li>
</ol>
<p>你还可以做一个代办事项列表</p>
<pre><code>- [ ] 不勾选
- [x] 勾选
</code></pre>
<p><strong>效果：</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 不勾选</li>
<li><input checked="" disabled="" type="checkbox"> 勾选</li>
</ul>
<hr>
<h4 id="我需要在文章中插入链接？"><a href="#我需要在文章中插入链接？" class="headerlink" title="我需要在文章中插入链接？"></a>我需要在文章中插入链接？</h4><ul>
<li><p>行内式：</p>
<p>  <a href="https://github.com/">Gayhub</a></p>
</li>
<li><p>参考式：</p>
<p>  [Gayhun][1]<br>  [1]:<a href="http://github.com/">http://github.com</a></p>
</li>
</ul>
<p><strong>释义：</strong></p>
<ul>
<li><p>行内式：<br>[显示的文本](点击文本访问的链接)</p>
</li>
<li><p>参考式<br>[显示的文本][自己定义的id]<br>[自己定义的id]:链接<br>参考式基本和行内式没有差别，只是可以预先定义要显示的文本。</p>
</li>
</ul>
<p><strong>效果：</strong><br><a href="http://github.com/">Gayhub</a></p>
<p>如果你需要鼠标悬停时给出提示信息，你可以这样</p>
<pre><code>[B站](https://bilibili.com &quot;点此访问bilibili&quot;)
</code></pre>
<p><strong>释义：</strong><br>[显示的文本](点击文本访问的链接 “鼠标悬停时的提示信息”)<br><strong>效果</strong><br><a href="https://bilibili.com/" title="点此访问bilibili">B站</a></p>
<p><strong>这样写还是有点麻烦？</strong><br>在显示文本和链接一致的情况下，你只需</p>
<pre><code>&lt;https://bilibili.com&gt;
</code></pre>
<p><strong>效果：</strong><br><a href="https://bilibili.com/">https://bilibili.com</a></p>
<hr>
<h4 id="插入图片怎么办？"><a href="#插入图片怎么办？" class="headerlink" title="插入图片怎么办？"></a>插入图片怎么办？</h4><pre><code>![紫罗兰永恒花园](./jz.png &quot;紫罗兰永痕花园&quot;)
</code></pre>
<p><strong>释义：</strong><br>[ 图片未加载成功时的帮助文本 ](图片的链接 “鼠标悬停时的提示信息”)</p>
<p>图片也拥有和链接相似的参考式写法。<br><strong>效果：</strong><br><img data-src="/2018/03/17/Markdown%E5%85%A5%E9%97%A8/jz.png" alt="紫罗兰永痕花园" title="紫罗兰永痕花园"></p>
<hr>
<h4 id="我想在文章中显示代码？"><a href="#我想在文章中显示代码？" class="headerlink" title="我想在文章中显示代码？"></a>我想在文章中显示代码？</h4><p><strong>1. 原生风格：</strong><br>首行缩进<strong>4个空格</strong>或是一个<strong>制表符</strong><br><img data-src="/2018/03/17/Markdown%E5%85%A5%E9%97%A8/ys1.png" alt="显示代码演示"></p>
<p><strong>效果：</strong></p>
<pre><code>    int main()&#123;
        printf(&quot;Hello world!&quot;);
        return 0;
    &#125;
</code></pre>
<p><strong>2. Github风格</strong><br>使用 <strong>```</strong> 包裹代码</p>
<p><img data-src="/2018/03/17/Markdown%E5%85%A5%E9%97%A8/ys2.png" alt="显示代码演示"></p>
<p><strong>效果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int  main()&#123;</span><br><span class="line">    printf(&quot;Hello world!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="我想用表格来展示？"><a href="#我想用表格来展示？" class="headerlink" title="我想用表格来展示？"></a>我想用表格来展示？</h4><pre><code>英雄名称| 击杀 |死亡| 助攻
:--|:--:|--:| --:
斧王|1|50|5
宙斯|5|5|5
炸弹人|56|5|41
</code></pre>
<p><strong>释义：</strong><br>第一行代表表头，第二行代表对齐方式控制，第三行开始是内容。<br>其中 <code>:--</code>代表左对齐，<code>--:</code>代表右对齐，<code>:--:</code>代表居中对齐。</p>
<p><strong>效果：</strong></p>
<table>
<thead>
<tr>
<th align="left">英雄名称</th>
<th align="center">击杀</th>
<th align="right">死亡</th>
<th align="right">助攻</th>
</tr>
</thead>
<tbody><tr>
<td align="left">斧王</td>
<td align="center">1</td>
<td align="right">50</td>
<td align="right">5</td>
</tr>
<tr>
<td align="left">宙斯</td>
<td align="center">5</td>
<td align="right">5</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">炸弹人</td>
<td align="center">56</td>
<td align="right">5</td>
<td align="right">41</td>
</tr>
</tbody></table>
<hr>
<h4 id="我想让我的文本更有表现力？"><a href="#我想让我的文本更有表现力？" class="headerlink" title="我想让我的文本更有表现力？"></a>我想让我的文本更有表现力？</h4><ul>
<li><p><strong>斜体</strong></p>
<pre><code>  *这是一串斜体*
</code></pre>
<p>  <strong>效果：</strong></p>
<p>  <em>这是一串斜体</em></p>
</li>
<li><p><strong>粗体</strong><br>  <strong>这是一串粗体</strong><br>  <strong>效果：</strong></p>
<p>  <strong>这是一串粗体</strong></p>
</li>
<li><p><strong>单独显示一串代码</strong><br>  <code>Hello world</code><br>  <strong>效果：</strong></p>
<p>  <code>Hello world</code></p>
</li>
<li><p><strong>给文字加上删除线</strong><br>  <del>这是要被删除的文字</del><br>  <strong>效果：</strong></p>
<p>  <del>这是要被删除的文字</del></p>
</li>
<li><p><strong>添加水平线</strong><br>  ***<br>  <strong>效果：</strong></p>
<hr>
</li>
</ul>
<hr>
<h4 id="我想使用的字符字被看包括在Markdown语法内？"><a href="#我想使用的字符字被看包括在Markdown语法内？" class="headerlink" title="我想使用的字符字被看包括在Markdown语法内？"></a>我想使用的字符字被看包括在Markdown语法内？</h4><p>你可以使用在你想使用的字符前添加转义符<code>\</code></p>
<pre><code>    \\
</code></pre>
<p><strong>效果：</strong><br>\</p>
<p><strong>你可以对这些字符进行转义</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|反斜线</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#96;</td>
<td align="center">反引号</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">星好</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">底线</td>
</tr>
<tr>
<td align="center">{}</td>
<td align="center">花括号</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">方括号</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">括号</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">井号</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减号</td>
</tr>
<tr>
<td align="center">,</td>
<td align="center">英文句点</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">感叹号</td>
</tr>
</tbody></table>
<hr>
<h3 id="一切OK"><a href="#一切OK" class="headerlink" title="一切OK"></a>一切OK</h3>]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Terminal 打造最美终端~</title>
    <url>/2020/01/08/Windows-Terminal-Wsl-%E6%89%93%E9%80%A0%E6%9C%80%E7%BE%8E%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自己之前在Windows一直使用<a href="https://cmder.net/">cmder</a>作为自己的终端使用，主要就是自带颜值比git-bash这些高很多，不过在把Windows升级到1909版本，cmder不知为何无法连接到<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" title="Windows Linux子系统">wsl</a>了, 正好也想试试微软新出的<a href="https://github.com/microsoft/terminal">Windows Terminal</a></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接在<a href="https://www.microsoft.com/en-us/p/windows-terminal-preview/9n0dx20hk701">应用商店</a>里安装就可以了</p>
<h2 id="个性化Windows-Terminal"><a href="#个性化Windows-Terminal" class="headerlink" title="个性化Windows Terminal"></a>个性化Windows Terminal</h2><p>默认的Windows Terminal各个终端都是默认样式，劝退级别233。点击下拉菜单，点击设置就会打开Vscode来自己配置Windows Terminal了</p>
<p>添加新的终端需要在<code>profiles</code>属性下添加，类似下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;guid&quot;</span>: <span class="string">&quot;&#123;156bea93-de01-48ff-bce0-860cc70a73d5&#125;&quot;</span>, <span class="comment">//uuid 用于区分不同终端</span></span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#282c34&quot;</span>, <span class="comment">//背景颜色</span></span><br><span class="line">    <span class="string">&quot;closeOnExit&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;colorScheme&quot;</span>: <span class="string">&quot;Chester&quot;</span>, <span class="comment">//配色方案</span></span><br><span class="line">    <span class="string">&quot;commandline&quot;</span>: <span class="string">&quot;\&quot;%PROGRAMFILES%\\git\\usr\\bin\\bash.exe\&quot; -i -l&quot;</span>, <span class="comment">// 终端位置</span></span><br><span class="line">    <span class="string">&quot;cursorColor&quot;</span>: <span class="string">&quot;#FFFFFF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cursorShape&quot;</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fontFace&quot;</span>: <span class="string">&quot;Consolas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fontSize&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;historySize&quot;</span>: <span class="number">9001</span>,</span><br><span class="line">    <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;%SystemDrive%\\Program Files\\Git\\mingw64\\share\\git\\git-for-windows.ico&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="string">&quot;10, 10, 10, 10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;snapOnInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;startingDirectory&quot;</span>: <span class="string">&quot;%USERPROFILE%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;useAcrylic&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否启用毛玻璃特效</span></span><br><span class="line">    <span class="string">&quot;acrylicOpacity&quot;</span>: <span class="number">0.85</span> <span class="comment">// 透明度 仅在启用毛玻璃特效后有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要终端变得好看，配色是第一步，可以去<a href="https://github.com/mbadolato/iTerm2-Color-Schemes">iTerm2-Color-Schemes</a>上找一个自己喜欢的主题，复制<code>windowsterminal</code>同名文件的内容到<code>schemes</code>，比如我选择的<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/windowsterminal/Chester.json">Chester</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Chester&quot;</span>,</span><br><span class="line">    <span class="string">&quot;black&quot;</span>: <span class="string">&quot;#080200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="string">&quot;#fa5e5b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;green&quot;</span>: <span class="string">&quot;#16c98d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;yellow&quot;</span>: <span class="string">&quot;#ffc83f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="string">&quot;#288ad6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;purple&quot;</span>: <span class="string">&quot;#d34590&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cyan&quot;</span>: <span class="string">&quot;#28ddde&quot;</span>,</span><br><span class="line">    <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#e7e7e7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightBlack&quot;</span>: <span class="string">&quot;#6f6b68&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightRed&quot;</span>: <span class="string">&quot;#fa5e5b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightGreen&quot;</span>: <span class="string">&quot;#16c98d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightYellow&quot;</span>: <span class="string">&quot;#feef6d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightBlue&quot;</span>: <span class="string">&quot;#278ad6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightPurple&quot;</span>: <span class="string">&quot;#d34590&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightCyan&quot;</span>: <span class="string">&quot;#27dede&quot;</span>,</span><br><span class="line">    <span class="string">&quot;brightWhite&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#2c3643&quot;</span>,</span><br><span class="line">    <span class="string">&quot;foreground&quot;</span>: <span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把profiles中终端配置修改成对应主题名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;colorScheme&quot;</span>: <span class="string">&quot;Chester&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后顺带修改一下背景颜色，微调一下透明度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#282c34&quot;</span>,  <span class="comment">// 比较有质感的黑色</span></span><br><span class="line">    <span class="string">&quot;useAcrylic&quot;</span>: <span class="literal">true</span>,       </span><br><span class="line">    <span class="string">&quot;acrylicOpacity&quot;</span>: <span class="number">0.85</span>    <span class="comment">// 0.8左右都是比较适合的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现效果如下</p>
<p><img data-src="/2020/01/08/Windows-Terminal-Wsl-%E6%89%93%E9%80%A0%E6%9C%80%E7%BE%8E%E7%BB%88%E7%AB%AF/terminal.png" alt="效果"></p>
<p>这里用的是cat的升级版<a href="https://github.com/sharkdp/bat">bat</a>,需要在<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" title="Windows Linux子系统">wsl</a>下安装</p>
<h3 id="无法出现毛玻璃特效？"><a href="#无法出现毛玻璃特效？" class="headerlink" title="无法出现毛玻璃特效？"></a>无法出现毛玻璃特效？</h3><p>这可能是由于在系统设置中关闭了特效，可以打开设置-&gt;个性化-&gt;颜色-&gt;透明效果-&gt;启用打开毛玻璃特效，然后重新打开Windows Terminal就生效了</p>
<h3 id="进入后目录不是用户目录？"><a href="#进入后目录不是用户目录？" class="headerlink" title="进入后目录不是用户目录？"></a>进入后目录不是用户目录？</h3><p>可以在执行命令后面添加这些参数，相关issues可以看这里<a href="https://github.com/microsoft/terminal/issues/592">startingDirectory setting issue for wsl profile</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wsl.exe ~ -d Ubuntu&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>     </span><br></pre></td></tr></table></figure>

<h3 id="如何让wsl和windows通信？"><a href="#如何让wsl和windows通信？" class="headerlink" title="如何让wsl和windows通信？"></a>如何让wsl和windows通信？</h3><p>根据 <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-ux-changes">官方文档</a>,在<code>/etc/resolv.conf</code>中，会储存windows主机的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="comment"># [network]</span></span><br><span class="line"><span class="comment"># generateResolvConf = false</span></span><br><span class="line">nameserver 172.20.192.1</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用bash脚本提取它作为全局变量使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> win_host=<span class="string">&quot;<span class="subst">$(grep -oP &#x27;(?&lt;=nameserver )</span>\d&#123;1,3&#125;(?:\.\d&#123;1,3&#125;)&#123;3&#125;&#x27; /etc/resolv.conf)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$win_host</span></span><br><span class="line">172.20.192.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://<span class="variable">$&#123;win_host&#125;</span>:1080&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://<span class="variable">$&#123;win_host&#125;</span>:1080&quot;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax初探</title>
    <url>/2018/06/11/ajax%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="如何向后端请求数据？"><a href="#如何向后端请求数据？" class="headerlink" title="如何向后端请求数据？"></a>如何向后端请求数据？</h1><ul>
<li><p>form表单提交，使用method指定提交方式,action为提交的地址。</p>
</li>
<li><p>a标签点击能发请求<br>这两者都要刷新页面或者新开页面</p>
</li>
<li><p>img可以发请求，但请求的必须是图片 不需要增加到页面</p>
</li>
<li><p>script和link也可以发起请求，但link和script只能加载指定格式，但是需要加到页面</p>
</li>
</ul>
<p>之后，ie5在js中引入ActiveX对象（api），使js可以直接发起http请求<br>随后其它浏览器也跟进，取名<code>XMLHttpRequest</code><br>不到一年，谷歌推出gmail.com,这里可以说前端真正诞生了</p>
<p>ie6后来也成为了安装最多的浏览器60%,ie因此就膨胀了,随后微软拆开ie6的开发人员，只更新安全功能，让chrome也跟了上来</p>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>Jesse James Garrett 将一下技术取名AJAX（异步的javaScript和 XML</p>
<ol>
<li>使用XMLHttpRequest发请求</li>
<li>服务器返回xml格式的字符串</li>
<li>js解析xml，并更新局部页面(现在用JSON)</li>
</ol>
<p>使用<code>XMLHttpRequest</code>的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    request.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/XXX&#x27;</span>) <span class="comment">//初始化配置  请求方式忽略大小写  默认异步</span></span><br><span class="line">    request.<span class="property">onreadystatechange</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; request.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>) <span class="comment">//响应内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.<span class="title function_">send</span>() <span class="comment">//发送</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>网络响应的时间会很长，这段时间已经够javaScript执行很多任务了，所以需要使用异步</p>
<p><strong>readystate</strong></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><code>open()</code>方法还没有被调用</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><code>send()</code>方法还没有被调用</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>send()</code>方法已被调用，响应头和响应状态码已经返回</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">正在下载响应体</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">请求全部完成</td>
</tr>
</tbody></table>
<p>onreadystate 要注意放在前面</p>
<p>一般不用管300状态码. 浏览器会自动处理</p>
<h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><p>可以使用DOM api解析xml，但是很复杂，现在已经过时了。<br>1所以用什么更好的方法更好的表示数据呢？</p>
<p>后来道格拉斯·克罗克福发明了一种轻量的资料语言<a href="https://zh.wikipedia.org/zh-hans/JSON">JSON</a></p>
<h3 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h3><p>JSON支持<code>object</code> <code>array</code>两种数据组织方式，值支持<code>string</code> <code>number</code> <code>object</code> <code>array</code> <code>true</code> <code>false</code> <code>null</code><br>没有<code>undefined</code></p>
<p>json没有变量，不支持引用，没有原型链</p>
<ul>
<li>string 必须具有<code>&quot;&quot;</code><br>支持转义符<code>\\</code></li>
</ul>
<p>注意，永远返回的是字符串，只是将其解析为对象<br>解析:<code>JSON.parse(string)</code></p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略要求协议+端口+域名一模一样才允许发起AJAX请求，保证安全</p>
<p>本质是禁止一个域名的js在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止向另一个域名发送请求。</p>
<p>不是同源的网页不能使用ajax发起请求（实际上发起了，只是不能读取内容），其他都可以</p>
<p>简单规避方法就是使用CORS,服务端设置<code>Access-Control-Allow-Origin: xxx</code>响应头 表示允许xxx跨域访问</p>
<h2 id="设置header"><a href="#设置header" class="headerlink" title="设置header"></a>设置header</h2><p>必须在open()和send()之间调用。<br>send()可以为post 设置请求内容</p>
<p>getAllResponseHeader获得所有响应头</p>
<p>tcp进行分片传输，因此会先拿到先拿到最开始的状态包，就可以先判断是否需要继续接受等之后的逻辑</p>
<p>传多个变量很容易让别人不知道自己具体想传什么，这里可以采用传个对象的方式，这样就有名字了</p>
<p>设置header 接受多参数</p>
<p>析构赋值，把名字一样的赋到同名变量里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">param = &#123;<span class="attr">a</span>:<span class="string">&#x27;aga&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;gag&#x27;</span>,<span class="attr">c</span>:<span class="string">&#x27;aga&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = param</span><br></pre></td></tr></table></figure>
<p>对于函数可以采用这个方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">&#123;a,b,c&#125;</span>)&#123;<span class="comment">//取得参数中的abc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有很多方式比如对象键名为字符串，不可以调用变量，但是<code>[x]: sss</code>可以</p>
<p>自己写回调可能不同库不一样，回调函数名不统一，所以需要规范出来</p>
<p>Promise写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="title function_">then</span>() <span class="comment">//第一个是成功第二个是失败</span></span><br></pre></td></tr></table></figure>

<p>具体写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve,reject</span>)&#123;</span><br><span class="line"> xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas体验</title>
    <url>/2018/05/08/canvas%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="必要的初始化"><a href="#必要的初始化" class="headerlink" title="必要的初始化"></a>必要的初始化</h1><ol>
<li><p>canvas默认是一个inline-block元素，这通常会导致一些BUG产生，例如下方有空白，宽度不合理，建议将其显示为<code>block</code>元素</p>
</li>
<li><p>让画板覆盖全屏<br> 这里需要不能使用css为其设置样式，在css中设置的样式实际并没有改变画板内部的大小，只是将画布简单的放大。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas =<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">canvas.<span class="property">width</span> = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">canvas.<span class="property">height</span> = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>获得一个具有2D绘制功能的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h1><p>现在就可以开始绘制图像了<br>具体如何绘制可以参考官<a href="http://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html">api文档</a>，官方文档什么都有。</p>
<p>绘制肯定需要鼠标键盘事件了，js监听事件非常简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以从鼠标事件中得到事件触发的相关参数，我们这里只需要clientX和clientY就可以了，它们代表鼠标点击的是当前页面窗口的位置，并不是在canvas中的位置，有时候页面会被用户改变，此时也需要让canvas自动改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">autoSetSize</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">width</span> = <span class="title function_">getPageSize</span>().<span class="property">width</span></span><br><span class="line">    obj.<span class="property">height</span> = <span class="title function_">getPageSize</span>().<span class="property">height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span> (<span class="params">param</span>) &#123;</span><br><span class="line">    <span class="title function_">autoSetSize</span>(canvas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以了,getPageSize是前面函数的封装</p>
<p>另外需要注意的是canvas默认背景是透明的，需要自己画个颜色做背景。</p>
<h1 id="移动端优化"><a href="#移动端优化" class="headerlink" title="移动端优化"></a>移动端优化</h1><h2 id="历史渊源"><a href="#历史渊源" class="headerlink" title="历史渊源"></a>历史渊源</h2><p>最早的时候手机浏览采用的是一种wap语言，也就是HTML的简化版，到了iphone3Gs，乔布斯把真正的网页搬上了手机，它们把手机模拟成一个宽度为980px的网页，进行等比缩放，用户也可以放大进行点击。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>但是我们的画板我们并不需要缩放，我们因此就需要禁用它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>意思是内容宽度等于设备屏幕的物理宽度，初始比例为一，禁用缩放。<br>在移动端交互方式也不再一样，产生的是touch事件,touch事件会将每一个点的属性以数组的形式列在touch事件中。</p>
<p>但是我们如何判断其是否支持触摸？<br>在事件初始化过程中，如果设备支持此事件，事件监听会被置为<code>null</code>,而如果不具有，会为<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">onclick</span>)</span><br></pre></td></tr></table></figure>
<p>除此之外，在许多手机浏览器会给页面添加一些滚动的默认效果，比如露出背景，这需要使用preventDefault阻止。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>css布局</title>
    <url>/2018/04/22/css%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边的东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边的东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> red solid;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">49%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">49%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果见<a href="http://js.jirengu.com/xilocahoru/1/watch?html,css,output">jsBin</a></p>
<h1 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h1><p>中间加个<code>inline-block</code>的<code>div</code>并居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边的东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间的东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边的东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> red solid;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">margin-left</span>:auro;</span><br><span class="line">  <span class="attribute">margin-right</span>:auto;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果见<a href="http://js.jirengu.com/welotibebi/3/watch?html,css,output">jsBin</a></p>
<h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><ul>
<li><p>设置左右边距为auto;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br></pre></td></tr></table></figure>
<p>  优点：简单方便<br>  缺点：无法对已float元素生效,元素必须具有固定的宽度</p>
</li>
<li><p>设置为<code>inline-block</code>并<code>text-align: center</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*父元素*/</span></span><br><span class="line"><span class="attribute">text-align</span>: center</span><br><span class="line"><span class="comment">/*子元素*/</span></span><br><span class="line">display: inline-block</span><br></pre></td></tr></table></figure>
<p>  inline元素可以对父级元素使用<code>text-align: center</code><br>  优点：可以对float元素生效，也适用于多个块级元素需要垂直居中的情况<br>  缺点：容易出BUG，一般需要<code>vertical-align: top;</code>修复</p>
</li>
</ul>
<h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><ul>
<li><p>设置行高与高度相等</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure>
<p>设置<code>padding-top</code>与<code>pdding-bottom</code>也是可行的。<br>  缺点：只适合内联与内联块级元素</p>
</li>
<li><p>设置table布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*父元素*/</span></span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line"><span class="comment">/*子元素*/</span></span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br></pre></td></tr></table></figure>
</li>
<li><p>position和top和transform</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*父元素*/</span></span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="comment">/*子元素*/</span></span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>,<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h1><ul>
<li><p>方法1：绝对定位+margin:auto</p>
<p>  div{<br>  width: 200px;<br>  height: 200px;<br>  background: green;<br><br>  position:absolute;<br>  left:0;<br>  top: 0;<br>  bottom: 0;<br>  right: 0;<br>  margin: auto;<br>  }</p>
</li>
<li><p>方法2：绝对定位+负margin</p>
<p>  div{<br>  width:200px;<br>  height: 200px;<br>  background:green;<br><br>  position: absolute;<br>  left:50%;<br>  top:50%;<br>  margin-left:-100px;<br>  margin-top:-100px;<br>  }</p>
</li>
<li><p>方法3：绝对定位+transform</p>
<p>  div{<br>  width: 200px;<br>  height: 200px;<br>  background: green;<br><br>  position:absolute;<br>  left:50%;    &#x2F;* 定位父级的50% *&#x2F;<br>  top:50%;<br>  transform: translate(-50%,-50%); &#x2F;*自己的50% *&#x2F;<br>  }</p>
</li>
<li><p>方法4：flex布局</p>
<p> .box{<br>   height:600px;<br><br>   display:flex;<br>   justify-content:center;  &#x2F;&#x2F;子元素水平居中<br>   align-items:center;      &#x2F;&#x2F;子元素垂直居中<br>     &#x2F;* aa只要三句话就可以实现不定宽高水平垂直居中。 *&#x2F;<br>  }<br>  .box&gt;div{<br>  background: green;<br>  width: 200px;<br>  height: 200px;<br>  }</p>
</li>
</ul>
<h1 id="还可以使用"><a href="#还可以使用" class="headerlink" title="还可以使用"></a>还可以使用</h1><ul>
<li>flex布局，很方便</li>
</ul>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ul>
<li>使用<code>::before</code>和<code>::after</code>可以方便的创建新元素再给它加样式</li>
<li>可以重新设置盒模型<code>box-sizing</code>来方便的设置固定的比例的宽度等</li>
<li>可以使用伪类来选择特定状态&#x2F;性质的元素，如：<code>:nth-chlid(even)</code>,选择偶数子元素</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>https原理是什么?</title>
    <url>/2020/08/29/https%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自己初中的时候有过一段时间很好奇密码学相关的问题，当时就了解到了非对称加密，觉得很神奇，只要被公钥加密，就只有私钥才能解开，当时想，加密过程不过就是按照规则进行一些数学计算而已，怎么会不可逆呢？非对称加密是怎么做到这些的？怎么让网络变成可信的？<br>当时百度还挺可靠的，搜索到了一篇讲的很好文章，大概有了认知，可惜那篇文章找不到了；今天正好看到一个前端问题：https 原理是什么？就再学习了一次，写这篇博客记录下来。</p>
<h1 id="https-为什么出现"><a href="#https-为什么出现" class="headerlink" title="https 为什么出现?"></a>https 为什么出现?</h1><p>因为网络链路默认是不可信任的，HTTP 在整个传输过程中无法保证数据不被窥探、篡改，常见的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>就是利用了这个原理，日常经常发现的网页出现莫名奇妙的新增广告，通常叫做运营商劫持，就是一种中间人攻击。</p>
<h1 id="https-如何防止中间人攻击的？"><a href="#https-如何防止中间人攻击的？" class="headerlink" title="https 如何防止中间人攻击的？"></a>https 如何防止中间人攻击的？</h1><p>https 在 TCP 传输层和 HTTP 应用层之间再加了一层 SSL&#x2F;TSL(传输层安全协议)，用于对 HTTP 报文进行加密。</p>
<p>SSL&#x2F;TSL 采用基于公钥的加密算法，比如最常用的<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">RSA 算法</a>。</p>
<p>RSA 是一种非对称加密算法，在了解非对称加密前，先了解一下对称加密，对称加密指的是在加密或者解密时使用相同的密钥。就像是为数据上一把锁，同时也要把钥匙拿给解密的人。<br>使用对称加密的过程往往是这样的：</p>
<ul>
<li>A 生成随机密钥 K</li>
<li>A 与 B 通过某种方式</li>
<li>A 密钥 K 加密明文数据</li>
<li>A 传输密文数据</li>
<li>B 使用密钥 K 解密密文</li>
<li>得到明文数据<br>对称加密的一大问题就是存在密钥交换环节，想要解密必须传输密钥，而传输密钥这个环节，往往容易泄露密钥，整个加密环节也就不安全了。</li>
</ul>
<p>非对称加密算法就解决了这个问题，密钥加密解密使用不同的密钥，避免了密钥交换环节，最著名的非对称加密算法就是 RSA 算法</p>
<h2 id="RSA-算法是怎么工作的？"><a href="#RSA-算法是怎么工作的？" class="headerlink" title="RSA 算法是怎么工作的？"></a>RSA 算法是怎么工作的？</h2><p>RSA 算法利用了数论方面的知识，详细的数学解释可以看阮一峰的博客，简单易懂（虽然自己只看了半懂 233）</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一) 阮一峰</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二）阮一峰</a></li>
</ul>
<p>整个过程简单概述，为</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><ol>
<li>随机选择两个不相等的质数<strong>p</strong>和<strong>q</strong></li>
<li>计算<strong>p</strong>和<strong>q</strong>的乘积<strong>n</strong></li>
<li>计算<strong>n</strong>的欧拉函数 φ(n)，φ(n) &#x3D; (p-1)(q-1)</li>
<li>随机选择一个整数<strong>e</strong>，条件是 1&lt; e &lt; φ(n)，且 e 与 φ(n) 互质</li>
<li>计算<strong>e</strong>对于 φ(n)的模反元素<strong>d</strong>。</li>
<li>将<strong>n</strong>和<strong>e</strong>封装成公钥，<strong>n</strong>和<strong>d</strong>封装成私钥。</li>
</ol>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><ol>
<li>假设需要加密的密文为 m，m 必须是整数，且<strong>m</strong>必须小于<strong>n</strong></li>
<li>利用公钥（n,e）计算加密的密文<code>c=m^e mod n</code></li>
<li>利用私钥（n,d）解密密文 <code>m=c^d mod n</code></li>
</ol>
<p>理论上公钥也可以当作公钥，也可以当作私钥，但实际上为了方便客户端进行加密和防止破解，公钥使用的 e 往往较小，私钥的更大。</p>
<h2 id="对抗中间人攻击"><a href="#对抗中间人攻击" class="headerlink" title="对抗中间人攻击"></a>对抗中间人攻击</h2><p>只引入非对称加密算法实际上并不能阻止中间人攻击，非对称密钥加密依赖于公钥的正确性。<br>想想这样的场景:</p>
<ol>
<li>小昂给小蕾想秘密的通过网路传输些暧昧信息</li>
<li>小昂生成一对公钥和私钥，将公钥传输给小蕾</li>
<li>小蕾收到公钥，并且将信息利用公钥进行加密</li>
<li>小昂收到信息</li>
</ol>
<p>整个过程看样子很完美<br>但是这其中有一个很重大的缺陷，网络中一切数据都是可以被截获和伪造的，小蕾其实并不能确认公钥就是小昂发送的，公钥在传输中存在被掉包的可能</p>
<ol>
<li>小昂生成一对公钥和私钥，将公钥传输给小蕾</li>
<li>小艾在中途截获了传输的公钥，并替换成了自己公钥</li>
<li>小蕾利用小艾的公钥加密了信息</li>
<li>小艾利用了自己的私钥解密了小蕾的信息</li>
<li>小艾篡改了信息，并使用小昂的公钥重新加密了修改后的信息</li>
<li>小昂收到了被篡改的信息。</li>
</ol>
<p>这是个很大的问题！非对称加密并没有解决中间人攻击。</p>
<h3 id="证书机制"><a href="#证书机制" class="headerlink" title="证书机制"></a>证书机制</h3><p>证书机制利用了另一个特点，即被私钥加密的信息，可以被公钥解密，可以利用私钥对消息进行一次签名，证明自己就是私钥的拥有者。</p>
<p>证书机制是这样工作的</p>
<ol>
<li>首先由受信任的机构（CA）生成一组公钥和私钥</li>
<li>软件商（浏览器、操作系统）会将这个公钥内置在自己软件中，并信任这个公钥。</li>
<li>小昂为了自己的通信安全，证明自己就是公钥的拥有者，决定使用数字证书。</li>
<li>CA 收到小昂的申请，确认了小昂的身份。</li>
<li>CA 先生成了这个证书的基本信息<ul>
<li>使用者： 小昂</li>
<li>公钥：xxxxx</li>
<li>有效期限：xxxxx</li>
<li>公钥算法：RSA</li>
<li>证书版本：xxxx</li>
</ul>
</li>
<li>CA 利用 hash 算法计算上列信息的 hash 值，并用自己的私钥进行加密，并和上面的信息组合，成为最终的数字证书。<br>这时小昂就得到了自己的数字证书，可以证明自己时公钥的拥有者了。</li>
</ol>
<p>小昂与小蕾接下来的通信就是这样的</p>
<ol>
<li>小蕾向小昂发送请求</li>
<li>小昂出示自己的数字证书</li>
<li>小蕾对得到的证书进行验证，使用 CA 的公钥解密被加密的数字证书 hash，计算数字证书 hash 值，以保证证书未被篡改</li>
<li>小类使用数字证书的公钥和算法进行加密密文</li>
</ol>
<h3 id="使用对称密钥"><a href="#使用对称密钥" class="headerlink" title="使用对称密钥"></a>使用对称密钥</h3><p>在使用非对称密钥中，由于公钥是公开的，被私钥加密的内容实际可以被认为等同于明文，小蕾向小昂发送信息，只有小昂能够解密，但是任何持有公钥的人都能解密小昂使用私钥加密的内容。<br>并且非对称加密相比对称加密，运算复杂度要高一个数量级，如果要传输大量信息，性能消耗会很大，在这种情况下，引入对称密钥就是很有必要的了。</p>
<ul>
<li>在上文的前提下，小蕾随机生成一个密钥，并将这个密钥使用公钥加密，发送给小昂</li>
<li>小昂使用私钥解密这个私钥，并在接下来的过程中，转用这个对称加密密钥进行通信</li>
</ul>
<p>在这个过程中往往为了前向安全性，使用的是<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">DH 密钥交换算法</a>协商密钥，不依赖于 RSA 算法</p>
<h3 id="增强安全性"><a href="#增强安全性" class="headerlink" title="增强安全性"></a>增强安全性</h3><ul>
<li>为了防止重放攻击，SSL&#x2F;TLS 还会在密文中附带时间戳</li>
<li>为了保证内容完整性，SSL&#x2F;TLS 会计算内容的 hash 值并一同加密发送</li>
<li>为了防止从 https 降级成 http，https 拥有 HSTS(HTTP Strict Transport Security)，会强制客户端使用 https</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>http入门</title>
    <url>/2018/03/30/http%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h1><p>HTTP是HyperText Transfer Protoco的缩写，中文译作“超文本传输协议”，HTTP构建在TCP传输协议的基础上，处于应用层，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，不过目前HTTP协议已经不仅仅只为传输HTML服务，还有其他功能，不过传输HTML仍然是最主要的。</p>
<h1 id="怎样使用HTTP"><a href="#怎样使用HTTP" class="headerlink" title="怎样使用HTTP?"></a>怎样使用HTTP?</h1><p>在浏览器输入输入以HTTP或HTTPS作为协议名的URL就可以了<br>比如：<a href="https://www.google.com.hk/search?q=URL&amp;oq=URL">https://www.google.com.hk/search?q=URL&amp;oq=URL</a></p>
<h2 id="什么是URL"><a href="#什么是URL" class="headerlink" title="什么是URL?"></a>什么是URL?</h2><p>URL(统一资源定位符)是URI（统一资源标识符）的子集，或者说是一种具体实现，URI的定义不太好查，我的理解是URI是为了标识某一资源使用的某种编码方法，URL是通过使用其位置的方法标识资源，URI的另一个子集URN（统一资源名）是通过给予一个唯一的编码来标识资源。</p>
<h2 id="URL的具体样子"><a href="#URL的具体样子" class="headerlink" title="URL的具体样子"></a>URL的具体样子</h2><pre><code>协议名://域名 端口 路径 ?查询参数 锚点
</code></pre>
<p>比如上文中的<code>https</code>就是协议名 <code>www.google.com.hk</code>为域名，端口这里留空，意思就是使用默认协议端口,<code>https</code>的默认端口为443，<code>/search</code>为路径，<code>?q=q=URL&amp;oq=URL</code>就是请求参数，请求参数以<code>?</code>开头，以<code>&amp;</code>来分割每一对请求参数，<code>#</code>为锚点，主要用来在HTML精确指定展示的段落。</p>
<h2 id="回车后会发生什么？"><a href="#回车后会发生什么？" class="headerlink" title="回车后会发生什么？"></a>回车后会发生什么？</h2><p>浏览器会将其解析URL中的协议名，准备使用指定的协议发送报文，解析到主机时，使用DNS查询主机的ip地址，</p>
<h3 id="DNS又是什么？"><a href="#DNS又是什么？" class="headerlink" title="DNS又是什么？"></a>DNS又是什么？</h3><p>域名解析服务，互联网的世界里只需要一串数字（ip）就可以标识一台唯一的主机，但是纯数字往往人记不清，比如谷歌的一台服务器ip：172.217.1.131，远远没有google.com.hk好记。域名等级从右向左看所处的位置，每隔一个点降一级，比如<code>www.google.com.hk</code>，<code>hk</code>是顶级域名(一级域名)，<code>com</code>是二级域名，<code>google</code>是三级域名，<code>www</code>是四级域名，查询域名的方式是从一级域名开始，一级级向下查询,其中还有内置的根域名服务器，主要用来查询顶级域名。</p>
<h3 id="DNS又是怎么运作的？"><a href="#DNS又是怎么运作的？" class="headerlink" title="DNS又是怎么运作的？"></a>DNS又是怎么运作的？</h3><p>DNS采用一级级域名分配的方式方便查询，比如我们目前请求的主机名（域名）为<a href="https://www.google.com.hk/">https://www.google.com.hk</a>。</p>
<p>首先会查询我们本机的缓存，如果没有或者过期，就向当前网关指定的DNS服务器进行查询（在家庭里通常是你的路由器），如果仍然没有查询到，就会再向上级查询，通常这级请求的就是ISP的DNS服务器（互联网服务提供商，也就是我们经常说的联通，电信，移动这些电信运营商），ISP的DNS服务器拥有大量的缓存，更新也比较及时，基本在这里就会心满意足的得到IP了（不这样每次输个网址等大半天，不然得被投诉死），但是如果真的ISP的DNS服务器也没有呢？这时就会进入标准流程，服务器检查本地是否有.hk域名解析服务器的地址，如果没有会向13个根服务器（或其镜像）查询<code>.hk</code>域名解析服务器的地址，当然作为香港地区的一级域名，ISP的域名解析服务器一定会缓存的，ISP的DNS服务器向<code>.hk</code>的域名服务器询问<code>www.google.com.hk</code>的ip地址,<code>.hk</code>给出其子域名<code>.com.hk</code>的域名服务器地址，ISP域名服务器再向<code>.com.hk</code>的域名服务器询问，<code>.com.hk</code>的域名服务器返回<code>.google.com.hk</code>,再次查询，终于得到结果，OK。其实DNS有两种查询方式，分为递归查询和迭代，递归查询和迭代查询，递归要求必须返回最终的准确结果，迭代查询返回的是下一个子域名DNS服务器的地址，我们这里举例的就是迭代查询。</p>
<p>DNS这里就告一段落了</p>
<h2 id="得到ip准备发送报文"><a href="#得到ip准备发送报文" class="headerlink" title="得到ip准备发送报文"></a>得到ip准备发送报文</h2><p>解析到ip就可以准备发送报文了</p>
<p>为了看见自己发送的报文，我们可以使用curl命令来查看整个过程。</p>
<h3 id="学习curl命令的使用"><a href="#学习curl命令的使用" class="headerlink" title="学习curl命令的使用"></a>学习curl命令的使用</h3><p>直接使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl</span><br></pre></td></tr></table></figure>
<p>会直接输出返回的HTML文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s</span><br></pre></td></tr></table></figure>
<p>不要显示进度和警告，多余的东西闭嘴不要告诉我</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v</span><br></pre></td></tr></table></figure>
<p>显示更多的连接信息，其中</p>
<ul>
<li><code>&gt;</code>你发送的部分</li>
<li><code>&lt;</code>你收到的部分</li>
<li><code>*</code>由curl提供的辅助信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>在报文的head部分添加指定的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>指定请求的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>指定请求为post时发送的数据</p>
<p>现在我们就用curl 命令来试试请求<a href="https://www.google.com.hk/">https://www.google.com.hk</a></p>
<h3 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h3><p>我们首先先忽略掉以*开头的部分，从上往下看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: www.google.com.hk</span><br><span class="line">&gt; User-Agent: curl/7.47.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>这里请求可以分为4部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 请求方式 路径及参数 协议版本</span><br><span class="line">2. 各种参数对</span><br><span class="line">2. 各种参数对</span><br><span class="line">2. 各种参数对</span><br><span class="line">3. 一个空行</span><br><span class="line">4. 要发送的数据</span><br></pre></td></tr></table></figure>

<h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>这部分指定请求的关键信息，必不可少。</p>
<ul>
<li><p>请求方式<br>  请求方式实际有很多种，最常用的就是get和post。</p>
<ul>
<li>GET 服务器给我个东西<br>  直接在浏览器输入地址进行访问的方式就是get,get最大的特点就是请求参数是直接附在URL路径的路径后面，这个路径及参数直接显示在浏览器地址栏，并可以被保存为书签，可以在历史记录中看到，get请求的资源也往往可以被缓存。</li>
<li>POST 寄给服务器一个东西<br>  在HTML中表单默认的提交方式就是POST,表示把数据发给服务器，这部分数据在报文的第四部分，POST不会再地址栏，历史记录中，一般不可缓存。</li>
<li>PUT 整体更新<br>  没用过，看文章摸不着头脑，待更新</li>
<li>PATCH 局部更新<br>  同上</li>
<li>HEAD 给我看下资源的相关信息<br>  用来确定资源的相关信息，再考虑执行什么动作，这样以较少带宽消耗</li>
<li>OPTIONS 服务器你告诉我一下支持的请求方法。<br>  比如我问一下谷歌支持什么请求方法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; HTTP/1.1 405 Method Not Allowed</span><br><span class="line">&lt; Allow: GET, HEAD</span><br><span class="line">&lt; Date: Sat, 31 Mar 2018 06:54:15 GMT</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Server: gws</span><br><span class="line">&lt; Content-Length: 1592</span><br><span class="line">&lt; X-XSS-Protection: 1; mode=block</span><br><span class="line">&lt; X-Frame-Options: SAMEORIGIN</span><br></pre></td></tr></table></figure>
  只支持GET和HEAD。</li>
</ul>
</li>
<li><p>路径及参数<br>值得注意的是这里的路径和URL中定义中的路径不一样，这里会包括参数</p>
</li>
<li><p>协议版本<br>HTTP有很多个版本，低版本支持的东西少一些。</p>
</li>
</ul>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>这部分作为补充信息，表达更多的东西<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: www.google.com.hk</span><br></pre></td></tr></table></figure>
<p>用来指示这个http请求的是那个域名，比如有多个域名都指向同一IP，服务器接收到报文，就查找Host的字段，确定请求的是那个域名下的资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: curl/7.47.0</span><br></pre></td></tr></table></figure>
<p>发起请求的客户端（我）的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>客户端（我）可以接受的数据类型</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>这部分固定为空行，用来分割1、2部分和4部分的联系，有时候我们也以空格为界，把空格上的部分称为head部分，下部分称为body部分。</p>
<h4 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h4><p>传输的数据。</p>
<h3 id="响应部分"><a href="#响应部分" class="headerlink" title="响应部分"></a>响应部分</h3><p>可能已经忘记了我们开始请求的谁了，贴一下命令</p>
<p><code>curl -s -v -- &quot;https://www.google.com.hk&quot;</code></p>
<p>这是响应部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 31 Mar 2018 07:03:53 GMT</span><br><span class="line">&lt; Expires: -1</span><br><span class="line">&lt; Cache-Control: private, max-age=0</span><br><span class="line">&lt; Content-Type: text/html; charset=Big5</span><br><span class="line">&lt; P3P: CP=<span class="string">&quot;This is not a P3P policy! See g.co/p3phelp for more info.&quot;</span></span><br><span class="line">&lt; Server: gws</span><br><span class="line">&lt; X-XSS-Protection: 1; mode=block</span><br><span class="line">&lt; X-Frame-Options: SAMEORIGIN</span><br><span class="line">&lt; Set-Cookie: 1P_JAR=2018-03-31-07; expires=Mon, 30-Apr-2018 07:03:53 GMT; path=/; domain=.google.com.hk</span><br><span class="line">&lt; Set-Cookie: NID=127=R-9OY1mXK_x-RPiO1dIs-6Noj2lg-Aq7rxtKPrZe9WoRtZAUpvURT_REdMZLag74mTGHBvnNfoIb6kImXFPS1acHFnNrru2C8WN5ggag5RtSF4e; expires=Sun, 30-Sep-2018 07:03:53 GMT; path=/; domain=.google.com.hk; HttpOnly</span><br><span class="line">&lt; Alt-Svc: hq=<span class="string">&quot;:443&quot;</span>; ma=2592000; quic=51303432; quic=51303431; quic=51303339; quic=51303335,quic=<span class="string">&quot;:443&quot;</span>; ma=2592000; v=<span class="string">&quot;42,41,39,35&quot;</span></span><br><span class="line">&lt; Accept-Ranges: none</span><br><span class="line">&lt; Vary: Accept-Encoding</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt;</span><br><span class="line">&lt;!doctype html&gt;&lt;h……（后面的太多了）</span><br></pre></td></tr></table></figure>

<p>响应部分其实和请求差不多，也分为四部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 协议版本 状态码 状态码描述文字</span><br><span class="line">2. 各种参数对</span><br><span class="line">2. 各种参数对</span><br><span class="line">2. 各种参数对</span><br><span class="line">3. 一个空行</span><br><span class="line">4. 响应的数据</span><br></pre></td></tr></table></figure>

<p>这里主要讲一下状态码<br>状态码分为5段</p>
<ol>
<li>100~199 部分响应</li>
<li>200~299 成功</li>
<li>300~399 重定向</li>
<li>400~499 客户端错误</li>
<li>500~599 服务器错误</li>
</ol>
<h4 id="100状态码"><a href="#100状态码" class="headerlink" title="100状态码"></a>100状态码</h4><p>很少遇到，现在steam被墙返回的就是108错误，还有就是需要转换协议遇见过101状态码</p>
<h4 id="200状态码"><a href="#200状态码" class="headerlink" title="200状态码"></a>200状态码</h4><p>请求成功 遇见新的再更新</p>
<h4 id="300状态码"><a href="#300状态码" class="headerlink" title="300状态码"></a>300状态码</h4><p>重定向到某个地址，一般会在第二部分添加Location字段指定新地址</p>
<ul>
<li>301 请求的资源被永久移动到了新地址，网址改域名了就可能用这个</li>
<li>302 请求的资源暂时移动到了新地址，这个我学校登陆认证后的页面就会302返回新地址，这个新地址指向个人主页，个人主页会设置cookies。</li>
</ul>
<h4 id="400状态码"><a href="#400状态码" class="headerlink" title="400状态码"></a>400状态码</h4><p>客户端错误</p>
<ul>
<li>400 请求的报文信息是错误的，写爬虫不填好refer,host这些经常遇见</li>
<li>403 请求的支援禁止访问，一般是因为没有权限。</li>
<li>404 请求的资源再服务器上找不到</li>
</ul>
<h4 id="500状态码"><a href="#500状态码" class="headerlink" title="500状态码"></a>500状态码</h4><p>服务器错误，我很少遇见。</p>
<h3 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h3><p>也是辅助性的文本，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date: Sat, 31 Mar 2018 07:03:53 GMT</span><br></pre></td></tr></table></figure>
<p>响应生成的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=Big5</span><br></pre></td></tr></table></figure>
<p>第四部分数据的格式和其使用的字符编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: NID=127=R-9OY1mXK……</span><br></pre></td></tr></table></figure>
<p>用来辨识用户身份</p>
<h3 id="其它部分和请求相同。"><a href="#其它部分和请求相同。" class="headerlink" title="其它部分和请求相同。"></a>其它部分和请求相同。</h3><h3 id="使用Google-Chrome开发者工具查看"><a href="#使用Google-Chrome开发者工具查看" class="headerlink" title="使用Google Chrome开发者工具查看"></a>使用Google Chrome开发者工具查看</h3><ol>
<li><p>打开Google Chrome</p>
</li>
<li><p>按<code>F12</code>，开发者工具就打开了</p>
</li>
<li><p>点击Network<br><img data-src="/2018/03/30/http%E5%85%A5%E9%97%A8/network.png"></p>
</li>
<li><p>输入你想访问的网址</p>
</li>
<li><p>点击新产生的条目，就能看见相关的东西了<br><img data-src="/2018/03/30/http%E5%85%A5%E9%97%A8/list.png"></p>
</li>
</ol>
<ul>
<li><code>Headers</code>主要显示相关的请求头和请求参数，这些信息会被Chorom解码排版，如果想看原始信息，点击<code>view source</code>。<br><img data-src="/2018/03/30/http%E5%85%A5%E9%97%A8/source.png"></li>
</ul>
<p><code>注意：</code>访问新的网页会删除之前访问的列表，如果不想自动删除，勾选<code>Preserve log</code></p>
<p><img data-src="/2018/03/30/http%E5%85%A5%E9%97%A8/log.png"></p>
<hr>
<p>OK，以后有什么新东西再来更新。</p>
]]></content>
      <tags>
        <tag>待更新</tag>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript入门</title>
    <url>/2018/05/09/javaScript%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>1991年 李爵士发明万维网<br>1992年 其同事发明html和css<br>1993年 成立w3c<br>1995年 网景公司成立 能够执行脚本</p>
<p>js之父Brendan Eich接到任务发明一种名为Mocha(咖啡配抹茶)的脚本语言，它需要看起来像java。js发布后，Unicode发布UTF-8，这就导致js不能完整兼容UTF-81996年微软模仿JS发明了Jscript。<br>在IE5.5微软推出JS发请求。<br>2004年Gmail利用这个功能做了一个网页上的程序，这让JS的地位大大提高。</p>
<p>这时就出现了前端（以js为生）</p>
<p>制约JS发展的问题</p>
<ul>
<li>大量全局变量</li>
<li>缺少标准库</li>
</ul>
<p>出现了ECMAScript 5,Es4胎死腹中<br>Es5做了个小升级，具体谷歌</p>
<p>rails社区（主要使用ruby）发明了coffeeScript，非常好用，ES6就迫在眉睫。</p>
<p>JS集大家之所长。原创之处不优秀，优秀之处非原创</p>
<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>IE8部分兼容ES5,IE7及以下则不兼容</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>ES7及以后，每年一更。</p>
<p>ESnext 还未正式公布的特性，可以使用webpack打包，使其支持。</p>
<h1 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h1><p>7 种数据类型</p>
<ol>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>symbol（ES6新增）</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ol>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>支持:</p>
<ul>
<li>十进制 1</li>
<li>浮点数 .1 &#x2F;&#x2F;0.1</li>
<li>科学计算法 1.23E2</li>
<li>二进制 0b011</li>
<li>八进制 0214542 &#x2F;&#x2F;以0开头并且没有大于7的数</li>
<li>十六进制 0x5116D</li>
</ul>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>‘你好’ “你好”</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>为了避免冲突使用</p>
<ul>
<li>\t 制表符</li>
<li>\n 回车</li>
<li>\ \</li>
</ul>
<p>多行字符串 \就可以了，但是如果后面接字符串，就会出现错误，且不容易发现。<br>也可以用 +号，+号最好，这样易于阅读的</p>
<p>ES6新增加了字符串语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="string">`123456</span></span><br><span class="line"><span class="string">7890`</span></span><br></pre></td></tr></table></figure>

<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ul>
<li>ture</li>
<li>false</li>
</ul>
<h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>全为真才为真，因为自动类型转换的缘故，实质上可以通过这种方式来简写<code>if</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ture</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">a&amp;&amp;b <span class="comment">//返回b的值</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">a&amp;&amp;b <span class="comment">//返回a的值</span></span><br></pre></td></tr></table></figure>
<p>在这里，a为ture的情况下,b的布尔值就等同整个函数的布尔值，所以返回b和返回运算后的布尔值是没有区别的，a为false的情况下同理</p>
<p><strong>注意，这种方式的<code>if</code>会难以阅读</strong></p>
<h3 id=""><a href="#" class="headerlink" title="||"></a>||</h3><p>一个为真就为真<br>简写<code>if</code>的形式和上面相反</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>有点类似java的enum</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>指针不指向任何地址，也就是地址为0。</p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>变量初始化会被初始化为undefined，不使用null是因为设计时认为null是数字0，这可能导致误解。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>除Object外都为基本类型,Object以hash表的方式组织对象,就是基本类型的组合。<br>注意<code>[]</code>表示声明一个空数组，<code>typeof []</code> 返回<code>Object</code>,但是以{0:’a’,1:’b’}，也是可以以数组的形式访问,但是<code>instanceof Array</code>返回false</p>
<h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><p>只支持以字符串声明key，注意最后以<code>,</code>结尾是ES5的新特性，ES3不支持，IE7及一下只支持IE</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;aarG&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空字符也可以是key，调用使用[‘’]<br>key不加引号视为标识符，不可以以数字开头<br>同时，如果key符合标识符，可以使用.来更方便的取得</p>
<h3 id="更改方式"><a href="#更改方式" class="headerlink" title="更改方式"></a>更改方式</h3><ul>
<li><code>in</code> 判断key是不是在对象当中，js声明的全局变量实际都绑定在window上，可以用<code>in</code>判断是否声明过</li>
<li><code>delete</code> 删除一个键值对</li>
<li><code>for(var key in person)</code> 遍历键值</li>
</ul>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>()</span><br></pre></td></tr></table></figure>
<p>得到一个可枚属性组成的数组</p>
<h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>返回对象的类型和方法</p>
<p>注意 <code>typeof null</code>返回Object</p>
<h1 id="去TM的js类型转换"><a href="#去TM的js类型转换" class="headerlink" title="去TM的js类型转换"></a>去TM的js类型转换</h1><h2 id="xx-toString"><a href="#xx-toString" class="headerlink" title="xx.toString()"></a>xx.toString()</h2><ul>
<li>number 以字符串的形式输出，可选参数为以何种进制输出数字<br>  注意：以<code>1.toString()</code>的方式是不可行的</li>
<li>boolean ture或者false</li>
<li>null 空指针，直接报错</li>
<li>undefined 直接报错</li>
<li>Object 总是输出[object Object]，除非重写覆盖了<code>toString()</code>方法 </li>
<li>{} 语法不支持</li>
</ul>
<p><strong>小技巧：</strong> xx + “”<br>js发现<code>+</code>运算符，会检测算子是否有运算符，有就转为字符串</p>
<ul>
<li>1 + ‘1’   “1”</li>
<li>ture + ‘’ “true”</li>
<li>{} + ‘’   0 &#x2F;&#x2F;不懂，可能是对象转为0，空字符串再转为0</li>
</ul>
<h2 id="window-String"><a href="#window-String" class="headerlink" title="window.String()"></a>window.String()</h2><p>支持null undefined {},其它和toString()一致</p>
<h2 id="window-Boolean"><a href="#window-Boolean" class="headerlink" title="window.Boolean()"></a>window.Boolean()</h2><p>7种类型种，只有以下几种是false</p>
<ul>
<li>number NAN 0</li>
<li>null</li>
<li>undefined</li>
<li>Object 全为true </li>
<li>String ‘’</li>
</ul>
<p>快速转boolean <code>!!</code></p>
<h2 id="window-Number"><a href="#window-Number" class="headerlink" title="window.Number()"></a>window.Number()</h2><ul>
<li>boolean 0或1</li>
<li>null 0</li>
<li>undefined NaN</li>
<li>Object 调用valueOf，根据返回的值做决定，如果返回对象则为NaN</li>
<li>string 如果为空字符串返回0，如果为数字则一个个解析，有非数字就返回NaN，其它返回NaN，特殊的是参数为011会被认为是11</li>
</ul>
<h2 id="window-paparseInt"><a href="#window-paparseInt" class="headerlink" title="window.paparseInt()"></a>window.paparseInt()</h2><ul>
<li>参数为字符串，会从头开始寻找数字，直到遇到非数字为止，没有找到返回NaN</li>
<li>如果开头为空格，会省略空格</li>
<li>空字符返回NaN</li>
<li>所有其它类型返回NaN</li>
</ul>
<h2 id="window-parseFloat"><a href="#window-parseFloat" class="headerlink" title="window.parseFloat()"></a>window.parseFloat()</h2><p>和paparseInt()一致，只是不会取整</p>
<p><strong>小技巧</strong></p>
<ul>
<li>‘1’ - 0</li>
<li>+’1’</li>
<li>-()<br>都可以</li>
</ul>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>内存具有内存颗粒，一般每个内存颗粒有512Mb,多个内存颗粒组成内存容量</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>浏览器(chrome)启动后会占用大量内存，并且每个新开页面都独立分配内存，这些内存又会分配给HTML+css，js，网络，定时器这些，一般JS内存只能申请到100Mb</p>
<p>JS种内存分为两个区，一个区分为数据区，一个区分为代码区，我们这里只考虑数据区。</p>
<p>数据区又分为两个部分，一个为stack(栈)，一个为heap(堆)。<br>js第一步先看声明了哪些变量，进行提升，这样方便内存分配<br>基本类型存在stack中，而Object由于数据量大，经常添加更改属性，不方便内存分配，所以Object就新开个部分存对象，声明对象后就把内存地址给变量，用指针来找对象，堆里新增加A数据是用引用的方式存储的，也就可以方便的添加删除了。</p>
<p>数字64位，字符16位（2个字节）</p>
<p>测试一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="property">x</span> <span class="comment">//undefined</span></span><br><span class="line">b.<span class="property">x</span> <span class="comment">//[Object Object]</span></span><br></pre></td></tr></table></figure>
<p>这里的关键是a.x这里，解释器确定变量是从左到右，先确定赋给谁，再进入表达式，所以a.x还是之前的a</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如果一个对象没有被引用，就会被标记可以回收，在浏览器需要的时候就会被回收。但在IE6，在多个对象一级一级引用的时候，即使父对象不存在了，子对象却不会被回收,这会导致内存泄漏，因此需要这样做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span>&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//还要有所有的其它监听事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝&amp;浅拷贝"></a>深拷贝&amp;浅拷贝</h3><p>你变我也变就是浅拷贝<br>你变我不变就是深拷贝（所有的引用都被复制，和原对象及其子对象没有任何关联）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>IE6</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数</title>
    <url>/2018/05/22/js%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h1><p>函数在js中是以字符串的形式储存起来的（这会带来效率问题吧？）</p>
<p>在js中函数也是个对象，执行的代码块以字符串的形式保存在对象某个地方，使用f()就是调用这块代码。<br>传统的调用方式是使用<code>.call()</code>执行函数。</p>
<h1 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h1><h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><p>就是有名字的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具名函数的声明，初始化，赋值都会被变量提升至顶部</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>就是没有名字的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">a</span>() <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用此种方式，是以变量提升的方式，声明，初始化被提升至顶部，在声明前调用会错误。</p>
<h2 id="具名函数赋值"><a href="#具名函数赋值" class="headerlink" title="具名函数赋值"></a>具名函数赋值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式其实等于匿名函数，b不能被使用，但能在函数内部使用。(BUG js)</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;return x+y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> n =<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;return x+&#x27;</span>+n+<span class="string">&#x27;+y&#x27;</span>)</span><br><span class="line"><span class="title function_">z</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//返回4</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(x,y) =&gt; x+y</span><br></pre></td></tr></table></figure>
<p>这回直接返回 <code>x+y</code>,如果参数只有一个，可以省略前面的括号，后面只有一个个表达式可以省略后面的大括号，箭头函数总是匿名函数</p>
<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="f-name"><a href="#f-name" class="headerlink" title="f.name"></a>f.name</h2><p>得到函数名<br>匿名函数会得到指向它的变量，具名函数赋值会得到具名函数的值……<br>如果使用<code>Function()</code>声明，总是返回<code>anonymlus</code>，表示匿名的</p>
<h2 id="f-call"><a href="#f-call" class="headerlink" title="f.call()"></a>f.call()</h2><p><code>f.call()</code>就是执行函数体<br>第一个参数为执行的对象，其余为函数的参数，这是js真正的调用方法，f()可以说只是一种语法糖</p>
<p>call()的第一个参数可以用this得到，后面的参数可以用arguments得到</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在普通模式，如果传入的是null或者undefined，则默认为Window<br>，如果开启严格模式，则不会自动转变，传入什么就是什么，严格模式可以使用<code>use strict</code>开启。</p>
<p>严格模式中，参数的类型转换不会发生，比如这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">f.<span class="title function_">call</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>本来1不是对象，但call需要第一个是对象，就会把1自动装箱成Number对象，使用’use strict’会禁用参数的自动装箱</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments是一个伪数组，虽然是数组的形式，但_proto_指向Object，不指向Array。<br>它储存着函数调用时所有的实参。</p>
<h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><p>函数调用过程是以栈的形式进行调用，先进后出，在我们递归调用时，尤其要注意栈空间的占用，否则可能溢出(stack Overflowd网站的名字,233)，如果递归时不会使用函数内的变量，会进行尾递归优化，不再存储函数内的变量，减少栈空间调用。</p>
<h3 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h3><p>函数内会构成一个新的作用域，多个函数的嵌套，构成了一棵作用域树</p>
<p>这里我们就需要区别几种声明变量的方式 </p>
<ul>
<li>不加关键字声明<br>  因为作用域是一棵树，找不到会向上找，直到找到window对象，如果window对象也不具有该值，就认为是为window设置键值对，这就创建了全局变量</li>
<li>var 声明<br>  var 声明会被提升至该作用域顶部，并在顶部初始化为undefined</li>
<li>let<br>  let声明同样会被提升至顶部，但初始化和赋值只会在进入let所在区块进行，未在所在区块的使用都被认为是非法的</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js数组</title>
    <url>/2018/05/20/js%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>js中window拥有非标准库和标准库，标准库中有Object及相关api,Sting,Boolean等，我们可以先试试这些函数&#x2F;对象</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h2><p>Object()会根据传入的参数返回不同的值</p>
<ul>
<li>基本类型，所有可以被包装的的基本类型都会被包装成包装类型<br>传入空对象,undefined,或者不传，返回null，传入非空对象返回原对象</li>
</ul>
<p>使用<code>new Array()</code>方式和构造函数没有区别</p>
<p><strong>这里我们可以总结一下</strong><br>如果是基本类型的函数&#x2F;对象，不加<code>new</code>和加<code>new</code>是不相同的<br>如果是对象，比如<code>Function</code> 我们这里的<code>Array</code>，这两者是等同的</p>
<h3 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a>Function构造函数</h3><p><code>let a = new Function(&#39;a&#39;,&#39;b&#39;,&#39;a+b&#39;)</code><br>参数可以无到任意，但至少有函数体</p>
<p><code>function</code>是个关键字，<code>Function</code>是个全局对象</p>
<p>函数有几种声明方式，声明出来的结果也不同<br>具名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数方法体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a+b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p><code>.call()</code><br><code>.bind()</code><br><code>.apply()</code></p>
<h2 id="Number-Boolean"><a href="#Number-Boolean" class="headerlink" title="Number() Boolean()"></a>Number() Boolean()</h2><p> 转换为对应的基本类型</p>
<h1 id="Array是什么？"><a href="#Array是什么？" class="headerlink" title="Array是什么？"></a>Array是什么？</h1><p><code>Array</code>对象是用于构造数组的全局对象，属于<code>Object</code></p>
<p>我们一般声明Array采用的是<code>[gg, aga, aga]</code>，实际上这种方式等价于<code>new Array</code>,前者可以当作语法糖。</p>
<h1 id="具体怎么用？"><a href="#具体怎么用？" class="headerlink" title="具体怎么用？"></a>具体怎么用？</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Array()构造函数会根据传入的不同参数返回不同的数组</p>
<ol>
<li><p><code>let a = Array(1)</code><br> 当参数只有一个数字的情况，参数代表数组的长度，返回等于参数长度的数组，这个数组其它元素都没有被声明，包括<code>0 in a</code>，它返回undefined。</p>
<p> 请注意，传入NaN会报错</p>
</li>
<li><p><code>let a = Array(&#39;我就要看你要做什么&#39;)</code><br> 当参数为一个非数字，返回一个长度为1且<code>a[0]=</code>所给字符串数组</p>
</li>
<li><p><code>let a = Array(3,3)</code><br> 当传入参数大于等于2，按顺序填充新数组并返回</p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="string-prototype"><a href="#string-prototype" class="headerlink" title="string.prototype"></a>string.prototype</h3><ul>
<li><code>.trim()</code> 返回一个去掉两端空格的新字符串</li>
<li><code>.spli()</code> 返回一个分割后的新字符串</li>
</ul>
<h3 id="Array-prototype"><a href="#Array-prototype" class="headerlink" title="Array.prototype"></a>Array.prototype</h3><p><code>.push()</code> 推入一个(末尾)<br><code>.pop()</code> 弹出一个(末尾)<br><code>.shift()</code> 删除数组头部元素<br><code>.unshift</code> 添加到头部<br><code>.join()</code> 把数组连接起来，并加上分隔符形成字符串返回，默认为<code>,</code>号<br><code>.concat(b)</code> 把数组连接起来返回新数组，也可以和空数组合并，等同于数组复制<br><code>.forEach()</code> 遍历数组，详见后文<br><code>.map()</code> 遍历数组，详见后文</p>
<p>Array的关键是继承了<code>Array.prototype</code></p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>如果是数组，可以使用<code>for(let i=0;i&lt;obj.length;i++&gt;)</code><br>如果不关心是否是数组，可以使用<code>for (let i in obj)</code>遍历所有键值<br>还可以使用<code>forEach()</code>，<code>.map()</code>遍历</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><code>forEach()</code></h4><p><code>forEcah</code>接受一个函数，这个函数有是三个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">currentValue,index,array</span>)&#123;</span><br><span class="line">    <span class="comment">//当前值，索引，数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title=".map()"></a><code>.map()</code></h4><p>和forEach差不多，不过对value的改变会以新数组的形式返回</p>
<h4 id="a-filter"><a href="#a-filter" class="headerlink" title="a.filter()"></a><code>a.filter()</code></h4><p>和map差不过，就是筛选，ture要，false不要</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title=".reduce()"></a><code>.reduce()</code></h4><p>每次会把函数的返回值作为下一次的返回值，还可以指定初始索引，最后返回最后执行后的函数返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">reduce</span>( <span class="keyword">function</span> (<span class="params">sum,n</span>)&#123;<span class="keyword">return</span> sum+=n&#125;,<span class="number">0</span>) <span class="comment">//返回6，0为初始索引</span></span><br></pre></td></tr></table></figure>

<h3 id="a-sort"><a href="#a-sort" class="headerlink" title="a.sort()"></a><code>a.sort()</code></h3><p>一般排序算法使用的都是快排<br>注意：js中默认排序是按照Unicode的码点进行排序，非常傻逼。</p>
<p>幸运的是，sort接受一个可选参数，支持自定义的比较算法。<br>函数必须是这种形式的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">a,b</span>)&#123;</span><br><span class="line">    f (a &lt; b ) &#123;<span class="comment">// 按某种排序标准进行比较, a 小于 b</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//小于0 a排前面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//大于0 b排前面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//相等不变，但实现不一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此比较数字大小的话，可以这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b&#125;) <span class="comment">// 最小的在最前</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a,b</span>)&#123;<span class="keyword">return</span> b-a&#125;) <span class="comment">// 最大的在最前</span></span><br></pre></td></tr></table></figure>
<p>其中forEach使用<code>this</code>表示调用者，可以使用<code>this</code>来获取调用者的属性</p>
<h3 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h3><p>如果像一个数组，且<code>_proto_</code>不等于<code>Araay.prototype</code>,那这就是一个伪数组<br>在js目前遇到的伪数组就是<code>arguments</code>这个表示传给函数的参数</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>less入门</title>
    <url>/2018/07/26/less%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><ul>
<li><p>颜色</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@bgColor:</span> <span class="number">#34c5c5</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">@bgColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>url</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@url:</span> <span class="string">&quot;./xxx/&quot;</span></span><br><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line">    <span class="attribute">background</span>: url(<span class="string">&quot;@&#123;url&#125;dog.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后url就会被合成，方便改路径</p>
</li>
<li><p>声明值</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@background:</span> &#123;<span class="attribute">background</span>:red;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="variable">@background</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h1><p>可以把选择器写在括号中，表示下一级选择器</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析完毕后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;表示当前选择器的父选择器</p>
<h1 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h1><p>可以在css中使用其它选择器里定义的属性，比如</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bordered</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: dotted <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">2px</span> black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#menu</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#111</span>;</span><br><span class="line">  <span class="selector-class">.bordered</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的javascript》读书笔记 一：作用域和闭包</title>
    <url>/2020/08/16/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>其实之前已经把《你不知道的 JavaScript》上卷读完了，但是其实只是囫囵吞枣，看的很初略，没有自己的思考，再到今天其实有点忘得差不多，这次重新精读一次，记录下自己的思考。</p>
<h2 id="JS-是如何处理变量声明的？"><a href="#JS-是如何处理变量声明的？" class="headerlink" title="JS 是如何处理变量声明的？"></a>JS 是如何处理变量声明的？</h2><p>js 入门会遇见很多很神奇的点，很著名的就是变量提升</p>
<ul>
<li>var 变量提升<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li>函数声明提升<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">hosting</span>(); <span class="comment">// &#x27;function hosting&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hosting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function hosting&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hosting = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
在这里使用<code>var</code>声明的变量标志符被提升了，甚至可以在声明前调用它，函数也是同理，并且函数声明的值也被一同提升了。</li>
</ul>
<p>上面的代码可以翻译成类似的同理代码:</p>
<ul>
<li>var 变量提升<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li>函数声明提升<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hosting = <span class="keyword">function</span> <span class="title function_">hosting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function hosting&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">hosting</span>(); <span class="comment">// &#x27;function hosting&#x27;</span></span><br><span class="line">hosting = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
了解了之后，其实我们还会冒出更多的疑问，为什么会这样？为什么这么设计？<br>《你不知道的 JavaScript》正好解答了这一部分。</li>
</ul>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>在了解 JS 如何变量声明前，我们还需要一些预先的知识，了解代码是如何编译的。编译器前端大致有下面几个流程：</p>
<ul>
<li><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4></li>
</ul>
<p>词法分析就是将字符串分解成适合理解的词法单元，例如 <code>23 + 10 * 2</code> 就应该是 5 个词法单元<code>23</code> <code>+</code> <code>10</code> <code>*</code> <code>2</code>，词法分析有两种方式，一种是基于状态机的，另一种是基于正则的，两者是等同的。</p>
<ul>
<li><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4></li>
</ul>
<p>语法分析实际上做的就是将连续的词法单元分析成一个个语意块，就像将一串连续的汉字理解一个个词语一样，最终输出成为一颗抽象语法树，上面词法单元分析的结果应该是这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ExpressionStatement&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expression&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BinaryExpression&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Literal&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;operator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;+&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BinaryExpression&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Literal&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;operator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Literal&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>整个语法结构是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpressionStatement =</span><br><span class="line"> BinaryExpression  =</span><br><span class="line"> Literal(23) + BinaryExpression =</span><br><span class="line"> Literal(23) + (Literal(10) * Literal(2))</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4></li>
</ul>
<p>在通过语法分析后，事实上代码已经可以转换成机器代码跑起来了， 但是为了避免一些语义错误和代码优化，就可以在生成抽象语法树后再进行一些处理。<br>比如前端打包中<code>Tree shaking</code>实际上就是在这个阶段对代码进行静态分析，移除不必要的代码。</p>
<p>了解了代码的编译过程，我们就可以从编译原理角度来理解编译器做的这些小动作 了。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域的定义在书中定义的很明白</p>
<blockquote>
<p>作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。<br>它决定了变量如何被查找及访问。</p>
</blockquote>
<h4 id="为什么要变量提升？"><a href="#为什么要变量提升？" class="headerlink" title="为什么要变量提升？"></a>为什么要变量提升？</h4><p>这是一个常见的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>声明语义应该是这个样子的：</p>
<blockquote>
<p>为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量。</p>
</blockquote>
<p>如果重复声明，在 C、Java 中，会直接报错，也是符合常理的做法。</p>
<p>然而在 js 中，却不是这样。首先编译器会预先扫描所有的变量声明，在首次声明时会将变量添加进作用域，并将变量默认值置为<code>undefined</code>,如果遇到再次声明，则忽略它。函数声明与变量基本一致，但是在编译时就会确定函数的值。</p>
<p>很对人都很奇怪为什么 js 会如此设计，为什么这样进行编译？这样做有什么好处吗？<br>实际上 js 语言的创造者 BrendanEich 其实在<a href="https://twitter.com/BrendanEich/status/33403701100154880">twitter</a>说过变量提升的原因。Quora 上<a href="https://www.quora.com/Why-does-JavaScript-hoist-variables">一篇文章</a>也说的很清楚。</p>
<blockquote>
<p>yes, function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order</p>
</blockquote>
<blockquote>
<p>A bit more history: `var` hoisting was an implementation artifact. `function` hoisting was better motivated</p>
</blockquote>
<p>大意就是 BrendanEich 在设计 js 语法时，十分讨厌 LISP 命令式的、自上而下的函数书写风格，如果没有函数声明提升，我们的代码将是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingB</span>(<span class="params"></span>)&#123;</span><br><span class="line">  doXXX...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingA</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">doSomethingB</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">doSomethingA</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读代码时，通常是自上而下的，然而如果没有变量提升，就不得不自上而下声明函数，自上阅读代码。因此 js 编译器会预先做变量提升，类似于类似于 C\C++代码中头文件的作用。而与此同时，作为函数声明提升的副作用，变量声明也被提升了，也就成为了现在的局面。</p>
<h4 id="函数作用域与词法作用域"><a href="#函数作用域与词法作用域" class="headerlink" title="函数作用域与词法作用域"></a>函数作用域与词法作用域</h4><p>在 ES6 之前，仅有全局作用域和函数作用域，这在某些情况下就会造成一些问题，这也在一些经典面试题中出现过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log123</span>(); <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>

<p>这里期望输出行为应该在 1s、2s、3s 时分别输出 1、2、3<br>而实际输出是在 1s、2s、3s 时都输出 4。</p>
<p>在 ES6 中，解决这个办法很简单，将<code>var</code>变成<code>let</code>即可，<br>在 ES6 前有两种解决办法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种 参数传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function">(<span class="params">count</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count + <span class="number">1</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      i * <span class="number">1000</span>,</span><br><span class="line">      i</span><br><span class="line">    ); <span class="comment">//  注意这里</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 立即执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> j = i;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j + <span class="number">1</span>);</span><br><span class="line">      &#125;, i * <span class="number">1000</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果初学者的话，可能看到这一大串代码有点手足无措，因为这里确实设计到了 JS 大量的核心特性，我们可以从头开始一点一点看下去</p>
<p>在第一个未改进的版本，我们首先在全局作用域中声明了函数<code>log123</code>函数，编译器预扫描了函数声明，并和宿主环境提供的 api 一起构建了全局作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>在构建完全局作用域后，代码就开始执行了，值得注意的是，js 不会预先编译所有的代码，函数会在执行时编译并缓存编译结果，以达到更快的执行速度。<br>在代码执行到<code>log123()</code>时，编译器会拿到函数的内容，开始编译并构建执行环境。<br>编译器会预先扫描函数体内所有的声明，其中包括形参。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>整个过程中，函数作用域被押入栈中，在查询变量时，会按照入栈顺序从最近到最晚开始查询，理所当然的，全局作用域是最后被查询的作用域。</p>
<p>接下来函数继续执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//  i被置为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//  创建函数表达式 将函数表达式传入setTimeout函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里又创建了一个新的函数表达式，这个函数将会在定时器结束后被调用<br>在这里，词法作用域的特殊性就显现出来了，词法作用域在书中是这样定义的</p>
<blockquote>
<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</p>
</blockquote>
<p>在这里，由于函数表达式是在<code>log123</code>函数内声明的，按照词法作用域的解析规则，函数表达式的内部作用域是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script:[ ]</span><br><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>函数表达式内部并没有变量 i，按照作用域链查找规则，<code>console.log(i)</code>中使用的就是<code>log123()</code>中的 i<br>这里其实就是所说的闭包</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p>闭包几乎在 js 中随处可见，也并没有什么特殊，早期的 js 利用闭包来避免一些私有方法暴露，但在模块化的今天已经越来愈少。更多的时候，我们在写代码的时候无意就创见了闭包，比如一个事件监听函数，使用 React Hooks。</p>
<p>到了此时，我们终于可以总结一下输出和预期不一致的原因了。</p>
<ol>
<li>我们创建了一个函数作用域</li>
<li>在函数作用域中声明了<code>i</code></li>
<li>我们创建了一个函数表达式，用于为定时器回调，函数表达式继承了父级函数作用域</li>
<li>循环结束，<code>i</code>被置为 4</li>
<li>定时器执行回调，执行<code>console.log(i)</code>时，在父级作用域中查找到了<code>i</code>，i 的值为 4</li>
</ol>
<p>在 ES6 之前，解决办法就是上述两种，第一种通过函数传参数的方式，传递了<code>i</code>当时的字面量<code>1</code>,<code>2</code>,<code>3</code>，<code>i</code>指向的是函数表达式作用域的实参，输出是预期的结果。<br>第二种方式，是在每一次循环时，都为函数表达式创建了新的父级函数作用域。<br>作用域链会像这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script:[ ]</span><br><span class="line">script:[j]</span><br><span class="line">script:[i]</span><br><span class="line">global:[log123, ...otherGlobalApi]</span><br></pre></td></tr></table></figure>

<p>函数表达式访问的是临时的父级作用域<code>j</code>的值，也如预期结果</p>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>所幸我们很快在 ES6 中拥有了块级作用域，用 let 实现上面的效果很简单，只需要把 var 更换成 let</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="number">1</span>); <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只把 let 理解成仅创建块级作用域的话，实际上无法解释输出的结果，按照作用域链查找规则，log 输出的还是父级块级作用域的 i</p>
<p>实际上，<code>let</code>在循环语句块中，有特别的处理，let 会在循环语句中的每一次循环创建单独的块级作用域，上面的代码类似于这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log123</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> _i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = _i; <span class="comment">// 创建单独的作用域</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="number">1</span>); <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这里的处理方式基本类似于上面第二种办法。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上大概就是读完《你不知道的 JavaScript》 作用域和闭包 部分的一些想法和笔记，通过解答 js 的经典问题 变量提升来做一些回顾，如果需要再深入的话，可能还是需要深入 ECMAScript 标准，但是作为开发的话，目前的知识已经足够了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的Javascript</tag>
        <tag>读书笔记</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的javascript》读书笔记二：this与原型</title>
    <url>/2020/09/14/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9Athis%E4%B8%8E%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>这部分其实应该叫做吐槽合集，作者在这部分大量吐槽了把 js 中原型理解成类的做法。现在的前端社区中，如 React，Vue 也是更少利用类的一些特性，而是使用了混入，类似于该书中讲的行为委托模式；而在 React Hooks 和 Vue composition api 中，则更激进的几乎完全去掉了 Class 风格的代码。</p>
<p>读了这部分，就能了解社区为什么不太喜欢 Class 风格的代码。</p>
<h2 id="从-this-讲起"><a href="#从-this-讲起" class="headerlink" title="从 this 讲起"></a>从 this 讲起</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 也是 js 中新手很头疼的问题了，各种归纳总结 this 的方法随处可见。这里也贴下书中对 this 的定义</p>
<blockquote>
<p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<br>this 就是这个记录的一个属性，会在函数执行的过程中用到。</p>
</blockquote>
<p>借助 this 我们可以很方便的来传递上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式绑定this</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">speak</span>(); <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Boo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Boo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定this</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">speak</span>.<span class="title function_">call</span>(<span class="title class_">Boo</span>); <span class="comment">// Boo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统传递上下文</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">speak</span>(<span class="title class_">Foo</span>); <span class="comment">// Foo</span></span><br><span class="line"><span class="title function_">speak</span>(<span class="title class_">Boo</span>); <span class="comment">// Boo</span></span><br></pre></td></tr></table></figure>

<p>书里归纳了五种 this 的绑定方式，就以上面的例子为例</p>
<ol>
<li>默认绑定 speak() this &#x3D; window</li>
<li>隐式绑定 Foo.speak() this &#x3D; Foo</li>
<li>显式绑定 Foo.speak.call(Boo) this &#x3D; Boo</li>
<li>硬绑定 bind Foo.speak.bind(Boo) this &#x3D; Boo</li>
<li>new 绑定 new Foo.speak this &#x3D; {}（es5）</li>
</ol>
<p>当然，其实也可以用符合直觉的方式来理解，使用函数是手动传入 this，而在其它情况下，则是调用方，也就是指执行上下文，如果没有，则认为是 window。<br>可以看下一些经典的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="attr">logThis</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">logThis</span>(); <span class="comment">// &#123; name: &#x27;foo&#x27;, logThis: Function  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anthorLogThis = foo.<span class="property">logThis</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">anthorLogThis</span>(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">returnLogFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">returnLogFunction</span>()(); <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">(<span class="literal">false</span> || foo.<span class="property">logThis</span>)(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>这里可能最让人疑惑的可能是最后一个例子，他们看起来是具有执行上下文的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="literal">false</span> || foo.<span class="property">logThis</span>)(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>这里要注意在使用了括号运算符后，返回的是函数的值，而返回的并不是执行上下文和函数的整体，也就自然变为了默认的 Window。</p>
<p>如果想具体如何判断 this，可以参考<a href="https://github.com/mqyqingfeng/Blog/issues/7" title="JavaScript深入之从ECMAScript规范解读this">这篇博客</a><br>这篇博客从规范实现上面阐述如果判断 this，当然，绝大多数情况都可以以符合直觉的方式，判断它的调用方是谁就好了。</p>
<h3 id="this-与属性描述符"><a href="#this-与属性描述符" class="headerlink" title="this 与属性描述符"></a>this 与属性描述符</h3><p>属性描述符是 ES5 时出现的，可以给对象设置数据描述符和存取描述符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与数据描述符的示例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">37</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.<span class="property">a</span>; <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set!&quot;</span>);</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在对象属性访问中，也有类似的[[GET]]与[[PUT]]。<br>默认的内置[[GET]]操作会首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值，如果没有找到，则会遍历原型链上的属性，如果没有则会返回 undefined，<br>而默认的[[PUT]]方法则由于原型链的存在复杂很多</p>
<p>在对象自身存在属性时，[[PUT]]方法很简单，如果有定义的 setter 就调用 setter，如果没有，就检查属性描述中定义是否可写，如果可写就写入。</p>
<p>而如果对象属性不存在，则会涉及到复杂的原型上属性的处理了。</p>
<ol>
<li>如果原型上存在对应属性，并且是数据描述符，并且 writable 为 true，那么会直接在当前对象上添加对应的属性和值。</li>
<li>如果原型上存在对应属性，并且是数据描述符，如果 writable 为 flase 那么这次赋值默认会失败，严格模式下则会报错。</li>
<li>如果原型上存在对应属性，并且是存取描述符，则会调用对应的 setter</li>
</ol>
<p>第二点类似于 java 中的 final 标识符，表示不可重写，然而可能大多数场景开发者会认为这是一个 BUG，因为结果出人意料。</p>
<h2 id="类与原型"><a href="#类与原型" class="headerlink" title="类与原型"></a>类与原型</h2><p>在很多基于类的语言中，类的继承行为都是复制的，对类的重新定义和运行时改写是不允许的，非常安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 js 中，类似的概念是以原型为基础的，在使用 new 关键字时，产生的对象会自动指向函数的[[prototype]]属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;st&quot;</span>, <span class="number">34</span>);</span><br><span class="line">person.<span class="property">sayName</span>; <span class="comment">// st</span></span><br></pre></td></tr></table></figure>

<p>指的注意的是，由于 js 的动态性，原型也是可以更改的，并且所有属性是共享的，基于原型的方法会很脆弱</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;st&quot;</span>, <span class="number">34</span>);</span><br><span class="line">person.<span class="property">sayName</span>; <span class="comment">// st</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;new&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="property">sayName</span>; <span class="comment">// stnew</span></span><br></pre></td></tr></table></figure>

<p>由于在 es6 之前，js 没有提供相关类的写法，就有各种对继承的实现，使用最多的就是寄身组合式继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1);</span><br></pre></td></tr></table></figure>

<p>而在 ES6 中，继承只需要简单的 extnds 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;kk&quot;</span>, <span class="number">18</span>);</span><br><span class="line">child.<span class="title function_">getName</span>(); <span class="comment">// kk 1</span></span><br></pre></td></tr></table></figure>

<p>指的注意的是，super 是静态绑定的，super 在声明时就已经确定了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;P.foo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c1.<span class="title function_">foo</span>(); <span class="comment">// P.foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> D = &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;D.foo&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> E = &#123;</span><br><span class="line">  <span class="attr">foo</span>: C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(E, D);</span><br><span class="line">E.<span class="title function_">foo</span>(); <span class="comment">// P.foo</span></span><br></pre></td></tr></table></figure>

<p>实际上，在 Vue 和 React 的代码中，继承的代码很少被使用，更多倾向于使用混入来复用代码，比如 Vue 中的 混入代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mix properties into target object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">to: <span class="built_in">Object</span>, _from: ?<span class="built_in">Object</span></span>): <span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</span><br><span class="line">    to[key] = _from[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混入可以更方便的组合多种对象，而不必实现复杂的继承关系。</p>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>实际上社区也有很多基于类关系的框架和代码，比如 angular、nest,实际上它们工作、维护的相当好，并没有太过不堪，选择基于类、原型、函数式更多是一种编程风格的选择，都有或多或少的优点缺点。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的Javascript</tag>
        <tag>读书笔记</tag>
        <tag>this</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么在Ts中Object.keys总是返回字符串数组?</title>
    <url>/2022/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Ts%E4%B8%ADObject-Keys%E6%80%BB%E6%98%AF%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="一个常见的问题"><a href="#一个常见的问题" class="headerlink" title="一个常见的问题"></a>一个常见的问题</h3><p>在很多情况下，我们需要遍历一个对象的所有Key，就像这样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> marks = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">keys</span>(marks).<span class="title function_">map</span>(<span class="function"><span class="params">key</span>=&gt;</span>marks[key]) </span><br><span class="line"><span class="comment">// error: 元素隐式具有 &quot;any&quot; 类型，因为类型为 &quot;string&quot; 的表达式不能用于索引类型 &quot;&#123; 1: string; 2: string; &#125;&quot;。在类型 &quot;&#123; 1: string; 2: string; &#125;&quot; 上找不到具有类型为 &quot;string&quot; 的参数的索引签名。</span></span><br></pre></td></tr></table></figure>

<p>Ts会立即报错，因为Object.keys的类型是这样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectConstructor</span> &#123;</span><br><span class="line">	<span class="title function_">keys</span>(<span class="attr">o</span>: <span class="built_in">object</span>): <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种时候我们往往需要对key进行断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> marks = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">keys</span>(marks).<span class="title function_">map</span>(<span class="function"><span class="params">key</span>=&gt;</span>marks[key <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;keyof <span class="keyword">typeof</span> marks&#125;</span>`</span>])</span><br><span class="line"><span class="comment">// no error</span></span><br></pre></td></tr></table></figure>

<p>这段代码只是简单的对类型的断言，更准确的断言实际还应该排除<code>symbol</code>类型，因为对象的键也可能是symbol，但是<code>Object.keys</code>只会遍历对象的可枚举的字符串属性。</p>
<p>同时这里也将数字转换为字符串，因为对象的键除了<code>symbol</code>，都会被转换为字符串。</p>
<h3 id="为什么Ts没有处理？"><a href="#为什么Ts没有处理？" class="headerlink" title="为什么Ts没有处理？"></a>为什么Ts没有处理？</h3><p>在GitHub上事实上有很多讨论，其中一个<a href="https://github.com/microsoft/TypeScript/pull/12253">Pull request</a>的讨论下有详细的回答。</p>
<p>Ts作者说明了使用<code>key of T</code>仅仅只在类型系统中工作，在运行时，类型会被抹除掉，而在实际场景，往往对象会拥有更多的key，这时类型是不安全的。</p>
<p>特别的,在<code>fon in</code>循环中，如果被推断的对象是一个泛型参数，Ts中将其key推断为<code>  Extract&lt;keyof T, string&gt;</code>,而在其它情况下，总是会被推断为<code>string</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testCases = &lt;T&gt;<span class="function">(<span class="params"><span class="built_in">object</span>: T</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">object</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(<span class="built_in">object</span>, key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="built_in">object</span>[key]; <span class="comment">// key: Extract&lt;keyof T, string&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实还是不太明白为什么使用泛型参数可以，而使用其他类型不行，可能与泛型参数是根据输入的类型自动推断有关。</p>
<h3 id="其他的相关函数"><a href="#其他的相关函数" class="headerlink" title="其他的相关函数"></a>其他的相关函数</h3><p>其他的对象遍历函数基本与<code>Object.keys</code>表现一致，只是可以通过泛型传递值的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectConstructor</span> &#123;</span><br><span class="line">	values&lt;T&gt;(<span class="attr">o</span>: &#123; [<span class="attr">s</span>: <span class="built_in">string</span>]: T &#125; | <span class="title class_">ArrayLike</span>&lt;T&gt;): T[];</span><br><span class="line">    <span class="title function_">values</span>(<span class="attr">o</span>: &#123;&#125;): <span class="built_in">any</span>[];</span><br><span class="line">    entries&lt;T&gt;(<span class="attr">o</span>: &#123; [<span class="attr">s</span>: <span class="built_in">string</span>]: T &#125; | <span class="title class_">ArrayLike</span>&lt;T&gt;): [<span class="built_in">string</span>, T][];</span><br><span class="line">    <span class="title function_">entries</span>(<span class="attr">o</span>: &#123;&#125;): [<span class="built_in">string</span>, <span class="built_in">any</span>][];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这点实际上是由于Ts类型仅存在编译时，和运行时的类型是无关的，所以在这种依赖于运行时的函数时，无法保证类型安全，因此给了一个最宽泛的<code>string</code>并让开发者自己断言。</p>
<p>不过在问题的讨论下，也有举例<code>Readonly</code>的评论，因为<code>Readonly</code>实际也仅存在编译类型检查时，运行时也仍然是可写的。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>类型推断</tag>
      </tags>
  </entry>
  <entry>
    <title>从callback到async函数-js异步编程的演变</title>
    <url>/2019/10/06/%E4%BB%8Ecallback%E5%88%B0async%E5%87%BD%E6%95%B0-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实之前只知道 Promise 很方便，大家也都是这么用的，generate 函数也一知半解，直到最近看了阮一峰的<a href="http://es6.ruanyifeng.com/#docs/generator-async">ES6 入门</a>和在知乎看的一篇工业聚的<a href="https://zhuanlan.zhihu.com/p/83965949" title="100 行代码实现 Promises/A+ 规范">文章</a>,才了解整个的发展历程，我也推荐你去看看他们的文章。</p>
<h2 id="js-异步编程模型"><a href="#js-异步编程模型" class="headerlink" title="js 异步编程模型"></a>js 异步编程模型</h2><p>js 作为一门浏览器的脚本语言，出生的时候就希望它尽可能的简单，易用，即使是非专业人员也能迅速掌握，而且 js 最初的应用场景并不复杂，所以单线程的 js 就确定了下来。<br>虽然 js 是单线程的，但浏览器却不是，对于很多耗时过长的任务，比如发起 ajax 请求，设置定时器，会由浏览器来做，js 只需要注册回调函数，声明浏览器完成异步后需要要做什么就可以了，js 只要有异步的地方，都有回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/cccc&quot;</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="title class_">XMLHttpRequest</span>.<span class="property">DONE</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h2 id="原始回调函数"><a href="#原始回调函数" class="headerlink" title="原始回调函数"></a>原始回调函数</h2><p>最早的回调函数方式就是直接在参数中传递一个回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>执行 setTimeout 后，这个计时任务会交由其它线程处理以避免阻塞 js 主线程,例如在浏览器会交由一个单独的计时线程处理；在时间超时后，浏览器会向 js 任务队列中插入新的任务，而 js 主线程在在同步任务完成后会不断检测队列中是否有新任务，并执行，此时这个回调函数也就被执行了。</p>
<p>回调函数的一大缺点就是在大量异步任务时，会嵌套下去，代码会逐渐横向发展，也即回调地狱。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stepBystep</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2000 delay&quot;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3000 delay&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4000 delay&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，Promise 就诞生了</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 语法可以将异步回调写成链式调用的模样，看着更清晰更直观，错误捕获等也有更好的体验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeoutPromise</span>(<span class="params">time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">res</span>(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stepBystepPromise</span>(<span class="params"></span>) &#123;</span><br><span class="line">  setTimeoutPromise(<span class="number">1000</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3000 delay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> setTimeoutPromise(<span class="number">4000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4000 delay&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候代码就是竖向展开的，错误捕获也很方便，<code>.catch()</code>就好了。<br>虽然 Promise 封装的回调函数已经很方便了，但是如果还想进一步呢？</p>
<h2 id="generate-函数"><a href="#generate-函数" class="headerlink" title="generate 函数"></a>generate 函数</h2><p>generate 函数提供了<code>yield</code>关键字，可以在函数中断执行，直到调用<code>.next()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;log:&quot;</span> + a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;log:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">generate</span>();</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 5,done: flase&#125;</span></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">8</span>); <span class="comment">// log:8 &#123;value: 6,done: flase&#125;</span></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">9</span>); <span class="comment">// log:9 &#123;value: undefined,done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>用这个方法，我们就可以尝试者用 generate 函数执行异步操作,在此之前我们首先需要把带有 callback 函数写成 Thunk 函数或者 Promise 的风格</p>
<h3 id="什么是-Thunk-函数"><a href="#什么是-Thunk-函数" class="headerlink" title="什么是 Thunk 函数"></a>什么是 Thunk 函数</h3><p>Thunk 函数就是将带有回调函数的多参数函数转变成只有一个回调函数的单参数函数，就像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeOutThunk</span>(<span class="params">time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是为了方便使用 generate 函数来控制异步流程，下面就是一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeOutThunk</span>(<span class="params">time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">3000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">4000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">generate</span>();</span><br><span class="line"><span class="keyword">let</span> &#123; value &#125; = gen.<span class="title function_">next</span>(); <span class="comment">// &#123;value: [[callbackFunction]] , done: flase&#125;</span></span><br><span class="line"><span class="title function_">value</span>(<span class="function">() =&gt;</span> gen.<span class="title function_">next</span>(<span class="number">123</span>)); <span class="comment">//123 &#123;value: [[callbackFunction]] , done: flase&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里<code>setTimeOutThunk()</code>已经变成单参数版本的函数,我们在调用<code>.next()</code>后，返回只具有回调函数参数的函数，这里其实主要是为了方便传参，如果另有约定不使用 Thunk 函数转化也可以。</p>
<p>在回调函数中,我们让回调函数调用下一个<code>.next()</code>,就可以让这个异步函数像同步函数一样执行了完整版本见下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeOutThunk</span>(<span class="params">time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="built_in">setTimeout</span>(callback, time, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">3000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">  val = <span class="keyword">yield</span> <span class="title function_">setTimeOutThunk</span>(<span class="number">4000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; value, done &#125; = gen.<span class="title function_">next</span>(...args);</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">run</span>(gen, ...args));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">value</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">run</span>(gen, ...args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(<span class="title function_">gen</span>());</span><br></pre></td></tr></table></figure>

<p>这里也支持 Promise<br>实质上这里已经完全将异步回调写成了同步代码，除了需要手动调用一下<code>run()</code>方法。</p>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>async 函数其实就是 generate 函数的语法糖版本，会自动运行，让我们不需要再额外调用<code>run()</code>方法，使用就很方便了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeoutPromise</span>(<span class="params">time</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">res</span>(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">stepBystepAwait</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">2000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">  time1 = <span class="keyword">await</span> setTimeoutPromise(<span class="number">4000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;time1&#125;</span> delay`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法上也与 generate 相似。</p>
<h2 id="一切皆回调"><a href="#一切皆回调" class="headerlink" title="一切皆回调"></a>一切皆回调</h2><p>无论是 Promise，还是 async 函数，其实仍然是利用回调函数处理异步，只是对如何处理异步函数做了一层封装，做了一些语法糖，让我们更方便的使用而已。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>async</tag>
        <tag>函数</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道面试题开始，重温类型转换</title>
    <url>/2022/03/09/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%87%8D%E6%B8%A9%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="一道题目"><a href="#一道题目" class="headerlink" title="一道题目"></a>一道题目</h3><p>最近准备回成都，开始了各种面试，这次面试官出了一道函数坷里化的题，题目如下:</p>
<blockquote>
<p>实现如下函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)       <span class="comment">// 1 </span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10 </span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>面试的时候这道题愣了一下，没有答出来，主要纠结了一下在不定参的时候，如果能够链式调用，那一定需要返回的是一个函数，按照题目要求，值需要既是一个函数，又是一个数字。</p>
<p>面试结束后仔细想了下，正好想到之前看《你不知道的JavaScript》中的对于对象类型的toPrimitive操作，面试后很快写了个Demo出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> previousArgs = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">...args</span>)=&gt;&#123;</span><br><span class="line">        previousArgs = previousArgs.<span class="title function_">concat</span>(args)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func.<span class="property">valueOf</span> = <span class="function">()=&gt;</span> previousArgs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, currentVal</span>)=&gt;</span> acc + currentVal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">func</span>(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>)(<span class="number">3</span>) + <span class="number">2</span>)  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>这里实际上关于使用<code>toString</code>以及<code>Symbol.toPrimitive</code>可以达成效果的，但具体原理有一些差别。</p>
<p>这里就借助这个机会回顾一下Js整个类型转换逻辑。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>总所周知，js作为一种弱类型语言，在需要的场景下，会进行隐式的类型转换，为此 <a href="https://tc39.es/ecma262/#sec-type-conversion">ECMA262  Type Conversion</a> 中规定了一系列类型转换的抽象方法，以及在各种运算符操作及函数中规定了如何去调用这些类型转换方法。</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p> <a href="https://tc39.es/ecma262/#sec-type-conversion">ECMA262  Type Conversion</a> 中规定了许多抽象方法，例如<code>ToString</code>、<code>ToNumber</code>、<code>toPrimitive</code>、<code>toBoolean</code>，其他的抽象方法也有很多，这里只简单介绍一下<code>toPrimitive</code>方法,步骤很清楚明白。</p>
<h5 id="ToPrimitive-input-preferredType"><a href="#ToPrimitive-input-preferredType" class="headerlink" title="ToPrimitive(input[,preferredType])"></a>ToPrimitive(input[,preferredType])</h5><p><code>toPrimitive</code>方法主要用于将对象转换为原始值，它接受两个参数，第一个参数为任意的合法值，第二个参数为倾向转换的类型(<code>string</code>或<code>number</code>)。</p>
<p>其执行逻辑如下</p>
<ol>
<li>如果input为对象，就：<ol>
<li>获取对象上定义的<code>@@Primitive</code>方法，也就是<code>Symbol.Primitive</code></li>
<li>如果<code>@@Primitive</code>方法不为<code>undefined</code>，就<ol>
<li>如果<code>preferredType</code> 未指定，就将<code>hint</code>默认设置为<code>&quot;default&quot;</code></li>
<li>否则,如果<code>preferredType</code>为<code>string</code>，就把<code>hint</code>设置为<code>&quot;string&quot;</code></li>
<li>否则，<code>preferredType</code>为<code>number</code>，就把<code>hint</code>设置为<code>&quot;number&quot;</code></li>
<li>将<code>result</code>设置为执行<code>@@Primitive(input, hint)</code>方法的结果</li>
<li>如果<code>result</code>的类型不为<code>object</code>，将<code>resule</code>作为结果返回</li>
<li>抛一个<code>TypeError</code>错误</li>
</ol>
</li>
<li>如果<code>preferredType</code> 未指定，就默认设置为<code>number</code></li>
<li>返回 调用<code> OrdinaryToPrimitive(input,preferredType)</code>方法的结果</li>
</ol>
</li>
<li>否则将input作为返回值</li>
</ol>
<h5 id="OrdinaryToPrimitive-O-hint"><a href="#OrdinaryToPrimitive-O-hint" class="headerlink" title="OrdinaryToPrimitive(O,hint)"></a>OrdinaryToPrimitive(O,hint)</h5><ol>
<li><p>如果<code>hint</code>为<code>&quot;string&quot;</code>,就</p>
<ol>
<li>将<code>mthodNames</code>设置为<code>&lt;&lt;&quot;toString&quot;,&quot;valueOf&quot;&gt;&gt;</code></li>
</ol>
</li>
<li><p>如果<code>hint</code>为<code>&quot;number&quot;</code>,就</p>
<ol>
<li>将<code>mthodNames</code>设置为<code>&lt;&lt;&quot;valueOf&quot;,&quot;toString&quot;&gt;&gt;</code></li>
</ol>
</li>
<li><p>按顺序取出<code>mthodNames</code>中的<code>name</code>，对于，每一项</p>
<ol>
<li>将<code>method</code>设置为对应对象上<code>name</code>的值</li>
<li>如果<code>method</code>可以被调用，就<ol>
<li>将<code>result</code>设置为执行<code>method()</code>方法的结果</li>
<li>如果<code>result</code>的类型不为<code>object</code>，将<code>resule</code>作为结果返回</li>
</ol>
</li>
</ol>
</li>
<li><p>抛一个<code>TypeError</code>错误</p>
</li>
</ol>
<p>这里就是<code>ToPrimitive</code>的逻辑了，整个逻辑就是优先调用<code>Symbol.Primitive</code>方法，如果不存在，再根据偏好顺序，执行<code>valueOf</code>及<code>toString</code>并作为结果返回。</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>在上面我们大致讲了类型转换中，将对象转为原始值的<code>ToPrimitive</code>方法，它被调用的一个典型案例就是使用<code>+</code>运算符，也就是本文的例子。在<a href="https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator">ECMA262  ApplyStringOrNumericBinaryOperator </a>中，规定了<code>+</code>运算符的行为。</p>
<h5 id="ApplyStringOrNumericBinaryOperator-lval-opText-rval"><a href="#ApplyStringOrNumericBinaryOperator-lval-opText-rval" class="headerlink" title="ApplyStringOrNumericBinaryOperator( lval, opText, rval )"></a>ApplyStringOrNumericBinaryOperator( lval, opText, rval )</h5><p>对于字符串或数字的运算都被定义在这个方法下，这里简便起见，我们仅看类型转换的部分</p>
<ol>
<li>如果<code>opText</code>为<code>+</code> ，就<ol>
<li>将<code>lprim</code>设为 <code>ToPrimitive(lval)</code>执行的结果</li>
<li>将<code>rprim</code>设为<code>ToPrimitive(rval)</code>执行的结果</li>
<li>如果<code>lprim</code>或<code>rprim</code>的类型为<code>string</code>，就<ol>
<li>将<code>lstr</code>设为 <code>ToString(rprim)</code>执行的结果</li>
<li>将<code>rstr</code>设为 <code>ToString(rprim)</code>执行的结果</li>
<li>将<code>lstr</code>与<code>rstr</code>连接后返回的新字符串作为结果返回</li>
</ol>
</li>
<li>将<code>lval</code>设为 <code>lprim</code></li>
<li>将<code>rval</code>设为<code>rprim</code></li>
</ol>
</li>
<li>将<code>lnum</code>设为 <code>ToNumeric(lval)</code>执行的结果</li>
<li>将<code>rnum</code>设为 <code>ToNumeric(rval)</code>执行的结果</li>
<li>如果<code>lnum</code>与<code>rnum</code>的值不匹配，返回一个<code>TypeError </code>错误</li>
<li>执行定义的数学运算，相关逻辑省略</li>
</ol>
<h4 id="运行结果解析"><a href="#运行结果解析" class="headerlink" title="运行结果解析"></a>运行结果解析</h4><p>有了上面定义的运算符逻辑及对象转换逻辑，我们就能比较清晰的明白上面的例子在执行时，<code>valueOf</code>及<code>toString</code>，还有<code>Symbol.toPrimitive</code>的调用逻辑是什么，有什么区别。</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p>为了方便对比，我们写一个最小化的Demo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = &#123;</span><br><span class="line">    <span class="title function_">valueOf</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo + <span class="number">1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo + <span class="string">&#x27;1&#x27;</span>) <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里按照上述的流程，会执行以下的步骤</p>
<ol>
<li><code>demo + 1</code> , 执行<code>toPrimitive(demo)</code></li>
<li><code>toPrimitive(demo) </code>检查没有<code>@@Primitive</code>方法，并且没有指定<code>preferredType</code>，默认偏好类型设置为value。</li>
<li>按照偏好类型，首先获取<code>valueOf</code>方法，并执行</li>
<li>执行后，返回<code>3</code>，类型不为<code>object</code>，返回后续结果。</li>
<li>执行后续流程。</li>
</ol>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>实际上，重写<code>toString()</code>方法也能拿到一样的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = &#123;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo + <span class="number">1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo + <span class="string">&#x27;1&#x27;</span>) <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这种场景下，<code>toString()</code>和<code>valueOf</code>是近乎等同的。</p>
<h5 id="Symbol-toPrimitive-hint"><a href="#Symbol-toPrimitive-hint" class="headerlink" title="Symbol.toPrimitive(hint)"></a>Symbol.toPrimitive(hint)</h5><p><code>Symbol.toPrimitive</code>方法是在ES6中出现的，让js有了覆写对象转换为原始值这一行为的能力，入参<code>hint</code>会根据转换的偏向类型，传入<code>&#39;string&#39;</code>、<code>&#39;number&#39;</code> 、<code>&#39;default&#39;</code>,上面的例子也可以使用<code>Symbol.toPrimitive</code>达到一样的效果。</p>
<p><code>Symbol.toPrimitive</code>方法除会接受入参以外，如果返回值未返回原始值类型，就直接抛出<code>TypeError</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo +<span class="number">1</span> <span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>

<p>而对于<code>toString</code>和<code>valueOf</code>方法，由于有默认的<code>Object.prototype.toString</code>方法，总是会输出对应的对象描述。</p>
<p>如果没有<code>toString</code>和<code>valueOf</code>方法，也会抛出这个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) + <span class="number">1</span> <span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里实际上是第一次阅读规范文档去解决自己的疑惑，规范实际写的非常简洁明了，很多时候要是不明白js的一些行为，阅读规范文档是一个好的办法。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">MDN Symbol.toPrimitive</a><br><a href="https://tc39.es/ecma262/#sec-type-conversion">ECMA262 Type Conversion</a><br><a href="https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator">ECMA262 ApplyStringOrNumericBinaryOperator</a><br><a href="https://weread.qq.com/web/reader/f5d32510715c0190f5ddc42">《你不知道的JavaScript 中卷》强制类型转换</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Symbol.toPrimitive</tag>
        <tag>坷里化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub Actions 自动化部署博客</title>
    <url>/2022/02/10/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>最近重新准备写博客的时候，发现hexo已经更新了，支持以包的形式引用主题，按照文档指引重新配置了主题。之前博客构建使用的是hexo官网的Travis Ci，配置直接复制过去改改就好了，这次更新主题看到仓库上大大的GitHub Actions,手痒痒，就想试一下用GitHub Actions 进行自动构建。</p>
<h3 id="构建产物"><a href="#构建产物" class="headerlink" title="构建产物"></a>构建产物</h3><p>GitHub Actions的快速上手文档异常的贴心，而且还是以npm构建为例子，前端基本可以很快上手~</p>
<p>GitHub Actions 的构建任务有四个层级</p>
<ul>
<li>workflow： 工作流，整个运行过程</li>
<li>job： 任务，工作流可以包含一个或多个任务，每个任务都是独立的机器运行</li>
<li>step: 步骤。每一个任务可以执行一个或多个步骤，按顺序执行</li>
<li>action: 动作，每一个步骤可以运行一个或者多个命令</li>
</ul>
<p>其中job是分别在不同机器上并发执行的，也可以通过<code>needs</code>参数和条件判断决定执行先后顺序，不过目前我们不需要多个机器并发执行。</p>
<p>上面其实是一些概念，实际写一个简单的构建配置是十分简单的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># 指定在main分支push时触发构建</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="comment"># 允许手动点击触发构建</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># 任务名称</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="comment"># 运行环境为最新稳定版本的</span></span><br><span class="line">    <span class="comment"># ubuntu</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 拉取这次提交后的代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="comment"># 安装并设置node版本为14，并启用缓存 </span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">      <span class="comment"># 安装依赖并执行构建命令</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm ci</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>其中use类似于npm包，可以使用其他人预先写好的构建指令及脚本，通过with传递参数。</p>
<p>对于自行编写的构建命令，直接使用<code>run</code>即可，如果有多条命令，需要使用<code>|</code> 进行换行。</p>
<h3 id="发布到GitHub-Pages"><a href="#发布到GitHub-Pages" class="headerlink" title="发布到GitHub Pages"></a>发布到GitHub Pages</h3><p>hexo自带发布到Github Pages插件，在本地机器发布时，直接执行<code>hexo deploy</code>即可，但是在GitHub Actions上，默认仅有当前仓库的权限，并且没有设置Git用户名称和邮箱，会得到以下错误</p>
<p><img data-src="/2022/02/10/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/image-20220214212324285.png" alt="image-20220214212324285"></p>
<p>这是因为我们在远程的执行虚拟机上执行Git命令，Git并没有相关配置，同时显而易见的，也没有为仓库提交的权限。</p>
<h4 id="解决Git配置"><a href="#解决Git配置" class="headerlink" title="解决Git配置"></a>解决Git配置</h4><p>Git配置很好解决,直接在发布前添加两行配置命令即可,这里使用GitHub Actions的<a href="https://docs.github.com/en/actions/learn-github-actions/contexts">上下文变量</a>，访问触发构建的用户的用户名，并作为提交者。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span> <span class="string">to</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    git config --global user.email &quot;$&#123;&#123; github.actor &#125;&#125;@noreply.github-action.com&quot;</span></span><br><span class="line"><span class="string">    git config --global user.name &quot;$&#123;&#123; github.actor &#125;&#125;.github-action&quot;</span></span><br><span class="line"><span class="string">    npm run deploy</span></span><br></pre></td></tr></table></figure>



<h4 id="添加具有写入权限的Token"><a href="#添加具有写入权限的Token" class="headerlink" title="添加具有写入权限的Token"></a>添加具有写入权限的Token</h4><p>作为一个很常用的功能，社区自然早早帮忙造好了轮子了，这里直接使用<code>webfactory/ssh-agent@v0.5.4</code>即可，然后在本地创建一对秘钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>之后再把公钥上传到对应的目标发布仓库，这里需要注意构建写入权限，才能够进行提交操作。</p>
<p><img data-src="/2022/02/10/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/image-20220214222645055.png" alt="image-20220214222645055"></p>
<p>私钥需要上传到Gituhb Actions执行的仓库，操作类似，之后就可以顺利执行<code>hexo deploy</code></p>
<p><img data-src="/2022/02/10/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/image-20220214223118913.png" alt="image-20220214223118913"></p>
<p>这里发布使用的是hexo自带的Git发布插件，整个发布流程实际也可以通过GitHub Actions实现，后面可以再改改。</p>
<h3 id="发布到个人云服务器"><a href="#发布到个人云服务器" class="headerlink" title="发布到个人云服务器"></a>发布到个人云服务器</h3><p>为了方便国内访问，自己还有一个部署在国内的站点，希望在自动构建的时候，也直接发布到个人的云服务器上，搜索一下<code>deploy</code>关键字，直接就有相应的Actions了，这里直接用<code>easingthemes/ssh-deploy@main</code>，,填好参数，执行时通过<code>rsync</code>命令把文件同步到远程主机上。</p>
<p><img data-src="/2022/02/10/%E4%BD%BF%E7%94%A8Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/image-20220214225137217.png" alt="image-20220214225137217"></p>
<p>使用rsync的主要问题是GitHub Actions的主机在美国，远程同步的时间非常非常久，第一次同步耗时13m，以为是命令出了问题，强行结束了Actions任务，第二次同步依然执行了12m,直到第三次因为文件已同步了，执行时间才有显著的减慢。</p>
<h3 id="最终配置"><a href="#最终配置" class="headerlink" title="最终配置"></a>最终配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm ci</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">webfactory/ssh-agent@v0.5.4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ssh-private-key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span> <span class="string">to</span> <span class="string">github</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;$&#123;&#123; github.actor &#125;&#125;@noreply.github-action.com&quot;</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;$&#123;&#123; github.actor &#125;&#125;.github-action&quot;</span></span><br><span class="line"><span class="string">          npm run deploy</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span> <span class="string">to</span> <span class="string">server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@main</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">            <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_SSH_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">ARGS:</span> <span class="string">&quot;-rltgoDzvO --delete&quot;</span></span><br><span class="line">            <span class="attr">SOURCE:</span> <span class="string">&quot;public/&quot;</span></span><br><span class="line">            <span class="attr">REMOTE_PORT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">            <span class="attr">TARGET:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_TARGET</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这次使用GitHub Actions实际是自己第一次从零开始写构建流程，由于生态比较活跃，实际上各种想用的功能都有轮子，可以轻松实现自己的功能，比较大的缺点就是GitHub Actions是和GitHub强绑定的，并且提供的构建主机都在美国，连接速度比较慢，看文档也支持自托管的构建主机，有时间可以弄一个试试。</p>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub Actions</tag>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo+Github Pages给自己搭建一个博客</title>
    <url>/2018/03/22/%E4%BD%BF%E7%94%A8Hexo-Github-Pages%E7%BB%99%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于我专业原因，有大量软件都必须使用Windows,并且我的笔记本在安装Linux的过程中，总容易出现各种兼容问题，因此没有安装Windows&#x2F;Linux双系统，而在Windows上使用虚拟机也不是一个太棒的选择，最后使用了win10的Linux子系统，体验感觉还行，如果在Windows平台安装失败的同学可以参照我博客的Linux部分尝试安装。</p>
<h1 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h1><h2 id="准备安装的必要工具"><a href="#准备安装的必要工具" class="headerlink" title="准备安装的必要工具"></a>准备安装的必要工具</h2><p>本篇默认使用<strong>git bash</strong>作为bash环境，并且自带<strong>git</strong>，可以从<a href="https://git-scm.com/download/win">这里</a>下载安装，还需要安装<strong>node.js</strong>，可以从<a href="https://nodejs.org/zh-cn/">这里</a>下载安装（记得勾选<strong>Add to PATH</strong>）。<br>我当前使用的node.js版本为v8.10.0，npm版本为5.6.0，版本不一致可能带来<strong>不可预知的错误</strong>。</p>
<h2 id="进行本地安装"><a href="#进行本地安装" class="headerlink" title="进行本地安装"></a><strong>进行本地安装</strong></h2><ol>
<li><p>首先使用<strong>npm</strong>安装<strong>hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>hexo -v</code>查看是否安装成功</p>
</li>
<li><p><strong>创建的博客</strong><br>使用<code>cd</code>跳转到一个安全的目录，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Documents</span><br></pre></td></tr></table></figure>
<p> 初始化你的博客</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>这条命令执行中经常出现各种问题，可以<code>rm -rf myblog</code>删除这个目录重试</strong></p>
</li>
<li><p><strong>如果经常连接github失败，建议使用系统代理</strong></p>
</li>
<li><p><strong>仍然无法正确安装并初始化？</strong><br> <strong>可以用Linux子系统试试，参照本篇Linux部分</strong></p>
</li>
</ul>
</li>
<li><p><strong>验证</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> myblog</span><br><span class="line">$ npm i</span><br></pre></td></tr></table></figure>
<p> 博客初始化就完成了</p>
<p> 现在输入</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<pre><code>然后在浏览器中访问`http://localhost:4000/`即可预览界面。
</code></pre>
<p>界面是这样的<br><img data-src="/./look.png" alt="预览图像"></p>
<h2 id="使用Github-Pages"><a href="#使用Github-Pages" class="headerlink" title="使用Github Pages"></a>使用Github Pages</h2><p>在Github上新建一个名为<code>你github用户名.github.io</code>的新repo<br>在博客目录中打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure>
<p>把最后一行<code>type </code>改成<code>type: git</code><br>在最后一行，与type平齐，加上<code>repo: 仓库地址</code><br>比如的仓库地址是：<code>git@github.com:Geylnu/Geylnu.github.io.git</code><br>安装git部署插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>请在此前确认已经正确配置git<br>然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>OK<br>等上几分钟，访问<code>用户名.github.io</code>就能看见自己的博客了。</p>
<ul>
<li>如果访问失败，检查Github Pages是否开启</li>
<li>如果缺少样式，检查仓库名是否正确</li>
</ul>
<p>添加新的博客命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo start <span class="string">&quot;新的博客名&quot;</span></span><br></pre></td></tr></table></figure>
<p>重新生成页面使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h2 id="使用Coding-Pages服务"><a href="#使用Coding-Pages服务" class="headerlink" title="使用Coding Pages服务"></a>使用Coding Pages服务</h2><p>由于总所周知的原因，Github在国内的访问很不稳定，由Github Pages支撑的博客自然也难以访问，<a href="https://coding.net/">coding</a>位于国内，并且也支持Pages服务。<br>使用coding时，只需要将仓库名命名为<code>你的用户名.coding.me</code>，就可以了，其他操作和Giihub pages相同。</p>
<h1 id="在Linux-Ubuntu-上安装"><a href="#在Linux-Ubuntu-上安装" class="headerlink" title="在Linux(Ubuntu)上安装"></a>在Linux(Ubuntu)上安装</h1><h2 id="我的系统环境"><a href="#我的系统环境" class="headerlink" title="我的系统环境"></a>我的系统环境</h2><p>我使用的是<strong>win10 1709版本</strong>，os内部版本为<strong>16299.309</strong>，安装的Linux子系统为<strong>Ubuntu 16.04.3</strong>内核版本<strong>4.4.0-43-Microsoft</strong><br>你可以<a href="https://www.jianshu.com/p/bc38ed12da1d">参照这里</a>安装win10 Linux子系统。</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>使用官方的脚本安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>
<p>如果你是其他Linux发行版本或想安装其他版本，你可点此访问<a href="https://github.com/nodesource/distributions">相关说明</a></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>使用npm安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装完成后可以使用<code>node -v</code>和<code>npm -v</code>确认是否安装成功</p>
<p><strong>初始化博客</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure>
<p>我在这一步总是遇见报错<br><img data-src="/./err1.png" alt="报错"><br>根据错误提示尝试了各种办法都没有解决（还害的我重新装了次子系统），之后我在Github也看见了有人遇见了同样的<a href="https://github.com/npm/npm/issues/20103" title="Rename Issues">问题</a></p>
<p>因为这个问题是偶发性的，其实直接<code>cd ./myblog</code>重新执行<code>npm install</code></p>
<p>还是报错？<br><img data-src="/./err2.png" alt="报错"><br>再来，直到不报错为止<br><img data-src="/./suc.png" alt="成功"><br>OK<br>可以用<code>hexo s</code>验证是否能正确浏览,其他的就很在windows一样了</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行入门</title>
    <url>/2018/03/21/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="给自己弄一个bash环境"><a href="#给自己弄一个bash环境" class="headerlink" title="给自己弄一个bash环境"></a>给自己弄一个bash环境</h1><p>本文所使用的系统为Linux,如果你是macOS，大多命令是相通的，你不必担心；如果你使用的是Windows 10,你可以参照<a href="https://www.jianshu.com/p/bc38ed12da1d" title="win10安装Linux子系统">此篇博客</a>，不到10分种为你的win10安装一个Linux子系统,如果你是win8&#x2F;win7&#x2F;winxp，你可以<a href="https://www.jianshu.com/p/7a706c0a3411" title="cmder 一个比cmd强n倍的神器">参考此篇文章</a>使用带有模拟bash环境的命令行终端。</p>
<h1 id="命令行释义"><a href="#命令行释义" class="headerlink" title="命令行释义"></a>命令行释义</h1><p>打当你打开你的命令行，通常是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@PC:~$ </span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@PC ~ </span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<ol>
<li><code>user</code> 指你当前登陆的账户的用户名。</li>
<li><code>PC</code> 是指你当前登陆的主机名。</li>
<li><code>~</code> 指当前你处在的目录，~代表你处在你的用户目录下。</li>
<li><code>$</code> 指示你可以在其后输入命令并执行，并无实际意义，在部分Linux中，此符号为<code>#</code>。</li>
</ol>
<p>通常我们需要在命令后输入使用文件路径进行操作，而文件路径中分为<strong>绝对路径</strong>和<strong>相对路径</strong>,我们首先要理清这两者的概念。</p>
<ol>
<li><p><strong>绝对路径</strong><br>指该文件&#x2F;文件夹真实的文件路径，在windows中，我们在经常看见的<code>&quot;C:\Program Files\Adobe\Adobe Photoshop CC 2018&quot;</code>就是绝对路径。而在Linux中，没有盘符的概念，只有一个根目录<code>/</code>，在根目录下拥有许多分区，常见的路径是这样的<code>/home/geylun/bilibili</code>，因此在Linux中你可以认为以<code>/</code>开头的路径即是绝对路径。</p>
</li>
<li><p><strong>相对路径</strong><br>相对路径其实只是绝对路径一种缩减的写法，方便我们进行路径输入，比如我总喜欢在我<code>/home/geylun/</code>下做各种操作，我不可能每次都在参数后面跟这一大串路径，相对路径这个办法就出来了，我用<code>.</code>代表当前目录，<code>..</code>代表当前目录的上级目录，<code>~</code>代表我的用户目录，这样在我的文件夹进行各种操作的时候，就只用输入<code>~</code>。</p>
</li>
</ol>
<h1 id="命令释义"><a href="#命令释义" class="headerlink" title="命令释义"></a>命令释义</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><ul>
<li><p><strong><code>cd</code></strong><br>改变你当前的工作目录，这样你可以以相对路径来更方便的输入路径，并且许多命令也只对当前工作目录生效。<br>如果目录太长，你可以按<strong>TAB</strong>键自动补全路径。</p>
</li>
<li><p><strong><code>pwd</code></strong><br>列出你当前目录的绝对路径</p>
</li>
<li><p><strong><code>ls</code></strong><br>列出当前目录里的文件及文件夹。<br>  <strong>可选参数</strong></p>
<ul>
<li><code>-a</code> 显示所有文件（包括以<code>.</code>开头的隐藏文件）</li>
<li><code>-l</code> 显示详细信息，包括权限、所有者、创建时间</li>
<li><code>-R</code> 递归的列出所有文件及其所在目录（tree更好）</li>
</ul>
</li>
<li><p><strong><code>tree</code></strong><br>以树状图的方式展示当前目录结构及文件</p>
<ul>
<li><code>-a</code> 显示所有文件<br>如果你没有此命令，Linux系统可以输入<code>sudo apt-get install tree</code>安装tree工具。</li>
</ul>
</li>
<li><p><strong><code>cat</code></strong><br>从文件中读入字符并打印到屏幕上<br>有很多参数可选，你可以参照<a href="http://www.runoob.com/linux/linux-comm-cat.html" title="Linux cat命令">菜鸟教程</a></p>
</li>
</ul>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>注意，命令行是以空格等标记分割参数，如果你输入的文件名包含空格，你最好使用<code>&quot;&quot;</code>包裹它。</p>
<ul>
<li><p><strong><code>touch</code></strong><br>如果文件不存在则创建文件，如存在则以当前系统时间修改时间属性</p>
</li>
<li><p><strong><code>echo</code></strong><br>回声，输入什么就输出什么<br>echo是一个很有趣的命令，你输入什么它就输出什么，使用<code>&gt;</code>重定向就能以指定的文本内容创建文件，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span> &gt;init.txt</span><br></pre></td></tr></table></figure>
<p>  这样就可以创建一个内容为”Hello world”的文件<br>  每次重新执行会覆盖之前的内容<br>  如果你想追加内容，而不是覆盖原文件，可以这样做</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;QAQ&quot;</span> &gt;&gt;init.txt</span><br></pre></td></tr></table></figure>
<p>  文本内容就会变成<br>  Hello world QAQ<br>  事实上你可以使用<code>&gt;</code>把任意的标准输出都重定向到新的文件中。</p>
</li>
<li><p><strong><code>cp</code></strong><br>复制文件到另一个文件，如果另一个文件不存在则创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> init.txt init.txt.backup</span><br></pre></td></tr></table></figure>
<p>  这样就会创建一个init文件的复制。</p>
</li>
<li><p><strong><code>mkdir</code></strong><br>创建一个目录<br>  <strong>可选参数</strong></p>
<ul>
<li><code>-p</code> 确保目录存在，不存在就创建一个</li>
</ul>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p><strong><code>mv</code></strong><br>修改文件&#x2F;文件夹路径，你可以使用此命令进行重名名、移动、覆盖等<br>比如修改名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> init.txt hello.txt</span><br></pre></td></tr></table></figure>
<p>  <strong>可选参数</strong></p>
<ul>
<li><code>-i</code> 如果目标文件存在就询问是否覆盖（默认直接覆盖）</li>
<li><code>-u</code> 若目标文件已经存在，且源文件更新时，才进行覆盖。</li>
</ul>
</li>
<li><p><strong><code>rm</code></strong><br>删除文件<br>  <strong>可选参数</strong></p>
<ul>
<li><code>r</code>递归删除，如果文件夹中还有文件夹，会一直查询到没有新的目录为止，然后一个个删除文件夹和文件</li>
<li><code>r</code>不要询问、警告我。<br>  <strong>使用<code>rm -rf</code>请再三小心！</strong></li>
</ul>
</li>
<li><p><strong><code>vim</code></strong><br>  命令行界面的文字编辑器，你可以使用输入<code>vimtutor</code>查看它的自带教程。</p>
</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><p><strong><code>clrar</code></strong><br>清屏</p>
</li>
<li><p><strong><code>history</code></strong><br>查看命令输入历史</p>
</li>
</ul>
<h1 id="命令行技巧"><a href="#命令行技巧" class="headerlink" title="命令行技巧"></a>命令行技巧</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><strong><code>TAB</code></strong> 提示命令及补全路径</li>
<li><strong><code>↑</code></strong>&#x2F;<strong><code>↓</code></strong> 上一条下一条命令</li>
<li><strong><code>ALT</code></strong>+<strong><code>.</code></strong> 上一个命令的最后一个参数</li>
<li><strong><code>!!</code></strong> 上一条命令占位符</li>
</ul>
<h2 id="修改-x2F-bashrc"><a href="#修改-x2F-bashrc" class="headerlink" title="修改~&#x2F;.bashrc"></a>修改~&#x2F;.bashrc</h2><p>可以再.bashrc中添加命令，这些命令会在终端打开时自动执行这些命令<br>你可以添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Desketop</span><br></pre></td></tr></table></figure>
<p>自动跳转到桌面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>把 <code>la</code> 定义为<code>&#39;ls -a&#39;</code></p>
<p>你还可以在这里定义环境变量，这些环境变量会影响到具体命令的执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SASS_BINARY_SITE=<span class="string">&quot;https://npm.taobao.org/mirrors/node-sass&quot;</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>如何在touch事件中模拟mouse事件中的offsetX offsetY</title>
    <url>/2019/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8touch%E4%BA%8B%E4%BB%B6%E4%B8%AD%E6%A8%A1%E6%8B%9Fmouse%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84offsetX-offsetY/</url>
    <content><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h1><p>最近想制作一个在散开的纸面画画的效果，纸面会按一定角度倾斜，就像下面这样↓<br><img data-src="/2019/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8touch%E4%BA%8B%E4%BB%B6%E4%B8%AD%E6%A8%A1%E6%8B%9Fmouse%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84offsetX-offsetY/canvas.png" alt="canvas"><br>也就是给canvas元素加了<code>transform: roate(-2deg)</code></p>
<h1 id="2-电脑端实现"><a href="#2-电脑端实现" class="headerlink" title="2. 电脑端实现"></a>2. 电脑端实现</h1><p>在电脑端很容易实现,鼠标事件中有<code>offsetX Y</code>，能够获得鼠标位置相对于目标节点的位置，可以简单理解为相对于元素左上角的坐标。获得坐标后，再按坐标绘制到Canvas上，一切就OK了，不过到了移动端就有点麻烦了。</p>
<h1 id="3-移动端实现"><a href="#3-移动端实现" class="headerlink" title="3. 移动端实现"></a>3. 移动端实现</h1><p>移动端touch事件有以下几个属性</p>
<ul>
<li>ClientX Y 相对于视口的坐标</li>
<li>pageX Y 相对于页面左上角原点的坐标</li>
<li>screenX Y 相对于屏幕的坐标标</li>
<li>movementX Y 相对于上一次坐标的坐标</li>
</ul>
<p>然而就是没有<code>offsetX Y</code>，怎么办，自己模拟试试？</p>
<h2 id="3-1-第一次模拟"><a href="#3-1-第一次模拟" class="headerlink" title="3.1 第一次模拟"></a>3.1 第一次模拟</h2><ol>
<li>获得<code>pageX Y</code></li>
<li>通过<code>offsetTop left</code>计算元素左上角的顶点位置<code>vertex</code></li>
<li>计算相对坐标</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getVertexPosition</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentTarget = el</span><br><span class="line">    <span class="keyword">let</span> top = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (currentTarget !== <span class="literal">null</span>) &#123;</span><br><span class="line">        top += currentTarget.<span class="property">offsetTop</span></span><br><span class="line">        left += currentTarget.<span class="property">offsetLeft</span></span><br><span class="line">        currentTarget = currentTarget.<span class="property">offsetParent</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; top, left &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vertex = <span class="title function_">getVertexPosition</span>(canvas)</span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offsetX = e.<span class="property">pageX</span>-vertex.<span class="property">left</span></span><br><span class="line">    <span class="keyword">let</span> offsetY = e.<span class="property">pageX</span>-vertex.<span class="property">top</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在页面没有设置任何<code>transform</code>属性的情况下，这个代码是生效的，能获得正确的坐标点。<br>然而如果父元素或目标元素有任何<code>transform</code>属性，坐标就会错误，比如本文中的canvas元素，设置了<code>transform: roate(-2deg)</code>,坐标就发生了偏移。<br>随后搜索了一下是否有类似的解决方案，结果都是这样的代码，都不能对<code>transform</code>元素生效。</p>
<h2 id="3-2-偏移原因"><a href="#3-2-偏移原因" class="headerlink" title="3.2 偏移原因"></a>3.2 偏移原因</h2><p>偏移原因是因为变换后，元素的坐标轴已经改变了，而我们得到的坐标还是变换前的坐标，自然而然就发生错误了。<br><img data-src="/2019/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8touch%E4%BA%8B%E4%BB%B6%E4%B8%AD%E6%A8%A1%E6%8B%9Fmouse%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84offsetX-offsetY/reason.png" alt="坐标图"><br>如图所示，实际触摸点是绿色，本应也绘制在绿色坐标点，但是我们现在的坐标系仍然是之前的坐标系，就导致了绘制点相对于原来的坐标点绘制，也即紫色，导致绘制偏移。<br>解决办法也很简单，将触摸点按照新坐标系计算得到值，就是真实的相对坐标了。<br><strong>步骤：</strong></p>
<ol>
<li>获得点击坐标（pageX pageY）</li>
<li>获得旋转角度 旋转中心</li>
<li>将旋转中心于元素顶点坐标相加，得到整个页面的旋转中心</li>
<li>旋转相同负角度（逆运算），将点击坐标还原到真实的坐标系</li>
<li>减去顶点坐标，获得真实相对坐标。</li>
</ol>
<h2 id="第二次模拟"><a href="#第二次模拟" class="headerlink" title="第二次模拟"></a>第二次模拟</h2><ol>
<li><p>首先获得计算后的样式，获得<code>transform</code>相关属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(el)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(style) </span><br></pre></td></tr></table></figure>
<p>获得的<code>transform</code>属性如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform: &quot;matrix(0.999391, -0.0348995, 0.0348995, 0.999391, 0, 0)&quot;</span><br><span class="line">transformBox: &quot;view-box&quot;</span><br><span class="line">transformOrigin: &quot;160px 240px&quot;</span><br><span class="line">transformStyle: &quot;flat&quot;</span><br></pre></td></tr></table></figure>
<p>关于<code>transform:matrix</code>以及如何理解查看<a href="https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/">张鑫旭的文章</a>。<br>简而言之，就是<code>transform</code>属性都是通过<code>transform:matrix</code>进行矩阵计算得到坐标的。</p>
</li>
<li><p>解析transform属性<br>由于这里涉及到矩阵运算，需要引入<a href="https://mathjs.org/">math.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transform = style.<span class="property">transform</span></span><br><span class="line"><span class="keyword">let</span> transformOrigin = style.<span class="property">transformOrigin</span></span><br><span class="line"><span class="keyword">let</span> origin = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">let</span> matrix = math.<span class="title function_">ones</span>([<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> (transform !== <span class="string">&#x27;none&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> originArray = transformOrigin.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    origin.<span class="property">x</span> = <span class="built_in">parseInt</span>(originArray[<span class="number">0</span>])</span><br><span class="line">    origin.<span class="property">y</span> = <span class="built_in">parseInt</span>(originArray[<span class="number">1</span>]) <span class="comment">//矩阵的坐标变化是基于变换中心得。</span></span><br><span class="line">    <span class="keyword">let</span> matrixString = transform.<span class="title function_">match</span>(<span class="regexp">/\(([^)]*)\)/</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> stringArray = matrixString.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> temp = []</span><br><span class="line">    stringArray.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        temp.<span class="title function_">push</span>(<span class="built_in">parseFloat</span>(value.<span class="title function_">trim</span>()))</span><br><span class="line">    &#125;)</span><br><span class="line">    temp = [</span><br><span class="line">        [temp[<span class="number">0</span>], temp[<span class="number">2</span>], temp[<span class="number">4</span>]],</span><br><span class="line">        [temp[<span class="number">1</span>], temp[<span class="number">3</span>], temp[<span class="number">5</span>]],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    ]</span><br><span class="line">    matrix = math.<span class="title function_">inv</span>(temp) <span class="comment">//进行逆矩阵</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    matrix = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了原变换矩阵的逆矩阵和变换中心，就能将触摸点正确的还原到原坐标系了</p>
</li>
<li><p>计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computPosition</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; matrix, origin, <span class="attr">vertex</span>: &#123; top, left &#125;,<span class="attr">ponit</span>:&#123;x,y&#125; &#125; = obj</span><br><span class="line">    x = x - left - origin.<span class="property">x</span></span><br><span class="line">    y = y - top - origin.<span class="property">y</span></span><br><span class="line">    <span class="keyword">let</span> result = math.<span class="title function_">multiply</span>(matrix, [x, y, <span class="number">1</span>])</span><br><span class="line">    x = result[<span class="number">0</span>] + origin.<span class="property">x</span></span><br><span class="line">    y = result[<span class="number">1</span>] + origin.<span class="property">y</span></span><br><span class="line">    <span class="keyword">return</span> (x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际实现</p>
<ol>
<li>由于子元素会受到父元素变换影响，因此需要遍历所有父元素</li>
<li>由于<code>getComputStyle()</code>和获得顶点坐标有较大性能消耗，最好将相关参数缓存起来<br> 实际代码实现见此<a href="https://github.com/Geylnu/touch-offset">https://github.com/Geylnu/touch-offset</a></li>
</ol>
</li>
</ol>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>W3C给出了没有为touch事件添加<code>offsetX Y</code>的原因<a href="https://github.com/w3c/touch-events/issues/62">https://github.com/w3c/touch-events/issues/62</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>移动端兼容</tag>
        <tag>原生事件</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]我们仍没有对私有方法是否需要进行测试达成共识</title>
    <url>/2022/05/30/%E6%88%91%E4%BB%AC%E4%BB%8D%E6%B2%A1%E6%9C%89%E5%AF%B9%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E8%BE%BE%E6%88%90%E5%85%B1%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>这篇文档来自于<a href="https://www.ruanyifeng.com/blog/2022/05/weekly-issue-207.html#:~:text=3%E3%80%81-,%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97%EF%BC%9F,-%EF%BC%88%E8%8B%B1%E6%96%87%EF%BC%89">阮一峰老师的周刊</a>，主题是私有方法是否需要测试，罗列了多方的观点和意见，如果对单元测试的范围也不太确定的话，强烈推荐看看这一篇文章。原文：<a href="https://jesseduffield.com/Testing-Private-Methods/">https://jesseduffield.com/Testing-Private-Methods/</a></p>
</blockquote>
<p>昨天，当我在一个Rust工作会议上，我不假思索的说：我想我们都同意在编写单元测试时，除非有特殊情况，否组都不应该直接测试私有方法。一个小型的辩论就展开了，许多人争论着互不相容的观点。我们很快结束了这场辩论，但是我还是有一点尴尬，我有点错判了开发人员的信条。</p>
<p>毫无疑问，在开发人员这个职业中，至少有一种观点大家现在都是都是同意的，对吧？再猜一次。如果你想知道这个讨论上的共识有多少，你可以通读一下Stack Overflow上的帖子: <a href="https://stackoverflow.com/questions/9122708/unit-testing-private-methods-in-c-sharp">Unit testing private methods in C#</a>, <a href="https://stackoverflow.com/questions/48011295/how-to-unit-test-this-private-method">How to unit test this private method?</a>, <a href="https://stackoverflow.com/questions/5601730/should-private-protected-methods-be-under-unit-test">Should Private&#x2F;Protected methods be under unit test? </a>。有人说我们应该总是直接测试私有方法，有的人说我们永远不应该直接测试私有方法。这些看法不可能都是对的！有没有最适合当前软件开发状况的观点？</p>
<p>关于测试私有方法的讨论，有五种流行的观点：</p>
<ul>
<li><p>首先就不使用私有方法</p>
</li>
<li><p>总是测试私有方法</p>
</li>
<li><p>永远不要测试私有方法</p>
</li>
<li><p>有时可以测试私有方法</p>
</li>
<li><p>将私有方法提取到类中</p>
</li>
</ul>
<p>在这篇文章中，我将讨论每一个观点，然后总结提炼成我自己的经验法则，希望大多数人都能赞同它。注意，虽然我们将讨论类和方法，但是相同的观点也适用于函数式语言中的匿名函数。</p>
<h3 id="观点1：首先就不使用私有方法"><a href="#观点1：首先就不使用私有方法" class="headerlink" title="观点1：首先就不使用私有方法"></a>观点1：首先就不使用私有方法</h3><p>我会把这个观点展示出来，是因为大多数人都会认为它有点极端，如果它是对的，它会这个辩论的其他部分无效化。</p>
<p>这种观点与其说是对私有方法的攻击，不如说是对试图预测未来的攻击，这个想法是，在编写库代码的时候，你不可能事先知道你的使用者想使用什么方法，并且默认使用私有方法将为你和你的客户带来更多的问题相比于默认为公共方法(或者受保护方法)。这似乎是一种库开发人员独一无二的想法（见<a href="https://osoco.es/thoughts/2018/10/the-case-against-private-methods/">The case against private methods</a>, ）因为应用开发者可以用一下键盘就很容易让方法变成空的，而库的使用者需要分叉代码库或者提出问题等待回应。</p>
<p>这种也有不利的一面：将一个私有方法转变成公开方法很容易，但是从公开方法降级到私有方法是一个破坏的改动。此外，你的公共方法表明了你希望他们如何使用你的库。为了假设的使用场景，使原有的私有API膨胀你的公共API，你会使你的所有使用者更加难受，他们只想知道如何满足已知的使用场景。这些缺点是交织在一起的：使用者使用错误的方法与你的库交互，这反过来也使重构变得更加困难</p>
<h3 id="观点2：总是测试使用私有方法"><a href="#观点2：总是测试使用私有方法" class="headerlink" title="观点2：总是测试使用私有方法"></a>观点2：总是测试使用私有方法</h3><p>虽然这是一个不受欢迎的观点，但是仍然有<a href="https://oli.me.uk/test-private-methods/">一些</a>支持者，主要有三论点：</p>
<ul>
<li>当使用测试驱动开发(TDD)时，你需要在编写代码前编写测试，所以你最好在每个方法的基础上编写测试，而不管你的方法是共有的还是私有的。</li>
<li>通过隔离测试每一个方法，（不管访问修饰符是什么）可以让读者清楚得了解每个方法的预期行为，这样他们就可以更好地理解每个方法在全局中扮演的角色。</li>
<li>直接测试私有方法的一个显而易见的替代方法是通过公共方法测试它们，但是这需要花更长的时间去编写代码，并且可能导致测试需要更长的时间去运行。如果你首要任务是节省开发时间，并且你相信测试公共方法的前期成本高于重构时重写私有方法的持续成本，那么首先测试私有方法并在代价出现时去解决是有意义的。</li>
</ul>
<p>有些语言比其它语言更容易测试私有方法，如果你的语言使你需要破解各种障碍来测试一个私有方法，那么你或许不适合这种观点。</p>
<h3 id="观点3：永远不要测试私有方法"><a href="#观点3：永远不要测试私有方法" class="headerlink" title="观点3：永远不要测试私有方法"></a>观点3：永远不要测试私有方法</h3><p>与先前的观点截然相反，这个观点的主要观点是，你的类的使用者只能通过它的公共方法（即类上的公共方法集）交互所以为什么你的测试会与众不同呢？如果私有方法不能直接被公共方法访问，那么它就是死代码。并且应该被删除、如果它可以通过公共访问被访问，那么你应该通过公共方法测试私有方法，因为如果不模拟即将适应的代码的用户，那么测试的目的是什么呢？</p>
<p>这是哲学上的观点，但是实际的论点更容易被接受：如果你的测试仅仅依赖于类的公共接口，那么你可以重构这个类的内部实现，而不需要改变任何测试。如果你不需要更新测试，那么你能够确切的知道一个失败的测试以为着你破坏了某些东西，而一个完全绿色的测试套件意味着你已经成功的保留了类的原始行为。</p>
<p>相反，如果类的测试依赖于私有方法，并且你的重构删除或更改了任何一个方法的签名，那么你需要重写这些测试来处理新的内部结构，但是现在你已经对你的测试失去了信心，因为测试重写和代码重写一样容易出错！</p>
<p>其次，即使你能够小心地重写测试，捕获与之前完全相同的行为，这仍然是一个费事实力的过程，因此阻止了可以改代码库健康状况的重构。先验观点更强调通过公共方法测试私有方法的前期成本，而这个观点更关心重构的持续成本。</p>
<h3 id="观点4：有时测试私有方法"><a href="#观点4：有时测试私有方法" class="headerlink" title="观点4：有时测试私有方法"></a>观点4：有时测试私有方法</h3><p>先前的观点非常关注“公共接口”，但是这个新的观点质疑什么是真正的公共的，什么是真正的单元。如果你正在编写一个应用（运行二进制文件），而不是一个库（代码被导出用于其他代码库），那么它只有一个真正的公共接口，也就是它自己，例如有用户的按键和点击组成的接口。如果你想像前面的观点所倡导的那样有最大化的重构能力，那么最好的方法是让每个测试都打开应用并模仿用户的点击和按键。这样，对任何内部代码都没有依赖性，你可以自信地重构代码，而不必重写任何测试。</p>
<p>在很少的情况下，端到端测试是最明智选择，例如，当你继承了一个几乎不可能进行单元测试的系统，你将要重构整个代码库，或者当你正在构建一个AB测试，并且想要针对两个实现运行测试以获得特性、BUG兼容性。然而，在大多数情况下，放弃所有的单元测试，代之以编写数以万计的端到端测试，而这些测试实际上是在模仿真实的用户，这是荒谬的。只包含端到端测试的测试套件存在问题的原因有一下几个：</p>
<ul>
<li>运行一个给定的测试需要太长的时间</li>
<li>编写一个给定的测试需要太长的时间</li>
<li>每个测试的复杂性掩盖了它的意图，降低了测试作为文档的能力</li>
<li>更改一个特性可能会破坏另一个不相关的测试</li>
</ul>
<p>正是由于这些原因，单元测试才首先存在，作为开发人员，我们通过更深入地侵入应用程序的代码并选择我们认为值得单独测试的“单元”来妥协。我们这样做是因为知道，如果重构导致这样一个单元消失，那么我们需要在其他地方重写它的测试，并承担上述所有成本。</p>
<p>一旦我们开始测试相对于我们的其它代码是公开的，但是相对于最终用户是私有的代码，我们必须承认我们的“单元”选择过程固有的随意性。在类中测试私有方法和在应用程序中测试类之间的区别只是程度上的不同，而不是种类上的不同。</p>
<p>这为我们提供了一个封装范围，从应用程序本身开始，向下通过模块、类，最后到私有方法，我们将封装级别降低到越来越小的片。封装级别越低，越难测试， 但封装级别越低，越难重构。</p>
<p>这种观点认为，如果一个私有方法足够自成一体。并且通过公共接口测试让人头疼，那么它就可以直接测试，而不必感到羞愧或内疚，否则就是双重标准。</p>
<h3 id="观点5：将私有方法单独提取到一个单独的类中"><a href="#观点5：将私有方法单独提取到一个单独的类中" class="headerlink" title="观点5：将私有方法单独提取到一个单独的类中"></a>观点5：将私有方法单独提取到一个单独的类中</h3><p>这个观点建立在前一个观点的基础之上 ，即如果你发现自己想要测试一个私有方法，那么这是一个迹象，表明你的类可能有大多的职责，违反单一职责原则(SRP)。</p>
<p>在《修改代码的艺术》一书中，作者Michael Feathers说：</p>
<blockquote>
<p>如果我们需要测试一个私有方法，我们应该将其公共化。如果公开它让我们感到困扰，在大多数情况下，这意味着我们的类做的太多了，我们应该修正它。</p>
</blockquote>
<p>(就我个人而言， 就我个人而言，我发现想象完全为了测试而公开一个方法不会感到困扰，但是你明白我的意思)</p>
<p>在Ruby中的实用面向对象设计中，，Sandi Metz 还指出，渴望被测试的私有方法是违反单一职责的坏味道。</p>
<p>前面的观点认为“单位”的选择是任意的，这个观点不同意。如果你想测试一些私有代码，那就意味着您偶尔发现了一个抽象边界，而这个抽象边界中并没有明确表示出来。也许你想要测试一些直接与问题相关联的算法，这种情况下，它应该被提取到它自己的抽象实现中。</p>
<p>通过将一个私有方法提取到一个单独的类中，我们现在可以通过它的公共接口来测试这个类，而且我们还有一个额外的好处，那就是将一个新类作为一个依赖项注入到原始类中，使我们能够很容易地模拟构造类的行为，这样代码和测试都可以保持职责分离。</p>
<p>如果在类中包装单个函数有点极端，而且你的语言允许函数存在于类之外，那么大概率将私有方法提取到它自己的独立函数中没有问题，前提是你可以切断它对任何实例变量的依赖关系。</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>我们从一个提出激进的观点开始，即任何方法都不应该是私有的。当然可以简化测试过程，但是缺乏封装也使测试过程变得很糟糕。</p>
<p>然后我们考虑了两个完全矛盾的观点，一个不想测试私有方法，另一个想测试所有的公有和私有方法。然后第三种观点出现了，提出无论你在封装的范围内处于什么位置，在更高级别（例如类）或更低级别（例如私有方法）进行测试都有利有弊，如果利大于弊，那么编写对应的测试并不可耻。</p>
<p>再之后，第四种观点出现了，它给这种测试方式泼了一盆冷水，需要测试私有方法本身就是类有太多职责的坏味道。</p>
<p>一个强调坚持测试类的公共API的观点3支持者可能会对观点5的支持者说：等一下，到目前为止，我们一直在讨论重构和封装，但是你已经将目标转移到了单一职责上！将私有方法移动到私有的类中并不能减轻重构时的负担：我们很可能需要像处理私有方法一样处理、更改私有类，这意味着在任何情况下，测试仍然需要重写。这里假设你的语言支持私有类，如果你支持的话，你就在刚才扩展了你的公共API，包含了一个你实际上不希望客户端使用的类！当一个私有方法只被一个类使用时将它移动到一个完全独立的文件中真的有意义吗》这对可读性有什么帮助？</p>
<h3 id="我的建议"><a href="#我的建议" class="headerlink" title="我的建议"></a>我的建议</h3><p>下面是我建议的方法：通过将每个方法默认为private，在类中尽可能使用精简的公共接口。如果你发现你自己想要直接测试一组私有方法，那么请考虑提取一个类（或独立函数）,但前提是它与你的测试需求无关。如果你想测试一个私有方法，并且看不到将其从类中提取出来的意义，那么将其转换为一个存函数，并测试该方法。这样，如果以后你决定将其函数移动到其他地方，那么移动测试就像复制+ 粘贴一样简单。</p>
<p> 在这场辩论中，我是否忽略或歪曲了任何观点？你不同意我的观点？我是不是太过于笼统了？有消息通知我。下次见！</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><a href="https://anthonysciamanna.com/2016/02/14/should-private-methods-be-tested.html">Should Private Methods Be Tested?</a> - Anthony Sciamanna</li>
<li><a href="https://www.artima.com/articles/testing-private-methods-with-junit-and-suiterunner">Testing Private Methods with JUnit and SuiteRunner</a> - Bill Venners</li>
<li><a href="https://fishbowl.pastiche.org/2003/03/28/testing_private_methods_dont_do_it">Testing private methods (don’t do it)</a> - Charles Miller</li>
<li><a href="https://oli.me.uk/test-private-methods/">Test private methods</a> - Oliver Caldwell</li>
<li><a href="https://osoco.es/thoughts/2018/10/the-case-against-private-methods/">The case against private methods</a> - José san leandro</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>私有方法</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手让小白也能重装系统！</title>
    <url>/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/</url>
    <content><![CDATA[<p><em>写本文得目的主要是为了帮助我的笨蛋马q儿子，面向0基础的小白，看完这篇文章你也就可以为自己重装系统，不花一份钱啦！</em></p>
<h1 id="简单装机"><a href="#简单装机" class="headerlink" title="简单装机"></a>简单装机</h1><p>注意，名为简单装机的原因是一以下<strong>所有的步骤</strong>都是<strong>理想状态</strong>下的，由于系统、各厂商bios不同，历史各种版本迭代原因，带来了许多兼容性问题，本应该丝滑流畅的安装过程总有可能遇到难以解决的兼容性问题，我可以尽可能的把我所遇到的问题及解决办法写下来，但不可避免会让文章变得冗长，晦涩，因此我决定不写这方面的坑，如果你遇到了，去&lt;baidu.com&gt;或者&lt;google.com&gt;上寻找解决方案吧！<strong>网络是最大百科全书。</strong></p>
<h1 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h1><h2 id="你需要的硬件准备"><a href="#你需要的硬件准备" class="headerlink" title="你需要的硬件准备"></a>你需要的硬件准备</h2><ul>
<li>一个至少8G的U盘</li>
<li>一台能上网的PC</li>
</ul>
<h2 id="你需要的软件准备"><a href="#你需要的软件准备" class="headerlink" title="你需要的软件准备"></a>你需要的软件准备</h2><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p>你可以选用迅雷，尽管它很臃肿。</p>
<h3 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h3><p>请注意，我希望你仅仅只在&lt;msdn.itellyou.cn&gt;或者微软的官方渠道下载你需要的系统，在其它地方下载系统存在一定的风险。</p>
<ul>
<li>第一步<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/1.png"></li>
<li>第二步<br>我总是建议你使用当前最高版本的win10<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/2.png"></li>
<li>第三步<br>内存高于4G的总是选用x64（64位的）<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/3.png"></li>
<li>第四步<br>复制这个框内的链接<br>一般情况下迅雷检测到会自动弹出，如果没有你可以自己打开迅雷新建任务，它会自动识别剪切板的内容，创建下载任务。<br>选择你想储存到的地方，开始下载。<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/4.png"><br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/5.png"></li>
</ul>
<h3 id="下载安装镜像写入工具"><a href="#下载安装镜像写入工具" class="headerlink" title="下载安装镜像写入工具"></a>下载安装镜像写入工具</h3><p>我使用的（UltraISO软碟通 ），你可以去这里下载<a href="https://cn.ezbsystems.com/download.htm">https://cn.ezbsystems.com/download.htm</a><br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/6.png"><br>下载后直接安装即可</p>
<h2 id="开始制作系统安装U盘"><a href="#开始制作系统安装U盘" class="headerlink" title="开始制作系统安装U盘"></a>开始制作系统安装U盘</h2><ul>
<li>第一步<br>  打开UltraISO<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/7.png"><br>  点击试用，对我们来说试用版的功能已经足够了</li>
<li>第二步<br>  找到你下载的系统镜像<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/8.png"><br>  双击它<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/9.png"><br>  之后你会看见这样的目录及结构，这表示你已经进入镜像文件里了<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/10.png"></li>
<li>第三步<br>  <strong>插入U盘</strong><br>  单击上方的启动按钮<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/11.png"><br>  选择写入硬盘镜像<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/12.png"><br>  这时就会弹出设置，设置如何把系统镜像写入U盘的方式<br>  写入方式我建议使用USB-HDD的方式<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/13.png"><br>  我建议你在写入前格式化你的U盘，这回带来更好的兼容性<br>  <strong>请注意备份你的U盘数据</strong><br>  然后点击<code>写入</code>，就开始将系统镜像写入到你的U盘，整个过程大约在5-10分钟<br>  另外请记住你的U盘物理名，这在后面有用。<br>  <img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/14.png"><br>  恭喜你！你已经制作好了系统安装U盘</li>
</ul>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统是整个环节最困难最容易出问题的环节，我们得离开我们熟悉的windows进入bios，并且不同品牌的biso往往不尽相同。</p>
<h3 id="选择从我们的U盘启动系统安装"><a href="#选择从我们的U盘启动系统安装" class="headerlink" title="选择从我们的U盘启动系统安装"></a>选择从我们的U盘启动系统安装</h3><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><p>方法： 直接插入U盘，开机，就可以直接进入系统安装界面</p>
<p>是的！简单方法我们仅仅只需要插入U盘就行了！一般来说近几年的电脑都支持这种方法，是不是很便利！</p>
<h4 id="复杂方法"><a href="#复杂方法" class="headerlink" title="复杂方法"></a>复杂方法</h4><p><em>请注意！当你无法使用上面的方法进入系统安装界面，通常意味着你的bios很老旧或者厂商对你的bios做了一些奇奇怪怪的修改，你可能会遇见大量的兼容性问题，你可以尝试百度&#x2F;谷歌相关错误现象&#x2F;提示来解决</em></p>
<ul>
<li>复杂方法一<br>搜索你的电脑品牌+快捷启动，或启动选项，这些教程会很详细的告诉你如何进入快捷启动。</li>
</ul>
<p>进入快速启动后，选择你的U盘，<code>enter</code>确定就可以进入安装界面了</p>
<ul>
<li>复杂方法二<br>同样搜索你的电脑品牌+设置启动顺序，你也可以看见大量教程了，按照他们说的做，不要乱设置，设置完重启就可以了。</li>
</ul>
<h3 id="正式安装系统"><a href="#正式安装系统" class="headerlink" title="正式安装系统"></a>正式安装系统</h3><p>如果你成功的从U盘启动了系统安装，你会看见这样的界面<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/15.png"></p>
<p>点击<code>下一步</code>,再点击<code>现在安装</code>，你会过几秒后看到这个页面<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/16.png"><br>请记住总是选择<strong>专业版</strong></p>
<p>点击<code>下一步</code>，<code>我接受许可条款</code>，<code>下一步</code></p>
<p>选择下方的自定义安装，升级选项总容易出问题<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/17.png"></p>
<p>选择后你会看到这样的界面<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/18.png"></p>
<p>如果你是全新的电脑，这里只会出现未分配的空间，重装的就会出现你的硬盘分区和默认隐藏的分区。</p>
<p>全新的电脑你可以自由分配空间，重装的电脑你选择C盘下一步就可以了。<br><img data-src="/2018/05/18/%E6%89%8B%E6%8A%8A%E6%89%8B%E8%AE%A9%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%81/19.png"></p>
<p>完成后记得一定要拔掉U盘，否则又会进入安装界面。</p>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="使用微软账号激活"><a href="#使用微软账号激活" class="headerlink" title="使用微软账号激活"></a>使用微软账号激活</h3><p>如果你之前有一台已经激活的win10，并注册了微软账号并在激活的win10上登陆过，在新的win10系统上你登陆你的微软账号就可以自动激活了，激活有数量限制，具体我未测试过。</p>
<h3 id="使用产品密钥激活"><a href="#使用产品密钥激活" class="headerlink" title="使用产品密钥激活"></a>使用产品密钥激活</h3><p>你可以直接在淘宝上买到激活码,搜索win10专业版密钥，大概10元一个，激活后你可以注册微软账号，以后都可以激活自己的系统了。</p>
<h3 id="使用kms破解激活"><a href="#使用kms破解激活" class="headerlink" title="使用kms破解激活"></a>使用kms破解激活</h3><p>你可以直接使用关键字win10破解搜索到相关工具，而且基本一定能破解，但是这个激活只能维持180天，kms会在180天后自动重新激活，并不方便，而且下载破解软件的过程中，可能感染病毒、被安装流氓软件，这是最不推荐的方式。</p>
<p><strong>ok，一切完工啦！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2018/04/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><p>参见<a href="https://zh.wikipedia.org/zh-hans/%E7%AE%97%E6%B3%95">维基</a></p>
<ul>
<li>输入：一个算法必须有零个或以上输入量。</li>
<li>输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
<li>明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望通常要求实际运行结果是确定的。</li>
<li>有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵 机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。</li>
<li>有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>
<p>算法拥有常见的范式</p>
<ul>
<li>分治法：把一个问题分区成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。</li>
<li>动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。</li>
<li>贪婪（心）算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。</li>
<li>线性规划法： 考虑多变量寻求各方权衡的最优解。</li>
<li>简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。</li>
</ul>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><p>顾名思义，就是指指导数据怎样存储，怎样组织，数据结构通常与算法是联结在一起的的，互不可分的。</p>
<h1 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h1><p>参见<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">维基</a></p>
<p>每个算法的<a href="https://visualgo.net/bn/sorting">可视化展示</a></p>
<p>尽量找时间每个常见排序算法都写一次。</p>
<p>已写的排序算法：</p>
<ul>
<li><p>冒泡排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,temp=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[j] &gt; p[j+<span class="number">1</span>])&#123;</span><br><span class="line">				temp=p[j];</span><br><span class="line">				p[j]=p[j+<span class="number">1</span>];</span><br><span class="line">				p[j+<span class="number">1</span>]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,temp;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		temp=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[j]&lt;=p[temp])&#123;</span><br><span class="line">				temp=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(temp!=i)&#123;</span><br><span class="line">			p[i]=p[i]+p[temp];</span><br><span class="line">			p[temp]=p[i]-p[temp];</span><br><span class="line">			p[i]=p[i]-p[temp];	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基数排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现的不好</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="comment">//假设只会对 [0,100)以内随机数进行排序</span></span><br><span class="line">	<span class="type">int</span> *tp =(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		tp[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">		tp[p[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(tp[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">			p[k++]=j;</span><br><span class="line">			tp[j]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">headSort</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">makeMaxHead</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> startIndex,<span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headSort</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> startIndex=length/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=startIndex;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        makeMaxHead(<span class="built_in">array</span>,i,length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>]=<span class="built_in">array</span>[length<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">array</span>[length<span class="number">-1</span>]=temp;</span><br><span class="line">    headSort(<span class="built_in">array</span>,--length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">makeMaxHead</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> startIndex,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> iTop;</span><br><span class="line">    <span class="type">int</span> iLeft;</span><br><span class="line">    <span class="type">int</span> iRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        iTop=startIndex;</span><br><span class="line">        iLeft=startIndex*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> iRight=(startIndex+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(iLeft&lt;length&amp;&amp;<span class="built_in">array</span>[iLeft]&gt;<span class="built_in">array</span>[iTop])&#123;</span><br><span class="line">            iTop=iLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iRight&lt;length&amp;&amp;<span class="built_in">array</span>[iRight]&gt;<span class="built_in">array</span>[iTop])&#123;</span><br><span class="line">            iTop=iRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iTop!=startIndex)&#123;</span><br><span class="line">            <span class="type">int</span> temp =<span class="built_in">array</span>[iTop];</span><br><span class="line">            <span class="built_in">array</span>[iTop]=<span class="built_in">array</span>[startIndex];</span><br><span class="line">            <span class="built_in">array</span>[startIndex]=temp;</span><br><span class="line">            startIndex=iTop;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>待更新</tag>
        <tag>算法&amp;数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2018/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;key&quot;:value</span><br></pre></td></tr></table></figure>
<p>计数排序使用的就是这个办法<br>复杂度O(n+max)<br>缺点：空间复杂度高，无法对浮点数或负数进行对比（数组下标不能为负数）</p>
<p>桶排序<br>每个里面装几个，再用其它进行排序，可以解决空间</p>
<p>基数排序<br>从个位到最高位，一级一级排列，每次都会把数字放在这个位数确定的地方<br>如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52 4554 555 6569 46444</span><br><span class="line">第一次</span><br><span class="line">52 4554 46444 555 6569</span><br><span class="line">第二次</span><br><span class="line">46444 52 4554 555 6569</span><br><span class="line">第三次</span><br><span class="line">52 46444 4554 555 6569</span><br><span class="line">第四次</span><br><span class="line">52 555 4554 6569 46444</span><br></pre></td></tr></table></figure>

<h1 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue(队列)"></a>queue(队列)</h1><p>先进先出（访问）<br>查询快速，不好删除</p>
<h1 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack(栈)"></a>stack(栈)</h1><p>后进先出，撤回就是此种</p>
<h1 id="linkList（链表）"><a href="#linkList（链表）" class="headerlink" title="linkList（链表）"></a>linkList（链表）</h1><p>删除更改方便，查询缓慢</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>层级结构都比较像一棵树<br>几个概念：</p>
<ul>
<li>层</li>
<li>深度</li>
<li>节点个数 叶子节点 非叶子节点</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>每次最多只分两个叉</p>
<ul>
<li>节点个数等于2^层数-1</li>
</ul>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>所有叶子节点都是全的 </p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>除最后一层外，所有层数都是满的，且最后一层只有右边是缺的或不缺</p>
<p>完全二叉树和满二叉树都可以用数组实现（因为有规律）</p>
]]></content>
      <tags>
        <tag>算法&amp;数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>方方的推荐书目/影片</title>
    <url>/2018/03/21/%E6%96%B9%E6%96%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%9B%AE-%E5%BD%B1%E7%89%87/</url>
    <content><![CDATA[<h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><ul>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> 《图解http》<br> 已读，感觉讲的比较概括，head头的各种参数讲的比较多，基本就是去HTTP这家大商场逛一圈，知道有什么店，店里卖什么还要以后再看</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《黑客与画家》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《只是为了好玩》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《JavaScript高级程序设计》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《编码》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《软件随想录》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《代码大全》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《点石成金》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《用户体验的要素》</li>
</ul>
</li>
</ul>
<h1 id="影片"><a href="#影片" class="headerlink" title="影片"></a>影片</h1><ul>
<li><ul>
<li><input disabled="" type="checkbox"> 《硅谷传奇》</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 《Helvetica》</li>
</ul>
</li>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> 《Code Rush》<br>已读，看完就下载了firefox</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>没有edu邮箱如何注册JetBrains免费教育账户？</title>
    <url>/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>你是在读的学生，能够在学信网查询到你的学籍信息。</p>
<h2 id="1-获得在线学籍报告"><a href="#1-获得在线学籍报告" class="headerlink" title="1. 获得在线学籍报告"></a>1. 获得在线学籍报告</h2><p>首先访问<a href="https://my.chsi.com.cn/" title="点此访问学信网">学信网</a>，没有注册的话，注册一个，然后登陆。</p>
<p>你会看到这样的界面<br><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step1.png"></p>
<p>点击<code>在线验证报告</code>，<code>申请</code>。</p>
<p>申请完成后你就能看到这样的在线验证报告。<br><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step2.png"></p>
<p>你可以以pdf文档格式保存起来，不过目前你只需要<strong>复制当前页面的链接</strong>。</p>
<h2 id="2-前往JetBrains注册"><a href="#2-前往JetBrains注册" class="headerlink" title="2. 前往JetBrains注册"></a>2. 前往JetBrains注册</h2><p>前往<a href="https://www.jetbrains.com/" title="点此访问JetBrains">JetBrains</a>，注册你的账户，注册成功会出现这样的界面，询问你获得许可证的方式。<br><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step3.png"></p>
<p>点击<code>Apply for free student or teacher license</code></p>
<p>就可以进入到教育许可证详情页面，如果你早已注册，你也可以手动访问<a href="https://www.jetbrains.com/zh/student/">JetBrains教育许可证</a></p>
<p>点击<code>APPLY NOW</code>或中文的<code>立即申请</code></p>
<p>你会看到这样的页面<br><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step4.png"><br>点击<code>Official document</code> 使用官方文档</p>
<p>如实的填写你的信息，如果你还需要两年及更长的时间毕业，请勾选<br><code>My education institution is accredited and takes 2 or more years of full-time study to complete</code><br><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step5.png"><br>请务必正确填写你的<strong>在线验证报告地址</strong>。</p>
<p><code>Comment</code>是可选的，你可以不必填写</p>
<h2 id="3-一切完成，静候佳音"><a href="#3-一切完成，静候佳音" class="headerlink" title="3. 一切完成，静候佳音"></a>3. 一切完成，静候佳音</h2><p><img data-src="/2018/03/19/%E6%B2%A1%E6%9C%89edu%E9%82%AE%E7%AE%B1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CJetBrains%E5%85%8D%E8%B4%B9%E6%95%99%E8%82%B2%E8%B4%A6%E6%88%B7%EF%BC%9F/step6.png"></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>自己来实现观察者模式</title>
    <url>/2020/09/24/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="自己来实现观察者模式"><a href="#自己来实现观察者模式" class="headerlink" title="自己来实现观察者模式"></a>自己来实现观察者模式</h1><p>今天写自己一个小demo时使用mvc的时候，想自己来实现观察者模式<br>也就是view层会观察model层数据的变化，相应渲染出改变后的数据</p>
<h1 id="使用发布订阅模式"><a href="#使用发布订阅模式" class="headerlink" title="使用发布订阅模式"></a>使用发布订阅模式</h1><p>最开始想的办法是自己model拥有多个修改<code>model.data</code>的方法，如<code>fetch()</code>,<code>patch()</code>,<code>delete()</code>,<code>post()</code>,只需要每个方法里加一句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.<span class="title function_">emit</span>(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="variable language_">this</span>.<span class="property">data</span>)</span><br></pre></td></tr></table></figure>
<p>就能通知在监听的view层进行渲染了</p>
<p>不过有点不优雅，我需要在每个改变数据的方法后都加一句，很麻烦。</p>
<h1 id="使用Object-defineProperty来自动化"><a href="#使用Object-defineProperty来自动化" class="headerlink" title="使用Object.defineProperty来自动化"></a>使用Object.defineProperty来自动化</h1><p>之后想到了ES5提供的**<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>**提供的<code>get</code>和<code>set</code>存取描述符，对这个属性的访问和读取会分别触发<code>get</code>和<code>set</code>函数, 也就是如果对<code>data</code>进行设置，就会触发<code>set</code>函数。</p>
<h2 id="get-和set-又是什么？"><a href="#get-和set-又是什么？" class="headerlink" title="get()和set()又是什么？"></a><code>get()</code>和<code>set()</code>又是什么？</h2><p>我们平常取值或者赋值都是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.<span class="property">val</span> = <span class="number">1</span> <span class="comment">//现在val = 1</span></span><br><span class="line">data.<span class="property">val</span>  <span class="comment">//得到 val的值</span></span><br></pre></td></tr></table></figure>
<p>在这个过程中，val就是一个值，获得val和修改val总是相等的，修改成多少，之后就会得到多少。</p>
<p>不过js是门很奇怪的语言，有时候会发现获得的值和修改的值不一样，比如<code>cookie</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> <span class="comment">//xxx=111; yyy=222;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;zzz=333&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> <span class="comment">//xxx=111; yyy=222; zzz=333</span></span><br></pre></td></tr></table></figure>
<p>看这里，赋值和取值并不相等，就像是自己调用的是方法一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">get</span>() <span class="comment">//xxx=111; yyy=222</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">set</span>(<span class="string">&quot;zzz=333&quot;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">get</span>() <span class="comment">//xxx=111; yyy=222; zzz=333</span></span><br></pre></td></tr></table></figure>
<p>似乎是这样的感觉。<br>原理也就是这样，在js中我们可以把赋值这个过程当成函数调用<br>赋值调用<code>set</code>函数 ,取值使用<code>get</code>函数。</p>
<p>ES5就提供了<code>Object.defineProperty</code>来自己定义赋值和取值得行为<br><code>Object.defineProperty</code>接受三个参数，要定义的对象，要定义的键名，定义行为的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cookieList = []</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">document</span>,<span class="string">&#x27;myCookie&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> cookieString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        cooieList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            cookieString+value+<span class="string">&#x27;; &#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> cookieString</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        cookieList.<span class="title function_">push</span>(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myCookie</span> <span class="comment">// &quot;&quot; 空字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myCookie</span> = <span class="string">&quot;aaa=111&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myCookie</span> <span class="comment">//&quot;aaa=111; &quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myCookie</span> = <span class="string">&quot;bbb=222&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myCookie</span> <span class="comment">//&quot;aaa=111; bbb=222&quot;</span></span><br></pre></td></tr></table></figure>
<p>这就是我们仿写的一个cookie，取值变成了调用<code>get</code>函数，赋值变成了调用<code>set()</code>函数<br>ES6有了定义对象的语法糖，也更简洁明了些</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Barack&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Obama&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123; <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nameArray = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        firstName = nameArray[<span class="number">0</span>]</span><br><span class="line">        lastName = nameArray[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> <span class="comment">//Barack Obama</span></span><br><span class="line">person.<span class="property">name</span>  = <span class="string">&#x27;Karl Marx&#x27;</span></span><br><span class="line">firstName  <span class="comment">//Karl</span></span><br><span class="line">lastName <span class="comment">//Marx</span></span><br></pre></td></tr></table></figure>
<p>其实在这里设置<code>get</code>和<code>set</code>, 有点像java, java中一切皆对象，类中常常有私有变量不能被外部访问，就通过<code>getName()</code>和<code>setName()</code>暴露api<br>通过这种方式，就能对赋值和取值进行控制，比如赋值的时候检测值是否合法这些，js就直接省略了写函数这部分，直接就能把赋值、取值的行为当作函数调用。<br>不过这种也很误导，赋值和取值竟然会不相等，那为什么不直接告诉我这是一个方法？实际情况下不应该胡乱使用<code>get</code>和<code>set</code></p>
<hr>
<p>另外查了下，语法似乎更像c#</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Class example</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> a &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> b &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> c &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，回到正题，现在我们可以在赋值时，通知View层数据改变了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//do xxxxx</span></span><br><span class="line">        event.<span class="title function_">emit</span>(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.<span class="property">data</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">//触发set()</span></span><br></pre></td></tr></table></figure>

<p>不过马上就发现<code>Object.defineProperty</code> 并不怎么好用</p>
<ol>
<li><p><code>get</code> <code>set</code>存取描述符会导致递归问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = value</span><br><span class="line">        event.<span class="title function_">emit</span>(<span class="string">&#x27;dataChanged&#x27;</span>,<span class="variable language_">this</span>.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.<span class="property">data</span> <span class="comment">//递归调用 页面会卡死</span></span><br></pre></td></tr></table></figure>
<p> 解决办法很简单,不使用data就可以了，比如使用<code>this._data</code>，或者使用闭包，利用外部环境的变量。</p>
</li>
<li><p>如果<code>model.data</code>的值不是原始类型，而是对象，那么对<code>model.data</code>对象的的更改不会触发<code>set()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(model,<span class="string">&#x27;data&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_data</span> = value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">model.<span class="property">data</span> <span class="comment">//get</span></span><br><span class="line">model.<span class="property">data</span>.<span class="title function_">push</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">//get</span></span><br><span class="line"><span class="keyword">let</span> data = model.<span class="property">data</span> <span class="comment">//get</span></span><br><span class="line">data.<span class="title function_">push</span>(&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="comment">//不会调用get set</span></span><br><span class="line">data <span class="comment">//不会调用get</span></span><br></pre></td></tr></table></figure>
<p> 在实际情况中，往往<code>data</code>都是一堆对象，存储的是引用，解决办法大概可以判断是否是对象，如果是，就递归的定义<code>get</code>和<code>set</code>,或者判断这是否是一个会更改<code>data</code>的函数,总而言之是件挺麻烦的事</p>
</li>
<li><p><code>Object.defineProperty</code>只能设置已知的属性，不能对未知的属性进行设置<br> 这就导致上面递归解决方案行不通，因为在运行时定义的属性的key是未知的，以就无法设置<code>get</code>,<code>set</code></p>
</li>
</ol>
<h1 id="使用Proxy来更优雅的实现"><a href="#使用Proxy来更优雅的实现" class="headerlink" title="使用Proxy来更优雅的实现"></a>使用Proxy来更优雅的实现</h1><p><a href="http://es6.ruanyifeng.com/#docs/proxy">关于Proxy的说明可以点击这里</a>,Proxy可以看作是<code>Object.defineProperty()</code>的完全升级版，可以拦截各种对对象的操作，其中就包括<code>get</code>和<code>set</code>，Vue3就是基于<code>Proxy</code>来实现响应式跟踪的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = []</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">Proxy</span>(array,&#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target,key,value,receiver</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set <span class="subst">$&#123;key&#125;</span>`</span>) </span><br><span class="line">       <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target,key,value,receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> model=&#123;data&#125;</span><br><span class="line">model.<span class="property">data</span>.<span class="title function_">push</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">//set 0  set length   这里push操作会修改&#x27;0&#x27;和&#x27;length&#x27;</span></span><br><span class="line">array.<span class="title function_">push</span>(&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="comment">//原对象不会触发set</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy</code>翻译为代理，其实挺贴切的，从上面的例子中可以看出，<code>Proxy</code>并不会修改原始对象的行为，而是会生成一个代理对象，用于拦截各种操作。</p>
<p>同时浏览器还提供了<code>Reflect</code>用来更好的扩展默认行为，阮一峰在ES6文中是这样说的:</p>
<blockquote>
<p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
</blockquote>
<p>这个概念类似于子类重写父类的行为一样，可以让我们方便的在原来逻辑基础上添加一扩展行为。</p>
<p>最后贴下大概的最终代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//能够检测所有变动的核心，递归检测所有赋值为对象的情况，并代理这个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxyAllobj</span>(<span class="params">target, key, value, receiver,handler</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`SET key:<span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    排除value 为null的情况，因为typeof null === &#x27;object&#x27;</span></span><br><span class="line"><span class="comment">    如果这个对象已经是被代理的对象了，不重新代理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ( value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;_isProxy&#x27;</span>, receiver) !== <span class="literal">true</span>) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">Proxy</span>(value, handler)  <span class="comment">//使用新的代理对象替换原对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`正在代理化<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">let</span> obj = value</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> newKey <span class="keyword">in</span> obj) &#123;     <span class="comment">//递归检测这个对象中的对象</span></span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(newKey)) &#123;</span><br><span class="line">                <span class="keyword">const</span> nextValue = obj[newKey];</span><br><span class="line">                <span class="title function_">proxyAllobj</span>(obj, newKey, nextValue, obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`GET key:<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">&#x27;_isProxy&#x27;</span>) &#123; <span class="comment">//由于无法判断一个对象是否为代理对象，所以使用一个预留字段来检测是否为代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">proxyAllobj</span>(target, key, value, receiver,handler)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">Proxy</span>([], handler)</span><br><span class="line"></span><br><span class="line">data.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ddd = <span class="number">2</span></span><br><span class="line">data.<span class="title function_">push</span>(&#123; ddd &#125;)</span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">data[<span class="number">1</span>] = &#123; <span class="attr">aaa</span>: &#123; <span class="attr">hi</span>: <span class="string">&#x27;hi&#x27;</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>].<span class="property">aaa</span>.<span class="property">hi</span> = <span class="number">5</span> <span class="comment">//能够检测到</span></span><br><span class="line"><span class="keyword">const</span> test = data[<span class="number">1</span>].<span class="property">aaa</span></span><br><span class="line">test.<span class="property">q</span> = <span class="string">&#x27;haha&#x27;</span> <span class="comment">//能够检测到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure>
<p>这只是一个小demo，能够实现data内任何数据的改变都能检测到，可以复制到浏览器控制台验证，可能还存在bug，实际情况下应该还会涉及更复杂的错误处理还有性能方面的问题</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/proxy">ECMAScript 6 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN  Object.defineProperty()</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>自己试试写个jQuery小demo</title>
    <url>/2018/05/28/%E8%87%AA%E5%B7%B1%E8%AF%95%E8%AF%95%E5%86%99%E4%B8%AAjQuery%E5%B0%8Fdemo/</url>
    <content><![CDATA[<h2 id="要达到的效果"><a href="#要达到的效果" class="headerlink" title="要达到的效果"></a>要达到的效果</h2><p>我需要这个小demo可以在接受Node的实例和选择器，并且可以立即调用相关的操作方法</p>
<h2 id="侵入式或者非侵入式？"><a href="#侵入式或者非侵入式？" class="headerlink" title="侵入式或者非侵入式？"></a>侵入式或者非侵入式？</h2><p>我其实可以直接在Node的原型对象上加上我自己写的方法，其它什么都不用做，不过这种方式会霸占变量名，而且更改了原来的原型对象，很容易带来冲突 ，所以可以选择自己新增一个方法，从这个方法里调用原来Node的方法，不对原来的Node做任何变动，这种方式叫就非侵入式。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这里其实有两种实现方法，一种是直接用函数构造出具有相关方法属性的对象，一次搞定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> x =&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//找到的Node实例加到x种</span></span><br><span class="line">    x.<span class="property">a</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种是构造出相关属性的对象，再构造一个拥有相关方法的原型，将__proto__指向原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yyy =&#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> x =&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//找到的Node实例加到x种</span></span><br><span class="line">    x.<span class="property">__proto__</span>=yyy</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面这种方式会更好一点,不过先使用前一种种方式实现一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">jQuery</span> = <span class="keyword">function</span> (<span class="params">nodeOrSelection</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> elements = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelection === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(nodeOrSelection)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            elements[i] = temp[i]</span><br><span class="line">        &#125;</span><br><span class="line">        elements.<span class="property">length</span> = temp.<span class="property">length</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelection <span class="keyword">instanceof</span> <span class="title class_">Node</span>) &#123;</span><br><span class="line">        elements[<span class="number">0</span>] = nodOrSelection</span><br><span class="line">        elements.<span class="property">length</span> = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    elements.<span class="property">addClass</span> = <span class="keyword">function</span> (<span class="params">nodeClass</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            elements[i].<span class="property">classList</span>.<span class="title function_">add</span>(nodeClass)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elements.<span class="property">setText</span> = <span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            elements[i].<span class="property">textContent</span> = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">$</span> = jQuery</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">setText</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里还可以写个自己的forEach，这样不用每次都自己写遍历了。<br>OK.</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2019/01/15/%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<h1 id="虚拟DOM是什么？"><a href="#虚拟DOM是什么？" class="headerlink" title="虚拟DOM是什么？"></a>虚拟DOM是什么？</h1><p>虚拟DOM其实就是在原有DOM的基础中，在js中再做一层DOM的抽象。</p>
<h1 id="虚拟DOM有什么用？"><a href="#虚拟DOM有什么用？" class="headerlink" title="虚拟DOM有什么用？"></a>虚拟DOM有什么用？</h1><p>在一些需要大量更改DOM的情况下，比如更新表格内的内容，重新排序等，会引起重绘、重排、引起大量的性能消耗，虚拟DOM就是针对这个问题的一个解决方案，在更改前都是针对虚拟DOM进行操作，不对真实DOM进行更改，更改完成后使用diff算法对比DOM树，只操作需要更改的DOM节点，减小 性能开销。</p>
<h1 id="虚拟DOM怎么用？"><a href="#虚拟DOM怎么用？" class="headerlink" title="虚拟DOM怎么用？"></a>虚拟DOM怎么用？</h1><p>首先需要创建一个类似的虚拟DOM抽象数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tag, children, text</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">tag</span> === <span class="string">&#x27;#text&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="variable language_">this</span>.<span class="property">text</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">vChild</span> =&gt;</span> &#123;</span><br><span class="line">      el.<span class="title function_">appendChild</span>(vChild.<span class="title function_">render</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v</span>(<span class="params">tag, children, text</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> children === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    text = children</span><br><span class="line">    children = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(tag, children, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义一个简单虚拟node类，拥有本元素和子节点，拥有<code>render()</code>函数。</p>
<p>改变使用diff算法对比</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchElement</span>(<span class="params">parent, newVNode, oldVNode, index = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!oldVNode) &#123;</span><br><span class="line">    parent.<span class="title function_">appendChild</span>(newVNode.<span class="title function_">render</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!newVNode) &#123;</span><br><span class="line">    parent.<span class="title function_">removeChild</span>(parent.<span class="property">childNodes</span>[index])</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newVNode.<span class="property">tag</span> !== oldVNode.<span class="property">tag</span> || newVNode.<span class="property">text</span> !== oldVNode.<span class="property">text</span>) &#123;</span><br><span class="line">    parent.<span class="title function_">replaceChild</span>(newVNode.<span class="title function_">render</span>(), parent.<span class="property">childNodes</span>[index])</span><br><span class="line">  &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newVNode.<span class="property">children</span>.<span class="property">length</span> || i &lt; oldVNode.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">patchElement</span>(parent.<span class="property">childNodes</span>[index], newVNode.<span class="property">children</span>[i], oldVNode.<span class="property">children</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际远远比这个复杂，拥有更多细节要处理，不过理解的话够用了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>虚拟DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>试试脚本</title>
    <url>/2018/03/25/%E8%AF%95%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="脚本是啥？"><a href="#脚本是啥？" class="headerlink" title="脚本是啥？"></a>脚本是啥？</h1><h2 id="生活中的脚本"><a href="#生活中的脚本" class="headerlink" title="生活中的脚本"></a>生活中的脚本</h2><p>“脚本”一词来源于演艺界，指拍摄戏剧、电影所依据的底本</p>
<blockquote>
<p>公馆一室内<br>王妈：（小心翼翼地）小姐，您还是得注意身子，就吃点东西吧。<br>鸡小姐：（把碗砸在地上）不吃，我就是不吃。<br>（王妈下）</p>
</blockquote>
<p>事先剧组写好脚本，演出时依据脚本内容，设置舞台，演员按照剧本说出台词，做出动作，还有灯光道具等等。</p>
<p>当然，脚本也并不局限于此。<br>生活中也有许多脚本，领导上台的演讲，什么时候声音大一点，小一点，表情是怎么样的；老师备课，准备预计讲什么内容，什么时候一些提出小问题，答错了怎么引导学生思考，什么时候分享小故事，什么时候刺激学生，提高学生注意……</p>
<p>简而言之，其实就是根据写好的计划，让对象做指定的动作，一切都在把控之中。</p>
<h2 id="计算机中的脚本"><a href="#计算机中的脚本" class="headerlink" title="计算机中的脚本"></a>计算机中的脚本</h2><p>计算机是个很复杂的东西，为了让人类来操控它，有最基础的处理器指令集，处理器接受到二进制的机器码，执行指定动作，然而机器码的可读性很差，人类最易理解的是自然语言，汇编就在此产生了，给这些机器码加上了名字，随着计算机能力的提高，能做的越来越多，有了更多的指令，做更多的事，汇编的代码越来越多，但是大量汇编代码在一起，是及其难懂的，为了更好的进行开发并更好的让人类理解，高级语言出现了，也就是我们目前的接触的程序语言。</p>
<p>高级语言的确让开发更简单容易了，但是高级语言始终需要转换成机器码，编译、链接，直到运行，需要大量的时间，这种语言被称为<strong>编译型语言</strong>，为了解决这个问题（其实还有更多原因，比如跨平台问题），<strong>解释性语言</strong>出现了，解释型语言并不把整个项目进行全部编译成机器码，而是以行为单位，逐条编译运行，<strong>脚本语言</strong>也就出现了，只需输入可读的文字命令，就能立即执行动作，所输即所得。</p>
<p>值得注意的是，解释型，编译型，并不是个绝对的概念，解释性语言也并不等于脚本，实际情况中有很多混合的地方，比如java，首先源代码经过编译变成跨平台的字节码（中间码），然后字节码交由java虚拟机进行解析，整个过程既有编译的地方，又有解释的地方。许多脚本语言也可以经过整体编译后再执行，所以这之间的界限并不明确。</p>
<h1 id="自己写一个简单脚本"><a href="#自己写一个简单脚本" class="headerlink" title="自己写一个简单脚本"></a>自己写一个简单脚本</h1><p><strong>默认Linux系统</strong><br>目标：自动根据给出的文件名生成目录，并在其下生成index.html及相关js,css文件夹及文件</p>
<pre><code> ├── css
 │   └── style.css
 ├── index.html
 └── js
     └── main.js
</code></pre>
<h2 id="bash脚本"><a href="#bash脚本" class="headerlink" title="bash脚本"></a>bash脚本</h2><p>bash是Unix操作系统的纯命令的人机交互界面，也是控制Unix系统的脚本语言，可以通过编写bash脚本来自动控制操作系统。</p>
<p>bash脚本住主要由日常使用的命令组成，很方便<br>新建一个文件，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;error: dir exists&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">mkdir</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">mkdir</span> css js</span><br><span class="line">  <span class="built_in">touch</span> index.html css/style.css js/main.js</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>保存退出<br>添加执行权限：<code>chmod +x 文件名</code><br>sh .&#x2F;文件名 搞定</p>
<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><p>能在服务器端运行的JavaScript的运行环境<br>同样新建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> dirName =process.<span class="property">argv</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fs.<span class="title function_">existsSync</span>(<span class="string">&quot;./&quot;</span>+dirName))&#123;</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(<span class="string">&quot;./&quot;</span>+dirName)</span><br><span class="line">    process.<span class="title function_">chdir</span>(<span class="string">&quot;./&quot;</span>+dirName)</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;css&#x27;</span>)</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&quot;./index.html&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&quot;css/style.css&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&quot;./js/main.js&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样保存退出，添加执行权限</p>
<p>使用node.js运行它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node ./文件名</span><br></pre></td></tr></table></figure>
<p>不想每次打开都输入<code>node</code>?<br>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure>
<p>这样就指定使用了node运行，实际上不指定，使用的是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>也就是bash解释器（吧？）。</p>
<h2 id="给自己写的脚本添PATH"><a href="#给自己写的脚本添PATH" class="headerlink" title="给自己写的脚本添PATH"></a>给自己写的脚本添PATH</h2><p>写了脚本执行却总需要加上路径？<br>添加进PATH就可以解决</p>
<ol>
<li><p>打开~&#x2F;.bashrc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~./bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>找个喜欢的位置输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;脚本所在的绝对路径:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p> 保存退出</p>
</li>
<li><p>应用修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~./bashrc</span><br></pre></td></tr></table></figure>
<p> ok,现在就可以在任何地方执行脚本啦！</p>
<p> 如果要查看你目前的PATH路径</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p> 看看我的</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">/home/geylnu/bin:/home/geylnu/.local/bin:/home/geylnu/local:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</span><br></pre></td></tr></table></figure></li>
</ol>
<p>匹配命令是从PATH路径<strong>从前向后找</strong>，优先是使用前面的可执行程序。<br>可以使用<code>type -a 命令</code>，查询命令匹配的选项，使用<code>which 命令</code>，查看要最终执行的是哪一个。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说Vue3的watchEffect与React Hooks的useEffect</title>
    <url>/2020/10/10/%E8%AF%B4%E8%AF%B4Vue3%E7%9A%84watchEffect%E4%B8%8EReact-Hooks%E7%9A%84useEffect/</url>
    <content><![CDATA[<p>最近有空阅读了一下 Vue3 的文档，发现 Vue 也新增了类似 React Hooks 中的 useEffect 的 watchEffect，两者基本很相似，这里就来比较比较。</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h3><p>React Hooks 带有一种函数式的设计理念，期望 <code>UI = f(x)</code>，UI 是纯函数的渲染结果，useEffect 则用来处理副作用，也就是对外部环境的影响，在 Hooks 中基本取代了生命周期的概念,类似于原本的<code>componentDidMount</code>和<code>componentWillUnmount</code>。</p>
<p>常见的在 useEffect 中请求数据</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">example</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hasCancle = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">query</span>(<span class="string">&quot;/xxxx&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 避免副作用被取消后仍然调用</span></span><br><span class="line">      <span class="keyword">if</span> (!hasCancle) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = data;</span><br><span class="line">        <span class="title function_">setCount</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除副作用</span></span><br><span class="line">      hasCancle = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a><code>watchEffect</code></h3><p>watchEffect 作用基本与 useEffect 作用一致，上面的代码可以很方便的改写为 Vue 版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_">watchEffect</span>( <span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> hasCancle = <span class="literal">false</span>;</span><br><span class="line">      <span class="title function_">query</span>(<span class="string">&quot;/xxxx&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasCancle) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; count &#125; = data;</span><br><span class="line">          <span class="title function_">setCount</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">onInvalidate</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          hasCancle = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管功能上 watchEffect 与 useEffect 十分相似，但由于实现不一，实质还是有很多不同</p>
<h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><p>在 React 中，<code>useEffect</code>被用来处理与界面无关的副作用，会在 React 更新 DOM 后调用，这样可以尽快的展现渲染结果，如果涉及到对 DOM 的副作用操作，则可以使用<code>useLayoutEffect</code>在重渲染期间调用，以避免浏览器重渲染。</p>
<p>而在 Vue 中，watchEffect 的调用时机则由<code>watchEffect</code>函数的第二个参数控制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(</span><br><span class="line">  <span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do xxx</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">flush</span>: <span class="string">&quot;pre&quot;</span>, <span class="comment">// &#x27;pre&#x27; | &#x27;post&#x27; | &#x27;sync&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>watchEffect 的默认调用时机<code>pre</code>，按照官方文档，它有两次调用时机</p>
<ul>
<li>在初始化时被同步调用</li>
<li>在组件被更新前</li>
</ul>
<p>watchEffect 类似于<code>beforeCreate</code>与<code>beforeUpdate</code>，但是实际还是有不小区别</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watchEffect</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watchEffect sync&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">flush</span>: <span class="string">&quot;sync&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watchEffect pre&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watchEffect</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watchEffect post&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeMount&quot;</span>));</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>));</span><br><span class="line">    <span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onBeforeUpdate&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onUpdated&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync setup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码调用顺序会是这样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watchEffect sync</span><br><span class="line">watchEffect pre</span><br><span class="line">sync setup</span><br><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">watchEffect post</span><br><span class="line">onMounted</span><br></pre></td></tr></table></figure>

<p>我们可以看到 setup 函数里所有的内容都会被首先被调用，调用时机为 <code>pre</code> 和 <code>sync</code> 的 watchEffect 函数也会被同步调用，调用顺序取决于声明顺序，而调用时机为<code>post</code>的 watchEffect 函数 则会在 DOM 元素挂载后调用。</p>
<p>对于三种不同刷新方式，其实可以很简单的理解：</p>
<ul>
<li><code>pre</code> 初始化会在 setup 函数中被同步调用，此后总在组件更新前调用</li>
<li><code>post</code> 初始化会在元素挂载后，此后总在组件更新后调用，总能获取实际的渲染结果</li>
<li><code>sync</code> 初始化会在 setup 函数中被同步调用，此后总在状态更改时同步调用</li>
</ul>
<p>当然。在大多数情况下，我们其实不需要关心时机，仅在涉及到对 DOM 的副作用时做下区分，比如获取 ref</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button ref=&quot;buttonRef&quot; @click=&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; watchEffect, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const count = ref(0);</span><br><span class="line">    const buttonEL = ref(null);</span><br><span class="line">    watchEffect(() =&gt; &#123;</span><br><span class="line">      console.log(buttonRef.value?.innerText); // 初始化: undefined 第一次调用: count is 0</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watchEffect(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        console.log(buttonRef.value?.innerText); // 初始化: &lt;button&gt; 第一次调用: count is 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flush: &quot;post&quot;,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>flush: &quot;post&quot;</code>,可以保证总是获取到最新的 DOM。</p>
<p>总的来说，Vue 和 React 在处理副作用上走上了不同的道路，React 倾向于尽快的进行重渲染，在渲染结束后执行副作用以避免 UI 线程等待；而 Vue 默认会在渲染更新前调用，更新的结果会直接体现在这次的渲染结果中。</p>
<h4 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h4><p>在 React 中，<code>useEffect</code>经常出现的错误就是进行了递归的重渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 这会导致递归调用,setCount触发了重渲染，副作用重新执行</span></span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<p>在 Vue 中，如果这个值仅被单个副作用函数依赖则并不会导致递归调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>值会正确的更新，同时这次的副作用不会被更新。</p>
<p>然而如果被多个副作用函数依赖，或者被异步调用，仍然会导致递归调用</p>
<p>多个依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总而言之，在 watchEffect 应该尽量小心的更新值。</p>
<h4 id="取消副作用"><a href="#取消副作用" class="headerlink" title="取消副作用"></a>取消副作用</h4><p>在 React 中，取消副作用的函数通过函数返回值返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do xxxxx</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而在异步函数中这会存在问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetchData</span>(props.<span class="property">id</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do xxxxx</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步函数返回的是一个 promise,我们无法在异步调用完成前拿到取消函数。</p>
<p>因此，为了更好地与 asnyc 函数调用兼容，在Vue中，取消函数以回调的方式注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;...&#125;) <span class="comment">// 我们在Promise解析之前注册清除函数</span></span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchData</span>(props.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>Vue 由于响应式原理，可以自动的进行依赖收集，React 则需要手动填写依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">&#125;, [count]); <span class="comment">//手动声明依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 在每次更改count时都会调用。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue 会在第一次运行副作用函数执行时进行自动的依赖收集，类似于目前的<code>computed</code>属性。<br>然而，依赖收集只发生在同步调用时，Vue 无法知道异步调用时使用的依赖，</p>
<p>比如下面这个例子，来自于 github 上的一个<a href="https://github.com/vuejs/vue-next/issues/2223" title="watchEffect doesn&#39;t work when perform async ">issues</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffectTest</span>(<span class="params">reactive, watchEffect</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watchEffect</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timmer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    obj.<span class="property">age</span>++;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="property">age</span> &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timmer);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;stop&quot;</span>, obj.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">watchEffectTest</span>(reactive, watchEffect);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>预期输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">stop 6</span><br></pre></td></tr></table></figure>

<p>实际输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">stop 6</span><br></pre></td></tr></table></figure>

<p>当然，这种缺陷也可以通过手动的读取一次依赖，告诉Vue这是依赖项，仅仅是在编写时会并不优雅。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>React</tag>
        <tag>Hooks</tag>
        <tag>副作用</tag>
      </tags>
  </entry>
  <entry>
    <title>说说浏览器下载的那些事儿</title>
    <url>/2020/09/25/%E8%AF%B4%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>最近突然在 chrome 85 版本上遇到下载后会出现”xxx 下载方式实属异常 因此它可能存在危险”，去看了下相关的谷歌博客，定位是谷歌的浏览器安全策略引起的。<br>实际上浏览器下载还有不少坑，这次就接这个机会总结一下。</p>
<h2 id="前端如何实现文件下载？"><a href="#前端如何实现文件下载？" class="headerlink" title="前端如何实现文件下载？"></a>前端如何实现文件下载？</h2><h3 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h3><p>在 download 属性出现之前，前端实现文件下载实际上依赖于浏览器的默认行为，也就是打开链接。</p>
<p>通常我们可以直接这样实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;http://xxxx&quot;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(url);</span><br></pre></td></tr></table></figure>

<p>这会以指定的 url 打开一个新窗口，浏览器在根据 url 获得到服务器的响应，判断出这不是一个浏览器可以打开的文件类型，就自动会转为下载。</p>
<p>在段代码在正常情况下是能够工作正常的，然而实际上有些业务场景，下载链接是后台生成的，我们需要这样做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clickHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  api.<span class="title function_">get</span>(<span class="string">&#x27;xxx&#x27;</span>, params).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="keyword">let</span> url = data.<span class="property">data</span>.<span class="property">url</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">open</span>(url);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在几乎所有的现代浏览器上都会被阻止，在 Chrome 上会在地址栏显示被拦截的标志，用户需要手动点击才能成功，Safari 会静默失效。<br>这是由于早期网页经常在页面插入自动打开广告页面，带来很糟糕的用户体验，因此浏览器做了限制，会禁止所有的异步回调中调用的 window.open()</p>
<p>当然了，浏览器限制也拦不过各种奇思妙想，既然无法在异步代码中调用 window.open()，那先在同步代码中调用，等待异步调用完成，改变新开的浏览器窗口的 url 就好了。<br>下面的代码就是一种实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clickHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> windowObjectReference = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  api.<span class="title function_">get</span>(<span class="string">&#x27;xxx&#x27;</span>, params).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="keyword">let</span> url = data.<span class="property">data</span>.<span class="property">url</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        windowObjectReference.<span class="property">location</span>.<span class="property">href</span> = url;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上述的原因，使用了 window.open(), 无法打开页面是很容易发生的事，这时 window.open(）会返回 null，需要做一些失败后的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;xxxx&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// do xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="window-location-href"><a href="#window-location-href" class="headerlink" title="window.location.href"></a>window.location.href</h3><p>尽管可以以上面的方式绕过浏览器的安全限制，然而这种行为是不确定，永远无法知道浏览器会在哪一个版本改变这种做法，更安全的行为是使用 window.location.href</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">herf</span> = <span class="string">&quot;http://xxxx&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式下载是手动让浏览器跳转到指定页面，浏览器发现是不支持预览的文件类型，自动转为下载，由于浏览器加载链接到发现这是一个应该下载的资源需要一定时间，这会造成页面白屏一段时间，表现的像是页面闪动一样</p>
<p>为了避免闪动，也有人想出了在 iframe 中调用 window.location.href 中的办法，由于链接是在 iframe 里加载的，也就不会出现闪动了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无闪现下载excel</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">download</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">iframeLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;iframe onload&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> win = iframe.<span class="property">contentWindow</span>;</span><br><span class="line">    <span class="keyword">const</span> doc = win.<span class="property">document</span>;</span><br><span class="line">    <span class="keyword">if</span> (win.<span class="property">location</span>.<span class="property">href</span> === url) &#123;</span><br><span class="line">      <span class="keyword">if</span> (doc.<span class="property">body</span>.<span class="property">childNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// response is error</span></span><br><span class="line">      &#125;</span><br><span class="line">      iframe.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;onload&quot;</span> <span class="keyword">in</span> iframe) &#123;</span><br><span class="line">    iframe.<span class="property">onload</span> = iframeLoad;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iframe.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    iframe.<span class="title function_">attachEvent</span>(<span class="string">&quot;onload&quot;</span>, iframeLoad);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iframe.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> <span class="title function_">onreadystatechange</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iframe.<span class="property">readyState</span> === <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">        iframeLoad;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  iframe.<span class="property">src</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">loadUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="property">contentWindow</span>.<span class="property">location</span>.<span class="property">href</span> = url;</span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 iframe 的顾虑和使用 window.open 的顾虑一样，这依赖于浏览器的默认安全策略，我们无法知道浏览器会在哪天把创建 iframe 进行下载定义为危险的行为并进行拦截。</p>
<h3 id="使用-lt-a-gt-标签"><a href="#使用-lt-a-gt-标签" class="headerlink" title="使用 &lt;a&gt; 标签"></a>使用 &lt;a&gt; 标签</h3><p>这实际上是目前大多数前端下载库的实现方式，会动态创建一个隐藏的 &lt;a&gt; 标签，通过 Blob 转换为 data 链接，点击这个 data 链接，浏览器会默认将这个文件 data 链接的内容进行保存。<br>15k start 的<a href="https://github.com/eligrey/FileSaver.js">FileSaver.js</a>就是这样实现的。</p>
<p>这样的方式相比直接打开或者直接使用链接的好处在于许多文件类型可以下载，而不是变为预览。</p>
<p>除此之外，&lt;a&gt; 还能支持 download 属性，这是真正的浏览器语义上的下载属性，以上除 data 链接的方式，浏览器都会抛出控制台警告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource interpreted as Document but transferred with MIME type application xxx</span><br></pre></td></tr></table></figure>

<p>浏览器的请求头会附带这样的 Accept 头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: xxxx</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br></pre></td></tr></table></figure>

<p>使用 download 属性后，浏览器发出的请求头会像这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: xxxx</span><br></pre></td></tr></table></figure>

<p>浏览器不会带上 Accept 头，甚至请求也不会出现在开发者工具中，会直接进行下载。</p>
<p>虽然 download 属性非常好用，但是还有一些限制：</p>
<blockquote>
<p>此属性仅适用于同源 URL<br>尽管 HTTP URL 需要位于同一源中，但是可以使用 blob: URL 和 data: URL ，以方便用户下载使用 JavaScript 生成的内容（例如使用在线绘图 Web 应用程序创建的照片）。<br>如果 HTTP 头中的 Content-Disposition 属性赋予了一个不同于此属性的文件名，HTTP 头属性优先于此属性。</p>
</blockquote>
<p>download 属性支持所有现代浏览器，而 IE 理所当然的不支持，需要进行一些特殊处理。</p>
<h2 id="后端如何实现文件下载？"><a href="#后端如何实现文件下载？" class="headerlink" title="后端如何实现文件下载？"></a>后端如何实现文件下载？</h2><h3 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h3><p>实际上，在 HTTP 响应中加上 Content-Disposition 是浏览器兼容性最好的下载方式，大多数的浏览器都支持这种方式.</p>
<p>Content-Disposition 可以指定浏览器是以附件的形式下载文件，还是以页面的一部分预览展示,同时也可以指定文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Disposition: inline</span><br><span class="line">Content-Disposition: attachment</span><br><span class="line">Content-Disposition: attachment; filename=&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure>

<h2 id="还存在的一些问题"><a href="#还存在的一些问题" class="headerlink" title="还存在的一些问题"></a>还存在的一些问题</h2><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>IOS 由于系统是每个应用都是一个沙盒，没有为用户暴露文件系统，如果用户 IOS 手机上没有安装对应的打开软件是无法进行下载的。</p>
<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>在最新的谷歌浏览器版本中(chrome 84+)，会开始逐渐限制 https 网站下载 http 内容，其中可执行文件 exe、压缩文件都会警告下载方式十分危险，并且在未来可能所有通过 http 下载的可执行内容都会被阻止。尽管理解谷歌这种方式可能是为了防止中间人攻击替换下载内容，不过推进方式还是蛮激进的。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>download</tag>
        <tag>微信H5</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈经常出现的出现的“深拷贝”</title>
    <url>/2020/02/17/%E8%B0%88%E8%B0%88%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%BA%E7%8E%B0%E7%9A%84-%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>想想已经 N 久没有写文章了，有点怠惰，之后还是尽量学了什么，就写文章记录下来；写文章的过程也是自己把知识联系起来的过程。<br>写这篇文章主要原因还是之前字节跳动三面，面试官一开始就要去写一个深拷贝，然而之前对这方面了解的很少很少，面试表现可以说相当差了，结果也是直接挂掉…<br>之后重新学习了，这里就记录下吧</p>
<h2 id="怎样定义深拷贝？深拷贝到底要拷贝什么？"><a href="#怎样定义深拷贝？深拷贝到底要拷贝什么？" class="headerlink" title="怎样定义深拷贝？深拷贝到底要拷贝什么？"></a>怎样定义深拷贝？深拷贝到底要拷贝什么？</h2><p>说起深拷贝，就得说下内存结构了，内存就是一断特殊的电路，我们通过对内存的储存结构进行编码，某个内存地址对应内存某一个储存数据的地方，最小储存单元是 8 个 bit; 我们甚至可以把最小储存单元定义为 1 个 bit，但是这通常没有必要，因为我们需要针对每一个储存单元设置清除电路，而现实使用时的数据大多都会超过 1 个 bit，为了更小的储存单元而把电路变得更复杂完全不值得。<br>如果我们使用的数据超过最小储存单元，我们就把连续几个内存地址一起用了，记录首个地址，记录它使用个几个内存地址，也就是它的类型，比如<code>int</code>, 在大多数实现上，一般是 4 个字节，也就是连续占用 4 个地址，这些我们称之为基本类型。</p>
<p>而如果我们要储存的数据包含多种类型，我们也可以按照这种方式，按顺序存储下来，记录首个地址，记录它使用了那些地址，通常我们还会有一些对应的函数来操作这些对应的数据，我们通常把这种结构称作为对象，相关的操作函数就被称作方法。</p>
<p>当数据被作为函数的参数传递时，基本类型和对象有很明显的差异</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">num</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b.<span class="property">num</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(number, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;num: 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果值是一个基本类型，那传递给函数的是它直接的值，也就是值的拷贝；而如果是对象，我们传递的是它的储存位置，也就是地址值，或者更抽象的说法，对象的引用，通过这个引用操作到真正的对象。</p>
<p>不过这其中有一个类型是个特例，那就是<code>string</code>，在 java 中<code>string</code>是一个对象，有各种操作方法，然而却表现的像基本类型一样，像是一个怪胎。在知乎中有许多相关的提问</p>
<ul>
<li>[Java 语言中 String a&#x3D;”a”;String b&#x3D;”a”; 为什么 a&#x3D;&#x3D;b 值为 true？]</li>
<li>[Java 到底是值传递还是引用传递？]</li>
<li>[如何理解 String 类型值的不可变？]</li>
</ul>
<p>而在 js 中<code>string</code>中直接被定义为基本类型</p>
<ul>
<li>[MDN-string]</li>
</ul>
<p>实际上，字符串的确是一个对象，只不过为了更好用，我们把它改造成了一个“基本类型”，在我们日常使用中，我们一般很少把字符串进行重新修改，甚至不能修改，有大量场景直接把字符串作为 key 值，有大量密码验证场景使用的就是字符串，如果改动了，一切就乱套了。总而言之，<code>string</code>不应该能被修改</p>
<p>在老大哥 Java 的实现中，<code>string</code>是以常量池的形式维护，每次新建一个<code>string</code>，都会从常量池中寻找是否已存在相同的字符串，如果有直接就返回引用，如果没有则创建。得益于 string 的不可变性，才可以高效的复用相同字符串，甚至像基本类型一样直接比较。js 也实现了类似的设计。</p>
<p>而深拷贝，实际就是拷贝数据里所有可变的数据结构，把新数据和老数据隔离开，避免更改一处数据结构，而更改多处。也就是直接返回所有基本类型和不可变对象，递归复制所有可变的对象。</p>
<h2 id="怎么进行深拷贝？"><a href="#怎么进行深拷贝？" class="headerlink" title="怎么进行深拷贝？"></a>怎么进行深拷贝？</h2><p>搞清除要复制什么东西，只是个起步，深拷贝能经常出现在面试题并不是由于它有多实用，工作中有多常见；主要深拷贝这一块儿会涉及到很多 js 的各种知识，各种边界条件，很能考察面试者的知识深度。</p>
<ol>
<li><p>对于基本类型，直接返回<br>js 中有 7 种基本类型，分别是 <code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>symbol</code>, <code>undefined</code>, <code>null</code>,<br>除了 null 和 function 以外，在<code>typeof</code>操作符下都显示为自己的类型名称，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>我们可以自定义一个<code>ownTypeof</code>方法来正好的帮助我们在深拷贝时判断类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> primitiveTypes = [</span><br><span class="line">  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bigint&quot;</span>,</span><br><span class="line">  <span class="string">&quot;boolean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;symbol&quot;</span>,</span><br><span class="line">  <span class="string">&quot;undefined&quot;</span>,</span><br><span class="line">  <span class="string">&quot;null&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ownTypeof</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">if</span> (primitiveTypes.<span class="title function_">includes</span>(type) || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;primitive&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些值就可以直接返回，不经过任何处理。</p>
</li>
<li><p>如果是对象，遍历对象的所有值<br>这里也有许多门道，js 提供了太多根据 key 值循环处理的方法，</p>
<ul>
<li>for in<br>最常见的循环方法，遍历对象所有可遍历的字符串 key，无法遍历不可遍历的 key,会遍历到原型上的属性,无法遍历 symbol key,</li>
<li>Object.keys()<br>基本等同于<code>for in</code>，除了不会遍历到原型上的属性</li>
<li>Reflect.ownKeys()<br>获取对象所有的 key ，包括不可遍历的 key，symbol key, 等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。<br>这里为了方便就直接用 Es6 的新方法<code>Reflect.ownKeys()</code>，简单又快速。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> typeofValue = <span class="title function_">ownTypeof</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (typeofValue === <span class="string">&quot;primitive&quot;</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(value);</span><br><span class="line">  <span class="keyword">const</span> finalValue = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    finalValue[key] = <span class="title function_">deepClone</span>(value[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决环引用<br>事实上这里我们的代码已经能勾复制大多数普通对象了，但是会碰见序列化时遇见的一个常见问题：环引用，我们通常会在使用 JSON 时遇到相似的错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a.<span class="property">self</span> = a;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a); <span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<p>而在我们编写的深拷贝函数种，这会直接导致无限递归，直到栈溢出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a.<span class="property">self</span> = a;</span><br><span class="line"></span><br><span class="line"><span class="title function_">deepClone</span>(a); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<p>解决环引用其实很简单，栈溢出的原因是我们的函数在不停的重复拷贝一个相同的对象，而实际上，如果这是一个重复的对象，我们直接返回它自身的引用就可以了。我们可以通过建立新老对象引用的映射达到这一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">value, cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> typeofValue = <span class="title function_">ownTypeof</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (typeofValue === <span class="string">&quot;primitive&quot;</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">get</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(value);</span><br><span class="line">  <span class="keyword">const</span> finalValue = &#123;&#125;;</span><br><span class="line">  cache.<span class="title function_">set</span>(value, finalValue);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    finalValue[key] = <span class="title function_">deepClone</span>(value[key], cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里基本的一个深拷贝实际上基本就完成了，然而其实还有更多的 edge case, 也就是由于这个原因，实现一个深拷贝很难很难</p>
</li>
<li><p>edge case</p>
<ul>
<li><p>是否考虑原型？<br>在继承了 Java 一切皆对象的思想， js 每一个对象都有一个原型，实际上，我们直接返回它的原型，只把它当作单独的数据处理，因为拷贝原型的代价十分高昂</p>
</li>
<li><p>是否复制函数？<br>在任何实现里面，我相信函数都是不可拷贝的，也无需拷贝，这是因为函数生成以后，其执行的代码就不可更改了，这是一个不可变数据结构，我们理所当然的也不需要考虑再复制一份代码。<br>除此之外还有一个重要原因是我们无法获得函数运行时的作用域，即使我们通过<code>toString()</code>获得源代码，也无法获得函数运行时的作用域。</p>
</li>
<li><p>是否拷贝对象描述符？<br>对象描述分别有两种，一种是数据描述符，一种是存取描述符，数据描述符是可复制的，存取描述符依赖于函数，无法复制</p>
</li>
<li><p>如果复制内置对象？<br>在 js 种，有许多对象是内置的，我们无法通过除其本身的构造函数外，创建出这个对象，比如最常见的数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> copyArray = <span class="title function_">deepClone</span>([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(copyArray); <span class="comment">// &#123; &quot;1&quot;: 1, &quot;2&quot;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>即使我们拷贝了它的原型，它表现的也像是个普通对象，而不是一个数组，我们为其复制，length 属性也不会一同变换。<br>这是由于数组是 js 的内置的对象，有独有的处理逻辑。<br>类似的对象有许多许多：Date、RegExp、Map、Set、Blob，这也是整个过程最复杂的一块，不同的内置对象复制逻辑也不同。</p>
<p>对于这种情况，则只能根据它的对象类型，使用其构造函数创建它。<br>我们可以使用<code>instanceof</code>来确人对象是不是这些内置对象的实例，不过通常使用更方便的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/test/</span>); <span class="comment">// [object RegExp]</span></span><br></pre></td></tr></table></figure>

<p>使用这个方式，我们可以直接读取这个对象类的名称，并进行相应处理。</p>
</li>
</ol>
<p>使用上面的方式，基本就可以写出一个不错的深拷贝，在实际上编写中也是一个踩坑的过程，会了解许多日常忽视的 js 知识，对于一个面试题，称的上不错了。</p>
<p>但是实际使用中，我们应该尽量避免大量使用深拷贝，这是一种大量浪费内存的行为，如果你需要的是不可变性，更应该采用一些提供 Immutable 特性的库。</p>
<p>[Java 语言中 String a&#x3D;”a”;String b&#x3D;”a”; 为什么 a&#x3D;&#x3D;b 值为 true？]: <a href="https://www.zhihu.com/question/57697842/answer/210583977">https://www.zhihu.com/question/57697842/answer/210583977</a> “Java 语言中 String a&#x3D;”a”;String b&#x3D;”a”; 为什么 a&#x3D;&#x3D;b 值为 true？”<br>[Java 到底是值传递还是引用传递？]: <a href="https://www.zhihu.com/question/31203609/answer/576030121">https://www.zhihu.com/question/31203609/answer/576030121</a> “Java 到底是值传递还是引用传递？”<br>[如何理解 String 类型值的不可变？]: <a href="https://www.zhihu.com/question/20618891">https://www.zhihu.com/question/20618891</a> “如何理解 String 类型值的不可变？”<br>[MDN-string]: <a href="https://developer.mozilla.org/en-US/docs/Glossary/string">https://developer.mozilla.org/en-US/docs/Glossary/string</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象吧！</title>
    <url>/2018/05/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%A7%EF%BC%81/</url>
    <content><![CDATA[<h1 id="全局对象window"><a href="#全局对象window" class="headerlink" title="全局对象window"></a>全局对象window</h1><p>标准里名为 global<br>但浏览器实现为window，global具有的window都有</p>
<h2 id="ECMAScript规定的"><a href="#ECMAScript规定的" class="headerlink" title="ECMAScript规定的"></a>ECMAScript规定的</h2><p>如：</p>
<ul>
<li>parseInt()</li>
<li>parseFloat()</li>
<li>……</li>
</ul>
<h2 id="浏览器私有"><a href="#浏览器私有" class="headerlink" title="浏览器私有"></a>浏览器私有</h2><p>每个浏览器不一样，<br>比如chrome&#x2F;firefox具有</p>
<ul>
<li><code>alert()</code><br>  弹出提示框<br>还有</li>
<li><code>prompt()</code><br>  提示输入</li>
<li><code>confirm()</code><br>  提示确认</li>
<li><code>console()</code><br>  控制台打印</li>
<li><code>setTimeout(function,3000)</code><br>  指定毫秒后执行函数</li>
<li><code>document</code><br>  document也是私有的<br>  dom规范由w3c指定</li>
</ul>
<h1 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h1><p><code>var n = new number(1)</code><br>把1包装成对象，会有更多的一些方法</p>
<p>但是基本类型其实也可以使用各种方法，这是因为JS会在发现把其当作对象时，自动以它的值创建对象，调用结束就把它删除，这就像java的自动装箱&#x2F;拆箱，所有的基本类型都是如此，包括string</p>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>
<p>这两者功用是一样的</p>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><ul>
<li>.toString(a) a指定以几进制显示</li>
<li>.charAt()返回指定索引的字符</li>
<li>.charCodeAt(0) 返回指定索引的unicode编码</li>
<li>.trim 去掉多余的空格</li>
<li>.concat(s) 将当前字符串与参数里面的字符串连接起来并返回（那和<code>+</code>有什么区别？）</li>
<li>.slice(1,2)  返回指定索引到指定索引的字符(0,1]</li>
</ul>
<h2 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h2><p><strong>注意：new Boolean() 也是true</strong></p>
<h1 id="原型链（继承？）"><a href="#原型链（继承？）" class="headerlink" title="原型链（继承？）"></a>原型链（继承？）</h1><h2 id="为了解决什么问题？"><a href="#为了解决什么问题？" class="headerlink" title="为了解决什么问题？"></a>为了解决什么问题？</h2><p>某一类对象拥有共同的方法，或属性，每个对象都声明一次既费时间又浪费内存，这时候使用继承就OK啦！</p>
<h2 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h2><p>拥有共通属性的对象，把共通的属性抽象出来作为一个父对象，子对象不再存储这些共通的属性和方法，而使用__proto__存储父对象。</p>
<h3 id="当我像调用toString-时，过程是怎样的？"><a href="#当我像调用toString-时，过程是怎样的？" class="headerlink" title="当我像调用toString()时，过程是怎样的？"></a>当我像调用<code>toString()</code>时，过程是怎样的？</h3><p>过程：</p>
<ol>
<li>判断是否是对象，如果是，自动装箱将其包装成对应的临时包装对象。</li>
<li>查找当前对象是否包含<code>toString()</code>方法。</li>
<li>如果当前对象不包括，访问<code>__proto__</code>里存储的父对象，继续寻找<code>toString()</code></li>
<li>如果找到停止寻找，否则继续递归下去。</li>
</ol>
<p>从这里就可以看出，如果子对象和父对象拥有同样的方法&#x2F;或者属性，总是使用的子对象的值，我们可以把这个称作覆盖</p>
<p>Object是所有对象的父对象，Object再向上就为null</p>
<h3 id="如何设置公有属性？"><a href="#如何设置公有属性？" class="headerlink" title="如何设置公有属性？"></a>如何设置公有属性？</h3><p>这里我们其实需要理解是如何创造对象的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>
<p>在这里 其实<code>new Object()</code>实际在调用一个函数，我们可以称作这个函数为构造函数，函数返回一个根据参数生成的对象。</p>
<p>因此这里可以看做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实质上，在js中，函数也只是一种对象</p>
<h4 id="Function对象"><a href="#Function对象" class="headerlink" title="Function对象"></a>Function对象</h4><p>如果我们使用<code>console.dir</code>打印Obeject、Number、Function的所有属性，我们就能真正理解__proto__和prototype具体是个什么鬼</p>
<ul>
<li>Function  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">prototype : <span class="title function_">f</span>()</span><br><span class="line">__proto__ : <span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>展开<code>prototype</code>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">prototype : <span class="title class_">Object</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Object  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prototype : 一堆我看不懂的东西</span><br><span class="line">__proto__ : <span class="title function_">f</span>()</span><br></pre></td></tr></table></figure></li>
<li>Number  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prototype : 一堆我看不懂的东西</span><br><span class="line">__proto__ : <span class="title function_">f</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们发现了什么？<br>我们知道使用new 关键字创建的对象会得到原型对象的<code>prototype</code>的地址并保存在<code>__proto__</code>中，这样就能共用方法及属性。</p>
<p>但是，原型对象又怎么产生？<br>这里就解释了一切，Function是所有原型对象的爸爸，所有的原型对象都是Function构造的，而Function爸爸需要让所有原型对象最后都继承自Object，这样才能面向对象嘛，所以<code>prototype</code>中的<code>__proto__ : Object</code>表示继承自Object，这种处理方式可能就叫中间层?</p>
<p>至于<code>__proto__</code>指向自己，我猜测可能是在某些情况需要<code>new Function</code>来创造一个Function子对象，这样就能让Function表里如一。</p>
<p>以上很多都是自己的猜测，可能有许多谬误，以后加深理解了再来更新，不说了，图还没画完呢…赶作业去了</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>风院电脑选购指南</title>
    <url>/2018/07/26/%E9%A3%8E%E9%99%A2%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要简单介绍一下风景园林&#x2F;环境设计专业软件需要啥子具体要求，顺带科普一下参数具体有什么用</p>
<h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><p>我们专业主要使用的软件是以下几个</p>
<ul>
<li><p>CAD<br>  2019版本官方配置表</p>
<ul>
<li>cpu 2.5-2.9Ghz处理器  建议：3+Ghz处理器</li>
<li>内存 8GB              建议：16GB</li>
<li>显卡 显存1Gb,29Gb&#x2F;s带宽,与DirectX 11 兼容 建议：显存4GB，106GB&#x2F;s带宽，与 DirectX 11 兼容<br>  来源：<a href="https://knowledge.autodesk.com/zh-hans/support/autocad/learn-explore/caas/sfdcarticles/sfdcarticles/CHS/System-requirements-for-AutoCAD-2019-including-Specialized-Toolsets.html">AutoCAD系统要求</a></li>
</ul>
<p>  总结：cpu这里的意思就是CPU主频尽可能的高，多核心多线程对于速度不会有太大提升，对于显卡的要求很粗略，只是需要一个快速且大的显存，目前一般的独立显卡都能满足这个要求，实际上显卡对于CAD来说并不重要。内存自然是越大越好，8G温饱，16G小康</p>
</li>
<li><p>PS<br>  2018版本官方配置表</p>
<ul>
<li>cpu Intel® Core 2 或 AMD Athlon® 64 处理器；2 GHz 或更快处理器</li>
<li>内存 2GB或更大RAM，推荐8GB</li>
<li>显卡 支持OpenGL 2.0<br>  在其<a href="https://helpx.adobe.com/cn/photoshop/kb/photoshop-cc-gpu-card-faq.html">帮助页面</a>还给出了更多的解释<ul>
<li>最小显存512MB,建议显存2GB<br>  来源：<a href="https://helpx.adobe.com/cn/photoshop/system-requirements.html">系统要求|Photoshop</a></li>
</ul>
</li>
</ul>
<p>  总结：PS的cpu这里给出的配置相当模糊，我去查询了第三方测评。第三方测评的意见认为，PS多线程优化仍然不够好，大量的核心并不能明显提升PS性能，但是第8代CPU由于直接多了两个物理核心，尽管优化不好，但仍然有看见的提升，Core i7 8700K比Core i7 7700K快9-14%</p>
<p>  由于PS需要处理大量高质量素材文件，非常占用内存和暂存盘空间，对于PS来说，更大的内存空间，更高的内存频率能够明显提高其性能表现。由于内存条较为昂贵，在不升级的情况下，把固态硬盘作为PS的暂存盘也是提高其性能的一个手段.</p>
<p>  PS对于显卡的要求并不高，参考官方的帮助页面，部分对于图像变形，模糊，选择和蒙版会使用GPU进行加速，一些滤镜效果必须使用显卡，但是要求并不高，集成显卡就已经能较好完成大部分的工作，一般的独立显卡，如1050，部分功能的确会相比集成显卡有更大的提升（30%），但更高的显卡，对于提升整体性能表现的帮助相当小。</p>
</li>
<li><p>SU<br>  SketchUp Pro 2018官方配置表</p>
<ul>
<li>cpu 1Ghz处理器 推荐2G+hz处理器</li>
<li>内存 4GB 推荐8+GB</li>
<li>显卡 OpenGL 3.0或更高，显存512MB及以上<br>  来源：<a href="https://help.sketchup.com/en/sketchup/sketchup-hardware-and-software-requirements">SketchUp Hardware and Software Requirements</a></li>
</ul>
<p>  总结：su做为一个3D建模软件，把一个任务拆开由多个线程负责的优化是十分困难的，多核CPU不会为它带来提升，单核性能决定了它的性能表现。SU对于显卡的要求很模糊，我去其官方社区找到了答案，SU在大多数情况下，中档的显卡和顶级的显卡，差别是很轻微而不明显的，在SU中视窗内显示的模型由显卡和CPU共同管理，显卡负责模型的光线显示效果（例如阴影，纹理等），cpu负责几何体的生成（如面，边缘），当模型越来越多时，cpu性能就会构成瓶颈。<br>  除此之外，绘图卡（专业卡）与游戏卡相比，不会带来更好的性能变现，反而贵很多。</p>
</li>
<li><p>v-Ray</p>
<ul>
<li>cpu 奔腾4及以上，所有支持SSE3指令集的CPU</li>
<li>内存 4GB和最低4GB的虚拟内存 ，推荐8GB及以上和8GB以上虚拟内存</li>
<li>显卡 无<br>  来源：<a href="view-source:https://docs.chaosgroup.com/display/VRAYSKETCHUP/System+Requirements#SystemRequirements-Windows">System Requirements - V-Ray for SketchUp</a></li>
</ul>
<p>  总结：这个配置实际上是一个能装vray的配置，实际上要看具体硬件。v-ray有两种渲染模式，CPU渲染和GPU渲染，CPU渲染模式很成熟了，目前大多都是CPU渲染模式，vray利用CPU进行渲染时，会充分利用所有线程，榨干cpu所有性能，对于vray cpu 渲染来说，在频率差不多的情况下，选择具有多核多线程的cpu能更好的提高渲染速度。<br>  v-ray还支持使用GPU渲染，使用GPU渲染速度更快（如果显卡比较好的话），但兼容性没有传统的CPU渲染好，可能出现不正确的渲染结果，不过可以使用这个模式来快速预览渲染效果。</p>
<p>  无论那种模式，在渲染时都会使用大量贴图文件和产生渲染后的数据，使用cpu渲染会去占用大量的内存和虚拟内存，使用GPU渲染会占用大量的显存。建议至少8G的内存，高参数、大场景的情况下会占用更多的内存。</p>
</li>
<li><p>Lumion<br>  Lumion8 官方配置表</p>
<ul>
<li>显卡 最低2,000 PassMark得分，2GB显存，支持DirectX 11或更高，推荐8,000 PassMark得分，6GB或更多显存</li>
<li>cpu<br>  最低:理想主频为3.0+ Ghz<br>  推荐:尽可能高的主频，理想主频为4.0+ GHz， 更低的主频会对GTX 1080 或 Titan X构成瓶颈，超过四个cpu核心不会带来性能提高，像 i7-4790K i7-6700K  i7-7700K这种主频为4.0+Ghz的CPU是个好的选择，低于3.4G+的至强系列处理器则不被推荐。</li>
<li>内存<br>  最低 8Gb(简单场景)，并且尽可能高的内存频率<br>  推荐 16GB，尽可能高的内存频率</li>
<li>more<br>  Lumion 官方非常棒，给出了相当详尽的配置建议，他们自己也推荐了笔记本，pc配置，品牌台式机，甚至配件价格，推荐去看看他们的原文。<br>  来源：<a href="https://lumion.com/system-requirements.html">system-requirements</a></li>
</ul>
<p>  总结：官方非常棒，不需要总结了，这里我单独说下PassMark得分，可以去</p>
</li>
<li><p>3Ds MAX</p>
<ul>
<li>cpu 支持 SSE4.2 指令集的 64 位 Intel® 或 AMD® 多核处理器</li>
<li>显卡 官方给了一个建议<a href="https://knowledge.autodesk.com/sites/default/files/file_downloads/3dsmax2019_GFX_ResultsJun2018.pdf">显卡列表</a></li>
<li>内存 至少 4 GB RAM（建议使用 8 GB 或更大空间）</li>
</ul>
<p>  总结：3dmax官方这里给出的数据也很少，主要因为3ds Max自带渲染引擎，渲染引擎对cpu的要求自然没有上限了，3dmax在建模的时候仍然主要依靠单个CPU核心，不过显卡能够提供更多的帮助。渲染的话同vray,可以GPU和CPU，值得注意的是同价格的游戏卡与专业卡的表现几乎差不多，你不应该选择专业卡。</p>
</li>
<li><p>more 还有许多其它软件，这里不再列举，如果你想可以去自己查询哟~ 网络最大的百科全书！</p>
</li>
</ul>
<h2 id="硬件篇"><a href="#硬件篇" class="headerlink" title="硬件篇"></a>硬件篇</h2><p>总体来说，计算机的核心功能只有两个，计算和储存，计算机的大量部件都是为这两者服务的。计算机的计算功能一般是由cpu(中央处理器)和显卡提供的，而储存功能则有多个部件实现。</p>
<ul>
<li><p>cpu(中央处理器)<br>cpu是计算机的核心，就像人的大脑一样，处理各个部件传来的数据，对数据进行计算后返回结果；影响cpu快慢有很多因素，架构，指令集，主频，物理核心数等，但是一般来说同代处理器相同系列，主要看的是主频和核心数。</p>
<ul>
<li>主频<br>  主频以Hz为单位，我们常常见到的是2.6Ghz，4.0Ghz这种，对于主频的理解，可以理解为cpu就是一个大工厂，主频就是这个大工厂的的工人生产一个东西有多快。</li>
</ul>
<p>  cpu的频率不是固定的，可以在一定范围内自动或手动调节，频率越高，会带来更高的功耗和更多的热量。笔记本由于各个厂商的设计不同，散热能力强弱不一，能够提供的功耗也不一样，同一cpu的性能表现也会不一样。</p>
<ul>
<li><p>核心数<br>  核心数就是通常说的几核cpu，代表的是cpu工厂有几个工人一起生产，值得注意的是有多少个核心并不意味着能力的翻倍提高，因为一个软件运行时的工作，很难分配给不同核心，往往还是只由少数几个核心负责，多核心对于优化差的软件来说没有明显提高。</p>
<ul>
<li><p>睿频<br>  睿频就是多核cpu提高那些优化差的软件的方法，通俗的来说，就是cpu这个大工厂接了个只能一个人（单核心）单独干的活，而其它工人就闲着了，cpu觉得这不行，干脆让其它几个工人不干了，把工资（能提供的功耗）交给正在干活的工人（核心），让工人干的更起劲（单核的主频就提高了），也就干的更快了。</p>
</li>
<li><p>超线程<br>  超线程技术和睿频技术相反，是把一个核心分成两个线程（之前是一个核心对应一个线程），通俗来说，就是给工人（核心）点工具，让它一个人做两个人的活，虽然干的没一个人做一件事那么快，但总体来说做的更多了（无情老板压榨员工），超线程技术会略微降低cpu主频。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存<br>  内存也是电脑至关重要的部件，也是程序运行时所在的空间。计算机计算首先得得到数据，就像工人工作必须得到零件一样，快速的得到数据对于提高计算机速度有很大的帮助，对于我们平时一些小操作卡顿，往往并不是cpu算的太慢了，而是数据传给cpu的时间太久了。 </p>
<p>  但是储存的价格实际上极其昂贵，比如位于cpu上速度极快的L1缓存大概只有几十kb，稍微慢一点的L2缓存有几百kb，更大更慢的的L3则有几MB的样子，那我几百G的小姐姐怎么办？这里就要引入计算机存储的局部性原理了，局部性原理表示计算机中使用的数据，如果第一次被使用，第二次被使用，那块数据第三次也会被使用，简单的说就是计算机使用的数据大量都是重复的，我们可以只把最经常用到的数据存在最快的空间中，不经常的存在慢一些的空间中，这样就可以省储存空间了。</p>
<p>  运用这个原理，现代计算机就设计出了分级的储存架构。cpu自己拥有一部分缓存的能力，分为L1,L2,L3,速度分别递减，容量递增，随后是内存，容量很大多了，比如4G 8G 16G，但是比cpu的缓存慢多了(差了几个量级)，不过价格也降下来了，几百元不等，以上都是缓存，由于物理上的设计，其实并不能长久储存数据，一断电（关机）数据就会消失，真正储存数据的是硬盘，详细看硬盘章节。<br>  整个储存结构呈金字塔型，越上面速度越快，空间越少，存储的越常用的数据。</p>
<p>  通俗的说就是数据就是零件，拿给cpu大厂加工，常用的零件会被放到cpu大产的内部的仓库，cpu工厂的工人工作直接去取就是了，由于空间有限，这些仓库都非常非常小。内存就是一个远离cpu的另外仓库，空间大多了，不过距离很远，拿到cpu工厂要很久，更远的就是硬盘了，与cpu工厂的距离几乎不可想象了，所以一般要做什么（软件运行 ）都会先拿到内存仓库作为中转。</p>
<ul>
<li>内存频率 越快内存交换数据的能力越强，能够更快的把硬盘数据存入内存。</li>
<li>虚拟内存 由于内存实际上对于我们的计算机来说还是太少，现在一个浏览器都能占上G的内存，那么多程序，都要用内存，可能会超出实际内存，这时怎么办？系统会在硬盘上划出一块空间，这块空间就叫虚拟内存，如果内存快要满了，就把一部分它认为暂时不会工作的程序的内存移入虚拟内存，腾给其它程序用，程序要工作了，就又把它移回进内存，虚拟内存是内存不足的无奈之举，通常还是建议使用更大的内存。</li>
</ul>
</li>
<li><p>显卡<br>  cpu是个全能手，什么都能算，但是对于浮点数（就是带小数点的数）计算不是很擅长，而对图形的运算常常涉及到大量浮点数运算（比如求三角形的斜边长），特别涉及到3D的图形，cpu来计算会慢死，显卡（GPU）就是为了解决这个问题，显卡拥有超多简化的核心，这些核心设计出来就只是为了进行浮点数运算，可以做的特别小，特别多，一个显卡里面可以有上千个这种微型处理器（官方称之为流处理器）。CPU与GPU的关系就像人脑和计算器一样，一个什么都能做，但是就计算而言没计算器厉害。</p>
<p>  评价显卡的性能基本和cpu一致，不过显卡单个核心的主频远远低于CPU，但是核心数远远高于CPU，由于GPU做的事很单一，通过跑分来评测其性能是一个很好的办法。</p>
<p>  显卡主要分为两种，为集成显卡和独立显卡</p>
<ul>
<li><p>集成显卡<br>  一般指的就是cpu内置的显卡，一般比较弱，不过日常看看视频，玩玩小游戏，最低画质的网游还是可行的，GPU和CPU一样，计算也需要先把数据传给它，和内存称呼类似，我们把显卡所使用的快速存储空间叫做显存，集成显卡没有独立的显存，而是把内存一部分当做自己的显存，这部分通常非常小，一般只有几百MB</p>
</li>
<li><p>独立显卡<br>  更加强大的显卡，目前游戏显卡主流就两家，AMD和NVIDIA（英伟达），NVIDIA比较强势。独立显卡拥有自己独立的散热器，独立的供电，独立的显存（主流1G或更多），CPU享受的待遇它都有。</p>
<p>  独立显卡根据用途还可以分为游戏卡，绘图卡（专业卡），和计算卡，游戏卡就是我们平常使用的显卡，很擅长一帧帧画面粗略的快速计算，绘图卡则经过优化，更擅长绘图软件中的大量顶点的空间计算，值得注意的是，事实上专业卡与游戏卡并没太多不一样，绘图卡在绘图领域表现得更好，更多是因为在驱动层面对专业软件做了更好的适配。计算卡则是专门用来计算大量数据，主要用在科学计算和人工智能领域，一般人不需要。</p>
</li>
</ul>
</li>
<li><p>硬盘<br>  硬盘是我们计算机中最后一级存储结构，是最慢，也是容量最大的一级，计算机实际运行中，会先将硬盘数据读入内存，方便更快的与cpu进行数据交换，而程序运行中最常使用的指令这些数据，会被缓存在cpu自带的缓存中。</p>
<p>  硬盘分为两种硬盘</p>
<ul>
<li>机械硬盘 通过磁头划过磁盘得到数据，速度主要看单碟容量和磁盘碟片的转速度，消费级主要分为5400转和7200转，一般来说容量越大，转速越高，速度也就越快。</li>
<li>固态硬盘 固态硬盘使用的是闪存颗粒来储存数据，相比机械硬盘，速度有极大的提升，特别是在大量小文件写入&#x2F;读取上。</li>
</ul>
<p>  由于固态硬盘的价格比较昂贵，目前通用的方法是一个128或256的固态硬盘作为C盘，软件主要安装在C盘里，另外配一个大容量的机械盘，用来存电影，游戏这些庞大且不常用的数据。</p>
</li>
<li><p>屏幕<br>  由于屏幕对于设计行业来说相当重要，我这里单独讲下屏幕<br>  我们说屏幕，主要说的是屏幕的面板，屏幕面板的参数觉得我们视觉体验。</p>
<ul>
<li><p>面板类型<br>  主流的两大屏幕面板类型是TN屏和IPS屏</p>
<ul>
<li>TN屏：窄视角，色域低，屏幕响应时间短 主要作为游戏屏幕（主要还是便宜）</li>
<li>IPS屏：宽视角 色域低，屏幕响应时间略长 比较综合的屏幕</li>
<li>这里主要说的是低端屏幕面板，高端则很不一样</li>
</ul>
</li>
<li><p>色域<br>  色域是对于我们设计领域最重要的一个属性，色域是一种计算机对颜色编码的方法，不同色域拥有不同的对纯色的定义和不同的色彩范围。<br>  目前主流有以下几个色域标准：</p>
<ul>
<li>sRGB 是微软与惠普与1996年开发定下的色域标准，是目前世界上广泛使用的色域标准，手机，电脑默认都是这个色域标准，不是该色域标准的显示屏，需要载入对应的色彩管理配置文件，否则会使用近似的色彩代替，带来色彩的偏差。也因为这个原因，一般我们普通使用只需要使用一个尽可能覆盖100%sRGB标准色域的的显示屏就好了（其实达到95%以上的sRGB覆盖就算是专业级了）</li>
<li>NTSC 一个很老的彩色电视标准实际上目前已经很少使用了，但是一般测评和厂商展示数据都是使用这个标准,NTSC标准色域的色彩范围比sRGB大，并且大部分和sRGB重合，sRGB大约占NTSC标准的72%，所以我们经常说希望笔记本色域达到72%NTSC,但是实际上72%NTSC并不等于100%sRGB,可能是72%NTSC色域中的一部分颜色在100%sRGB色域显示之外，评测根据缺失和多出来的颜色，会说偏绿之类的结果，实际意思是相对于sRGB来说，色域覆盖偏向绿色。</li>
<li>adobeRGB adobe推出的色域标准，色彩范围略微超过NTSC，对于CMYK打印色域标准有更好的兼容性，而且由于adobe全家桶存在，对自己的adobeRGB兼容也很好，专业的平面设计领域可以使用adobeRGB。</li>
</ul>
</li>
<li><p>色准<br>  色准就是颜色显示是否准确，目前一般使用 ΔE（色彩偏离度） 来表示，越大表示与标准色彩差距越大，一般来说低于1就是很优秀的专业屏幕了。色准可以通过自己进行校色，部分降低色彩偏离度，提高色准。</p>
</li>
</ul>
<p>  显示器的指标其实是很复杂的，还有亮度，游戏关心的刷新率，色深等等，我这里仅仅只介绍对颜色影响至关重要的两个参数。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>麻烦的全局变量</title>
    <url>/2018/05/29/%E9%BA%BB%E7%83%A6%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>当我们使用下面的div的id是会发现得到的并不是我们想要的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parent) <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<p>全局变量很容易造成变量名冲突，应该尽量少的使用全局变量</p>
<h3 id="构建局部作用域"><a href="#构建局部作用域" class="headerlink" title="构建局部作用域"></a>构建局部作用域</h3><p>既然不能创建全局变量，我们就应该创建一个局部作用域<br>在使用<code>let</code>的情况下，一对<code>&#123;&#125;</code>就可以包含一个局部作用域，但在使用<code>var</code>的情况下，我们需要使用函数创建局部作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.<span class="title function_">call</span>()</span><br></pre></td></tr></table></figure>
<p>在一些浏览器中会遇到语法错误，我们可以使用<code>()</code>包裹整个函数，也可以在前面加上<code>-</code>或者<code>+</code>,或者<code>!</code>，只要是单目运算符都可以 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>全局变量</tag>
      </tags>
  </entry>
</search>
